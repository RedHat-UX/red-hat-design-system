{"version":3,"file":"render-light.js","sourceRoot":"","sources":["../../src/directives/render-light.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAC,SAAS,EAAE,SAAS,EAAC,MAAM,kBAAkB,CAAC;AACtD,OAAO,EAAC,iBAAiB,EAAC,MAAM,0BAA0B,CAAC;AAM3D,MAAM,oBAAqB,SAAQ,SAAS;IAE1C,MAAM;QACJ,8CAA8C;IAChD,CAAC;IACQ,MAAM,CAAC,IAAe;QAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,UAA6B,CAAC;QACpD,IAAI,OAAO,QAAQ,CAAC,WAAW,KAAK,UAAU,EAAE,CAAC;YAC/C,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC;QAChC,CAAC;QACD,OAAO;IACT,CAAC;;AAVM,qCAAgB,GAAG,IAAI,CAAC;AAajC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmFG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,SAAS,CAAC,oBAAoB,CAAC,CAAC;AAE3D,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,KAAc,EAAW,EAAE,CAC/D,iBAAiB,CAAC,KAAK,CAAiC,EAAE,gBAAgB,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart} from 'lit';\nimport {directive, Directive} from 'lit/directive.js';\nimport {getDirectiveClass} from 'lit/directive-helpers.js';\n\nexport interface RenderLightHost extends HTMLElement {\n  renderLight(): unknown;\n}\n\nclass RenderLightDirective extends Directive {\n  static _$litRenderLight = true;\n  render() {\n    /* SSR handled specially in render-lit-html */\n  }\n  override update(part: ChildPart) {\n    const instance = part.parentNode as RenderLightHost;\n    if (typeof instance.renderLight === 'function') {\n      return instance.renderLight();\n    }\n    return;\n  }\n}\n\n/**\n * This directive allows a host element to control its light DOM rendering in\n * addition to its shadow DOM rendering, by implementing a `renderLight()` method.\n *\n * Here's an example of an `<x-story>` element that intended to server and client\n * side render its light DOM, but only client-side render its shadow DOM.\n *\n * The light DOM will contain just content:\n *\n * ```html\n * <x-story>\n *   <h1>Hello World</h1>\n *   <p>This is a story about greeting the earth.</p>\n * </x-story>\n * ```\n *\n * On the client the shadow DOM renders as usually and contains the \"chrome\" or\n * the decoration and interactive elements:\n *\n * ```html\n * <x-story>\n *   #shadow-root\n *     <slot></slot>\n *     <button>Like</button>\n *   <h1>Hello World</h1>\n *   <p>This is a story about greeting the earth.</p>\n * </x-story>\n * ```\n *\n * Implementation (using `LitElement`):\n *\n * ```js\n * class StoryElement extends LitElement implements RenderLightHost {\n *\n *   @property() title;\n *   @property() body;\n *\n *   renderLight() {\n *     return html`\n *       <h1>${this.title}</h1>\n *       <p>${this.body}</p>\n *     `;\n *   }\n *\n *   render() {\n *     return html`\n *       <slot></slot>\n *       <button @client=${this.like}>Like</button>\n *     `\n *   }\n * }\n * ```\n *\n * To use the `renderLight()` method, the use-site of the element must opt into it\n * with the `renderLight()` directive:\n *\n * ```js\n * const story = {\n *   title: 'Hello World',\n *   body: 'This is a story about greeting the earth.',\n * };\n *\n * const t = (story) => html`\n *     <x-story\n *         .title=${story.title}\n *         .body=${story.body}>\n *       ${renderLight()}\n *     </x-story>`\n * ```\n *\n * This prevents contention on the light DOM between the user of the component\n * and the component itself. The component doesn't actually render to its\n * light DOM, its user does. The component provides the implementation.\n *\n * The component will also need to provide its light DOM styling. This is TBD,\n * but obviously won't be able to take advantage of shadow DOM scoping.\n *\n * The major advantage of structuring SSR'ed components this way is that we can\n * render the critical content on the server so that it's indexable and\n * renderable without loading component definitions, but we don't bloat the HTML\n * payload with copies of the component implementation markup. Users who have\n * split light an shadow DOM rendering in a similar way have reported that it's\n * faster to first contentful paint than the \"deep\" SSR that is common place.\n */\nexport const renderLight = directive(RenderLightDirective);\n\nexport const isRenderLightDirective = (value: unknown): boolean =>\n  (getDirectiveClass(value) as typeof RenderLightDirective)?._$litRenderLight;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RenderLightDirective};\n"]}