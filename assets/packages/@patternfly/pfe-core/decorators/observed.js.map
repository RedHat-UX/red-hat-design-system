{"version":3,"file":"observed.js","sourceRoot":"","sources":["observed.ts"],"names":[],"mappings":"AAOA,OAAO,EACL,kBAAkB,EAClB,0BAA0B,GAC3B,MAAM,gDAAgD,CAAC;AAgCxD,MAAM,UAAU,QAAQ,CAA4B,GAAG,EAAS;IAC9D,2CAA2C;IAC3C,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;QACnB,MAAM,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC;QAClC,OAAO,UAAS,KAAK,EAAE,GAAG;YACvB,KAAK,CAAC,WAAsC;iBAC1C,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,0BAA0B,CAAC,CAAC,CAAC,CAAC,CAAC;YAC1D,eAAe,CAAC,KAAK,EAAE,GAAuB,EAAE,oBAAoB,CAAC,CAAC;QACxE,CAAC,CAAC;KACH;SAAM;QACL,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC;QACvB,KAAK,CAAC,WAAsC;aAC1C,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,0BAA0B,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,eAAe,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KAC7B;AACH,CAAC;AAED,MAAM,UAAU,eAAe,CAC7B,KAAQ,EACR,GAAqB,EACrB,gBAAoC;IAEpC,MAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IAC/D,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE;QAChC,GAAG,UAAU;QACb,YAAY,EAAE,IAAI;QAClB,GAAG,CAAgC,MAAkB;YACnD,MAAM,MAAM,GAAG,IAAI,CAAC,GAAc,CAAC,CAAC;YACpC,yDAAyD;YACzD,UAAU,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAEpC,yCAAyC;YACzC,uDAAuD;YACvD,sFAAsF;YACtF,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE;gBAC1C,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;aAC7C;iBAAM;gBACL,6DAA6D;gBAC7D,qCAAqC;gBACrC,0DAA0D;gBAC1D,MAAM,gBAAgB,GAAG,gBAAgB,IAAI,IAAI,GAAG,SAAS,CAAC;gBAE9D,sEAAsE;gBACtE,gEAAgE;gBAChE,qEAAqE;gBACrE,IAAI,IAAI,CAAC,UAAU,EAAE;oBACnB,IAAI,CAAC,gBAAsC,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;iBAChE;qBAAM;oBACL,IAAI,CAAC,kBAAkB,CAAC,CAAC,KAAK,CAAC,GAAa,EAAE,gBAAgB,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;iBACjF;aACF;QACH,CAAC;KACF,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { ReactiveElement } from 'lit';\nimport type {\n  ChangeCallback,\n  ChangeCallbackName,\n  PropertyObserverHost,\n} from '../controllers/property-observer-controller.js';\n\nimport {\n  observedController,\n  PropertyObserverController,\n} from '../controllers/property-observer-controller.js';\n\ntype TypedFieldDecorator<T> = (proto: T, key: string | keyof T) => void ;\n\n/**\n * Calls a _fooChanged method on the instance when the value changes.\n * Works on any class field. When using on lit observed properties,\n * Make sure `@observed` is to the left (i.e. called after) the `@property`\n * or `@state` decorator.\n *\n * @example observing a lit property\n * ```ts\n * @observed @property() foo = 'bar';\n *\n * protected _fooChanged(oldValue?: string, newValue?: string) {}\n * ```\n *\n * @example using a custom callback\n * ```ts\n * @observed('_myCallback') size = 'lg';\n *\n * _myCallback(_, size) {...}\n * ```\n *\n * @example using an arrow function\n * ```ts\n * @observed((oldVal, newVal) => console.log(`Size changed from ${oldVal} to ${newVal}`))\n * ```\n */\nexport function observed<T extends ReactiveElement>(methodName: string): TypedFieldDecorator<T>\nexport function observed<T extends ReactiveElement>(cb: ChangeCallback<T>): TypedFieldDecorator<T>\nexport function observed<T extends ReactiveElement>(proto: T, key: string): void\nexport function observed<T extends ReactiveElement>(...as: any[]): void|TypedFieldDecorator<T> {\n  /** @observed('_myCustomChangeCallback') */\n  if (as.length === 1) {\n    const [methodNameOrCallback] = as;\n    return function(proto, key) {\n      (proto.constructor as typeof ReactiveElement)\n        .addInitializer(x => new PropertyObserverController(x));\n      observeProperty(proto, key as string & keyof T, methodNameOrCallback);\n    };\n  } else {\n    const [proto, key] = as;\n    (proto.constructor as typeof ReactiveElement)\n      .addInitializer(x => new PropertyObserverController(x));\n    observeProperty(proto, key);\n  }\n}\n\nexport function observeProperty<T extends ReactiveElement>(\n  proto: T,\n  key: string & keyof T,\n  callbackOrMethod?: ChangeCallback<T>\n) {\n  const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n  Object.defineProperty(proto, key, {\n    ...descriptor,\n    configurable: true,\n    set(this: PropertyObserverHost<T>, newVal: T[keyof T]) {\n      const oldVal = this[key as keyof T];\n      // first, call any pre-existing setters, e.g. `@property`\n      descriptor?.set?.call(this, newVal);\n\n      // if the user passed a callback, call it\n      // e.g. `@observed((_, newVal) => console.log(newVal))`\n      // safe to call before connectedCallback, because it's impossible to get a `this` ref.\n      if (typeof callbackOrMethod === 'function') {\n        callbackOrMethod.call(this, oldVal, newVal);\n      } else {\n        // if the user passed a string method name, call it on `this`\n        // e.g. `@observed('_renderOptions')`\n        // otherwise, use a default method name e.g. `_fooChanged`\n        const actualMethodName = callbackOrMethod || `_${key}Changed`;\n\n        // if the component has already connected to the DOM, run the callback\n        // otherwise, If the component has not yet connected to the DOM,\n        // cache the old and new values. See PropertyObserverController above\n        if (this.hasUpdated) {\n          this[actualMethodName as ChangeCallbackName]?.(oldVal, newVal);\n        } else {\n          this[observedController].cache(key as string, actualMethodName, oldVal, newVal);\n        }\n      }\n    },\n  });\n}\n"]}