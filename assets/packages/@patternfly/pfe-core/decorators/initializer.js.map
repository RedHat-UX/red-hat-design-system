{"version":3,"file":"initializer.js","sourceRoot":"","sources":["initializer.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,kBAAkB,EAAE,MAAM,wCAAwC,CAAC;AAE5E;;;;;;GAMG;AACH,MAAM,UAAU,WAAW,CAA4B,OAAiB;IACtE,OAAO,UAAS,KAAQ,EAAE,GAAW;QACnC,qCAAqC;QACpC,KAAK,CAAC,WAAsC,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;YACtE,MAAM,WAAW,GAAG,KAAK,CAAC,GAAc,CAA0B,CAAC;YACnE,MAAM,UAAU,GAAG,IAAI,kBAAkB,CAAC,QAA2B,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;YAC7F,IAAI,QAAQ,CAAC,WAAW,EAAE;gBACxB,UAAU,CAAC,aAAa,EAAE,CAAC;aAC5B;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type { ReactiveElement } from 'lit';\nimport type { Options } from '../controllers/light-dom-controller.js';\n\nimport { LightDOMController } from '../controllers/light-dom-controller.js';\n\n/**\n * Runs the decorated method in `connectedCallback`,\n * provided the element has light children, and sets\n * up a mutation observer to re-run the callback,\n * unless opted-out with `{ observe: false }`\n * @param  options        Set `observe` to `false` to skip mutation observer setup, or pass a MutationObserverInit as options\n */\nexport function initializer<T extends ReactiveElement>(options?: Options) {\n  return function(proto: T, key: string) {\n    // @TODO: allow multiple initializers\n    (proto.constructor as typeof ReactiveElement).addInitializer(instance => {\n      const initializer = proto[key as keyof T] as unknown as () => void;\n      const controller = new LightDOMController(instance as ReactiveElement, initializer, options);\n      if (instance.isConnected) {\n        controller.hostConnected();\n      }\n    });\n  };\n}\n"]}