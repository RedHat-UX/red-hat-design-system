{"version":3,"file":"floating-dom-controller.js","sourceRoot":"","sources":["floating-dom-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer } from 'lit';\nimport type { LitElement, ReactiveController, ReactiveControllerHost } from 'lit';\nimport type { StyleInfo } from 'lit/directives/style-map.js';\n\ntype Lazy<T> = T | (() => T | null | undefined);\n\ninterface FloatingDOMControllerOptions {\n  content: Lazy<HTMLElement>;\n  invoker?: Lazy<HTMLElement>;\n  arrow?: Lazy<HTMLElement>;\n  shift?: boolean;\n  padding?: number;\n  fallbackPlacements?: Placement[];\n}\n\ninterface ShowOptions {\n  offset?: OffsetValue;\n  placement?: Placement;\n  flip?: boolean;\n  fallbackPlacements?: Placement[];\n}\n\nexport type Anchor = '' | 'top' | 'left' | 'bottom' | 'right';\nexport type Alignment = 'center' | 'start' | 'end';\n\n/**\n * Controls floating DOM within a web component, e.g. tooltips and popovers\n */\nexport class FloatingDOMController implements ReactiveController {\n  #open = false;\n  #opening = false;\n  #cleanup?: () => void;\n  #anchor?: Anchor;\n  #alignment?: Alignment;\n  #styles?: StyleInfo;\n  #placement?: Placement;\n  #options: FloatingDOMControllerOptions;\n\n  get #invoker() {\n    const { invoker } = this.#options;\n    return typeof invoker === 'function' ? invoker() : invoker;\n  }\n\n  get #content() {\n    const { content } = this.#options;\n    return typeof content === 'function' ? content() : content;\n  }\n\n  get #arrow() {\n    const { arrow } = this.#options;\n    return typeof arrow === 'function' ? arrow() : arrow;\n  }\n\n  /** The crosswise alignment of the invoker on which to display the floating DOM */\n  get alignment(): Alignment {\n    return this.#alignment ?? 'center';\n  }\n\n  /** The side of the invoker on which to display the floating DOM */\n  get anchor(): Anchor {\n    return this.#anchor ?? '';\n  }\n\n  /**\n   * When true, the floating DOM is visible\n   */\n  get open(): boolean {\n    return this.#open;\n  }\n\n  /** The computed placement of the floating DOM */\n  get placement(): Placement {\n    return this.#placement ?? 'top';\n  }\n\n  /**\n   * Styles to apply to your element's container\n   *\n   * - `--_floating-content-translate`: translate to apply to floating content.\n   */\n  get styles(): StyleInfo {\n    return this.#styles ?? {};\n  }\n\n  constructor(\n    private host: ReactiveControllerHost,\n    options: FloatingDOMControllerOptions\n  ) {\n    host.addController(this);\n    this.#options = {\n      invoker: (() => host as LitElement),\n      shift: true,\n      ...options,\n    };\n  }\n\n  hostDisconnected(): void {\n    this.#cleanup?.();\n  }\n\n  async #update(\n    placement: Placement = 'top',\n    offset?: OffsetValue,\n    flip = true,\n    fallbackPlacements?: Placement[],\n  ) {\n    const { padding, shift } = this.#options;\n\n    const invoker = this.#invoker;\n    const content = this.#content;\n    const arrow = this.#arrow;\n    if (!invoker || !content) {\n      return;\n    }\n    const cache = new Map<Element, Element[]>();\n    const {\n      x,\n      y,\n      placement: _placement,\n      arrow: arrowData,\n    } = calculatePosition(invoker, content, {\n      strategy: 'absolute',\n      placement,\n      offset,\n      enableShift: shift,\n      shiftPadding: padding,\n      enableFlip: flip,\n      flipPadding: padding,\n      fallbackPlacements,\n      arrow: arrow ?? undefined,\n      arrowPadding: arrow ? arrow.offsetHeight / 2 : undefined,\n    }, cache);\n\n    if (arrow) {\n      const { x: arrowX, y: arrowY } = arrowData || {};\n\n      const staticSide = {\n        top: 'bottom',\n        right: 'left',\n        bottom: 'top',\n        left: 'right',\n      }[_placement.split('-')[0]] || '';\n\n      Object.assign(arrow.style, {\n        left: arrowX != null ? `${arrowX}px` : '',\n        top: arrowY != null && !['top'].includes(_placement) ? `${arrowY}px` : '',\n        right: '',\n        bottom: '',\n        [staticSide]: `-${arrow.offsetHeight / 2}px`,\n      });\n    }\n\n    this.#placement = _placement;\n    [this.#anchor, this.#alignment] = (this.#placement.split('-') ?? []) as [Anchor, Alignment];\n    this.#styles = {\n      '--_floating-content-translate': `${x}px ${y}px`,\n    };\n    this.host.requestUpdate();\n  }\n\n  /**\n   * Show the floating DOM\n   * @param [options={}]\n   * @param options.offset\n   * @param options.placement\n   * @param options.flip\n   * @param options.fallbackPlacements\n   * */\n  async show({ offset, placement, flip, fallbackPlacements }: ShowOptions = {}): Promise<void> {\n    const invoker = this.#invoker;\n    const content = this.#content;\n    if (!invoker || !content) {\n      return;\n    }\n    if (!this.#opening) {\n      this.#opening = true;\n      const p = this.#update(placement, offset, flip, fallbackPlacements);\n      this.#cleanup ??= autoUpdate(invoker, content, () =>\n        this.#update(placement, offset, flip, fallbackPlacements));\n      await p;\n      this.#opening = false;\n    }\n    this.#open = true;\n    this.host.requestUpdate();\n  }\n\n  /** Hide the floating DOM */\n  async hide(): Promise<void> {\n    await this.host.updateComplete;\n    while (this.#opening && !this.open) {\n      await new Promise(requestAnimationFrame);\n    }\n    this.#open = false;\n    this.#cleanup?.();\n    this.host.requestUpdate();\n    await this.host.updateComplete;\n  }\n}\n\n/*\n * The below is a recreation of the @floating-ui/dom package.\n * Published under the MIT license.\n * @see https://github.com/floating-ui/floating-ui/blob/master/LICENSE\n *\n * This file combines all floating-ui functionality into a single module\n * to reduce import waterfall and simplify maintenance. When CSS anchor\n * positioning reaches GA, this entire file can be deleted.\n */\n\n// =============================================================================\n// TYPE DEFINITIONS\n// =============================================================================\n\n// Basic type definitions\ntype Axis = 'x' | 'y';\ntype Side = 'top' | 'right' | 'bottom' | 'left';\ntype Length = 'width' | 'height';\ntype Strategy = 'absolute' | 'fixed';\n\n// Derived types\ntype AlignedPlacement = `${Side}-${'start' | 'end'}`;\n\nexport type Placement = Side | AlignedPlacement;\n\ntype Coords = Record<Axis, number>;\n\ntype Dimensions = Record<Length, number>;\n\ntype Rect = Coords & Dimensions;\n\ntype SideObject = Record<Side, number>;\n\ntype ClientRectObject = Rect & SideObject;\n\ntype Padding = number | Partial<SideObject>;\n\n// Core floating UI types (browser-specific)\ntype Boundary = Element | 'clippingAncestors';\ntype ElementContext = 'reference' | 'floating';\ntype FloatingElement = HTMLElement;\ntype ReferenceElement = Element;\ntype RootBoundary = 'viewport' | 'document' | Rect;\n\ntype OffsetValue = number | {\n  /**\n   * The axis that runs along the side of the floating element. Represents\n   * the distance (gutter or margin) between the reference and floating\n   * element.\n   * @default 0\n   */\n  mainAxis?: number;\n  /**\n   * The axis that runs along the alignment of the floating element.\n   * Represents the skidding between the reference and floating element.\n   * @default 0\n   */\n  crossAxis?: number;\n  /**\n   * The same axis as `crossAxis` but applies only to aligned placements\n   * and inverts the `end` alignment. When set to a number, it overrides the\n   * `crossAxis` value.\n   *\n   * A positive number will move the floating element in the direction of\n   * the opposite edge to the one that is aligned, while a negative number\n   * the reverse.\n   * @default null\n   */\n  alignmentAxis?: number | null;\n};\n\n// Helper objects\ntype OverflowAncestors = (Element | Window | VisualViewport)[];\n\ninterface ElementRects {\n  reference: Rect;\n  floating: Rect;\n}\n\ninterface Elements {\n  reference: ReferenceElement;\n  floating: FloatingElement;\n}\n\ninterface PositionState {\n  placement: Placement;\n  elements: Elements;\n  rects: ElementRects;\n  x: number;\n  y: number;\n  strategy: Strategy;\n  initialPlacement: Placement;\n}\n\ninterface ComputePositionReturn extends Coords {\n  /**\n   * The final chosen placement of the floating element.\n   */\n  placement: Placement;\n  /**\n   * The strategy used to position the floating element.\n   */\n  strategy: Strategy;\n  /**\n   * Arrow positioning data (if arrow was provided).\n   */\n  arrow?: Partial<Coords> & {\n    centerOffset: number;\n  };\n}\n\ninterface DetectOverflowOptions {\n  /**\n   * The clipping element(s) or area in which overflow will be checked.\n   * @default 'clippingAncestors'\n   */\n  boundary?: Boundary;\n  /**\n   * The root clipping area in which overflow will be checked.\n   * @default 'viewport'\n   */\n  rootBoundary?: RootBoundary;\n  /**\n   * The element in which overflow is being checked relative to a boundary.\n   * @default 'floating'\n   */\n  elementContext?: ElementContext;\n  /**\n   * Whether to check for overflow using the alternate element's boundary\n   * (`clippingAncestors` boundary only).\n   * @default false\n   */\n  altBoundary?: boolean;\n  /**\n   * Virtual padding for the resolved overflow detection offsets.\n   * @default 0\n   */\n  padding?: Padding;\n}\n\n/** calculatePosition args */\ninterface PositionConfig {\n  placement?: Placement;\n  strategy?: 'absolute' | 'fixed';\n  offset?: OffsetValue;\n  enableShift?: boolean;\n  shiftPadding?: number;\n  enableFlip?: boolean;\n  flipPadding?: number;\n  fallbackPlacements?: Placement[];\n  arrow?: HTMLElement;\n  arrowPadding?: number;\n}\n\n/** getCssDimensions return type */\ninterface CssDimensions {\n  width: number;\n  height: number;\n  $: boolean;\n}\n\n/** getClippingRect args */\ninterface ClippingRectArgs {\n  element: Element;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  strategy: Strategy;\n  cache: Map<Element, Element[]>;\n}\n\n/** autoUpdate args */\ninterface AutoUpdateOptions {\n  /**\n   * Whether to update the position when an overflow ancestor scrolls.\n   * @default true\n   */\n  ancestorScroll?: boolean;\n  /**\n   * Whether to update the position when an overflow ancestor is resized.\n   * @default true\n   */\n  ancestorResize?: boolean;\n  /**\n   * Whether to update the position when either the reference or floating\n   * elements resized.\n   * @default true\n   */\n  elementResize?: boolean;\n  /**\n   * Whether to update the position when the reference element moved on the\n   * screen (covered by another element, clipped by an ancestor, or scrolled\n   * out of view).\n   * @default true\n   */\n  layoutShift?: boolean;\n  /**\n   * Whether to update on every animation frame if required.\n   * @default false\n   */\n  animationFrame?: boolean;\n}\n\nconst absoluteOrFixed = new Set(['absolute', 'fixed']);\n\nconst noOffsets = createCoords(0);\n\nconst originSides = new Set(['left', 'top']);\n\nconst lastTraversableNodeNames = new Set(['html', 'body', '#document']);\n\nconst transformProperties = [\n  'transform',\n  'translate',\n  'scale',\n  'rotate',\n  'perspective',\n];\n\nconst willChangeValues = [\n  'transform',\n  'translate',\n  'scale',\n  'rotate',\n  'perspective',\n  'filter',\n];\n\nconst containValues = ['paint', 'layout', 'strict', 'content'];\n\nconst invalidOverflowDisplayValues = new Set(['inline', 'contents']);\n\nconst tableElements = new Set(['table', 'td', 'th']);\n\nconst topLayerSelectors = [':popover-open', ':modal'];\n\nconst oppositeSideMap: Record<Side, Side> = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom',\n};\n\nconst oppositeAlignmentMap: Record<Exclude<Alignment, 'center'>, Exclude<Alignment, 'center'>> = {\n  start: 'end',\n  end: 'start',\n};\n\nconst yAxisSides = new Set<Side>(['top', 'bottom']);\n\n// Utility functions\n\n/**\n * Creates a coordinate object with the same value for both x and y.\n * @param v - The value to use for both coordinates\n * @returns Coordinate object with x and y set to the same value\n */\nfunction createCoords(v: number): Coords {\n  return { x: v, y: v };\n};\n\n/**\n * Clamps a value between a minimum and maximum range.\n * @param start - The minimum value\n * @param value - The value to clamp\n * @param end - The maximum value\n * @returns The clamped value\n */\nfunction clamp(start: number, value: number, end: number): number {\n  return Math.max(start, Math.min(value, end));\n}\n\n/**\n * Extracts the side from a placement string.\n * @param placement - The placement string (e.g., 'top-start')\n * @returns The side portion (e.g., 'top')\n */\nfunction getSide(placement: Placement): Side {\n  return placement.split('-')[0] as Side;\n}\n\n/**\n * Extracts the alignment from a placement string.\n * @param placement - The placement string (e.g., 'top-start')\n * @returns The alignment portion (e.g., 'start') or undefined if no alignment\n */\nfunction getAlignment(placement: Placement): Alignment | undefined {\n  return placement.split('-')[1] as Alignment | undefined;\n}\n\n/**\n * Gets the opposite axis (x  y).\n * @param axis - The axis to flip\n * @returns The opposite axis\n */\nfunction getOppositeAxis(axis: Axis): Axis {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Gets the length property name for an axis.\n * @param axis - The axis ('x' or 'y')\n * @returns 'width' for x-axis, 'height' for y-axis\n */\nfunction getAxisLength(axis: Axis): Length {\n  return axis === 'y' ? 'height' : 'width';\n}\n\n/**\n * Gets the axis that runs along the side of a placement.\n * @param placement - The placement to get the side axis for\n * @returns 'y' for top/bottom sides, 'x' for left/right sides\n */\nfunction getSideAxis(placement: Placement): Axis {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\n\n/**\n * Gets the axis that runs along the alignment of a placement.\n * @param placement - The placement to get the alignment axis for\n * @returns The axis perpendicular to the side axis\n */\nfunction getAlignmentAxis(placement: Placement): Axis {\n  return getOppositeAxis(getSideAxis(placement));\n}\n\n/**\n * Flips the alignment portion of a placement (start  end).\n * @param placement - The placement string to flip alignment for\n * @returns The placement with opposite alignment\n */\nfunction getOppositeAlignmentPlacement<T extends string>(placement: T): T {\n  return placement.replace(/start|end/g, alignment =>\n    oppositeAlignmentMap[alignment as Exclude<Alignment, 'center'>]) as T;\n}\n\n/**\n * Gets the opposite placement by flipping the side.\n * @param placement - The placement to flip\n * @returns The placement with opposite side\n */\nfunction getOppositePlacement<T extends string>(placement: T): T {\n  return placement.replace(/left|right|bottom|top/g, side =>\n    oppositeSideMap[side as Side]) as T;\n}\n\n/**\n * Converts padding value to a complete side object.\n * @param padding - The padding value (number or partial side object)\n * @returns Complete side object with padding for all sides\n */\nfunction getPaddingObject(padding: Padding): SideObject {\n  return typeof padding !== 'number' ? {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding,\n  } : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding,\n  };\n}\n\n/**\n * Converts a basic rect to a client rect object with all sides.\n * @param rect - The basic rect with x, y, width, height\n * @returns Client rect object with top, left, right, bottom properties\n */\nfunction rectToClientRect(rect: Rect): ClientRectObject {\n  const { x, y, width, height } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n  };\n}\n\n// =============================================================================\n// DOM UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Gets the node name of a given node or window object.\n * @param {Node | Window} node - The node or window to get the name for\n * @returns {string} The lowercase node name, or '#document' for non-Node objects\n */\nfunction getNodeName(node: Node | Window): string {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\n\n/**\n * Gets the document element (html element) for a given node or window.\n * @param  node - The node or window to get the document element for\n * @returns  The document element (html element)\n */\nfunction getDocumentElement(node: Node | Window): HTMLElement {\n  return (\n    (isNode(node) ? node.ownerDocument : node.document) || window.document\n  )?.documentElement;\n}\n\n/**\n * Type guard to check if a value is a Node.\n * @param  value - The value to check\n * @returns  True if the value is a Node, false otherwise\n */\nfunction isNode(value: unknown): value is Node {\n  return !isServer && value instanceof Node;\n}\n\n/**\n * Type guard to check if a value is an Element.\n * @param  value - The value to check\n * @returns  True if the value is an Element, false otherwise\n */\nfunction isElement(value: unknown): value is Element {\n  return !isServer && value instanceof Element;\n}\n\n/**\n * Type guard to check if a value is an HTMLElement.\n * @param  value - The value to check\n * @returns  True if the value is an HTMLElement, false otherwise\n */\nfunction isHTMLElement(value: unknown): value is HTMLElement {\n  return !isServer && value instanceof HTMLElement;\n}\n\n/**\n * Type guard to check if a value is a ShadowRoot.\n * @param  value - The value to check\n * @returns  True if the value is a ShadowRoot, false otherwise\n */\nfunction isShadowRoot(value: unknown): value is ShadowRoot {\n  return !isServer && typeof ShadowRoot !== 'undefined' && value instanceof ShadowRoot;\n}\n\n/**\n * Checks if an element has overflow properties that create a scrolling context.\n * @param  element - The element to check\n * @returns  True if the element has overflow properties that create a scrolling context\n */\nfunction isOverflowElement(element: Element): boolean {\n  const { overflow, overflowX, overflowY, display } = window.getComputedStyle(element);\n  return (\n    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX)\n    && !invalidOverflowDisplayValues.has(display)\n  );\n}\n\n/**\n * Checks if an element is a table-related element (table, td, th).\n * @param  element - The element to check\n * @returns  True if the element is a table-related element\n */\nfunction isTableElement(element: Element): boolean {\n  return tableElements.has(getNodeName(element));\n}\n\n/**\n * Checks if an element is in the top layer (popover or modal).\n * @param  element - The element to check\n * @returns  True if the element is in the top layer\n */\nfunction isTopLayer(element: Element): boolean {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch {\n      return false;\n    }\n  });\n}\n\n/**\n * Checks if an element or CSS style declaration creates a containing block.\n * A containing block is the element relative to which positioned elements are positioned.\n * @param  elementOrCss - The element or CSS style declaration to check\n * @returns  True if the element creates a containing block\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n * @see https://drafts.csswg.org/css-transforms-2/#individual-transforms\n */\nfunction isContainingBlock(\n  elementOrCss: Element | CSSStyleDeclaration,\n): boolean {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ?\n    window.getComputedStyle(elementOrCss)\n    : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return (\n    transformProperties.some(value =>\n      css[value as keyof CSSStyleDeclaration] ?\n        css[value as keyof CSSStyleDeclaration] !== 'none'\n        : false,\n    )\n    || (css.containerType ? css.containerType !== 'normal' : false)\n    || (!webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false))\n    || (!webkit && (css.filter ? css.filter !== 'none' : false))\n    || willChangeValues.some(value => (css.willChange || '').includes(value))\n    || containValues.some(value => (css.contain || '').includes(value))\n  );\n}\n\n/**\n * Gets the nearest containing block element for a given element.\n * Traverses up the DOM tree to find the first element that creates a containing block.\n * @param {Element} element - The element to find the containing block for\n * @returns {HTMLElement | null} The containing block element, or null if none found\n */\nfunction getContainingBlock(element: Element): HTMLElement | null {\n  let currentNode: Node | null = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n\n    currentNode = getParentNode(currentNode);\n  }\n\n  return null;\n}\n\n/**\n * Checks if the current browser is WebKit-based.\n * @returns {boolean} True if the browser is WebKit-based, false otherwise\n */\nfunction isWebKit(): boolean {\n  if (typeof CSS === 'undefined' || !CSS.supports) {\n    return false;\n  }\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\n\n/**\n * Checks if a node is the last traversable node in the DOM tree.\n * @param {Node} node - The node to check\n * @returns {boolean} True if the node is the last traversable node (html, body, or #document)\n */\nfunction isLastTraversableNode(node: Node): boolean {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\n\n/**\n * Gets the scroll position of an element or window.\n * @param {Element | Window} element - The element or window to get scroll position for\n * @returns {{scrollLeft: number, scrollTop: number}} Object containing scrollLeft and scrollTop values\n */\nfunction getNodeScroll(element: Element | Window): {\n  scrollLeft: number;\n  scrollTop: number;\n} {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop,\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY,\n  };\n}\n\n/**\n * Gets the parent node of a given node, handling shadow DOM and slotted elements.\n * @param {Node} node - The node to get the parent for\n * @returns {Node} The parent node, handling shadow DOM boundaries and slotted elements\n */\nfunction getParentNode(node: Node): Node {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as Element).assignedSlot\n    // DOM Element detected.\n    || node.parentNode\n    // ShadowRoot detected.\n    || (isShadowRoot(node) && node.host)\n    // Fallback.\n    || getDocumentElement(node);\n\n  return isShadowRoot(result) ? result.host : result;\n}\n\n/**\n * Gets the nearest overflow ancestor element for a given node.\n * Traverses up the DOM tree to find the first element that has overflow properties.\n * @param {Node} node - The node to find the overflow ancestor for\n * @returns {HTMLElement} The nearest overflow ancestor element\n */\nfunction getNearestOverflowAncestor(node: Node): HTMLElement {\n  const parentNode = getParentNode(node);\n\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ?\n      node.ownerDocument.body\n      : (node as Document).body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\n/**\n * Gets all overflow ancestors for a given node, including windows and visual viewports.\n * @param  node - The node to get overflow ancestors for\n * @param  list - Accumulator list for overflow ancestors\n * @param  traverseIframes - Whether to traverse iframe boundaries\n * @returns  Array of overflow ancestors including elements, windows, and visual viewports\n */\nfunction getOverflowAncestors(\n  node: Node,\n  list: OverflowAncestors = [],\n  traverseIframes = true,\n): OverflowAncestors {\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === node.ownerDocument?.body;\n  const win = window;\n\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(\n      win,\n      win.visualViewport || [],\n      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],\n      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],\n    );\n  }\n\n  return list.concat(\n    scrollableAncestor,\n    getOverflowAncestors(scrollableAncestor, [], traverseIframes),\n  );\n}\n\n/**\n * Gets the frame element for a window if it's within an iframe.\n * @param {Window} win - The window to get the frame element for\n * @returns {Element | null} The frame element if the window is within an iframe, null otherwise\n */\nfunction getFrameElement(win: Window): Element | null {\n  return win.parent && Object.getPrototypeOf(win.parent) ?\n    win.frameElement\n    : null;\n}\n\n// =============================================================================\n// CORE MIDDLEWARES\n// =============================================================================\n\n// Helper function implementations\nfunction computeCoordsFromPlacement(\n  { reference, floating }: { reference: Rect; floating: Rect },\n  placement: Placement,\n  rtl?: boolean\n): Coords {\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords: Coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height,\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height,\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY,\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY,\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * @param reference - The reference element\n * @param floating - The floating element\n * @param config - Configuration options\n * @param cache - Cache for clipping ancestor calculations\n */\nfunction calculatePosition(\n  reference: Element,\n  floating: HTMLElement,\n  config: PositionConfig,\n  cache: Map<Element, Element[]>\n): ComputePositionReturn {\n  const {\n    placement: initialPlacement = 'bottom',\n    strategy = 'absolute',\n    offset = 0,\n    enableShift = true,\n    shiftPadding,\n    enableFlip = true,\n    flipPadding,\n    fallbackPlacements,\n    arrow,\n    arrowPadding = 0,\n  } = config;\n\n  const rtl = isRTL(floating);\n  const elements = { reference, floating };\n  let resetCount = 0;\n  let statefulPlacement = initialPlacement;\n  let arrowData: Partial<Coords> & { centerOffset: number } | undefined;\n  let x = 0;\n  let y = 0;\n\n  // Main positioning loop (handles flip resets)\n  while (resetCount < 50) {\n    const rects = getElementRects({ reference, floating, strategy });\n    const coords = computeCoordsFromPlacement(rects, statefulPlacement, rtl);\n    ({ x, y } = coords);\n\n    // 1. Apply offset\n    if (offset) {\n      const offsetCoords = convertValueToCoords(\n        { placement: statefulPlacement, elements, rects, x, y, strategy,\n          initialPlacement },\n        offset\n      );\n      x += offsetCoords.x;\n      y += offsetCoords.y;\n    }\n\n    // 2. Apply shift (keep in viewport)\n    if (enableShift) {\n      const overflow = detectOverflow(\n        { x, y, placement: statefulPlacement, strategy, rects, elements,\n          initialPlacement },\n        { padding: shiftPadding },\n        cache\n      );\n      const side = getSideAxis(getSide(statefulPlacement));\n      const mainAxis = getOppositeAxis(side);\n\n      const minSide = mainAxis === 'y' ? 'top' : 'left';\n      const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n      const minCoord = (mainAxis === 'y' ? y : x) + overflow[minSide];\n      const maxCoord = (mainAxis === 'y' ? y : x) - overflow[maxSide];\n\n      if (mainAxis === 'y') {\n        y = clamp(minCoord, y, maxCoord);\n      } else {\n        x = clamp(minCoord, x, maxCoord);\n      }\n    }\n\n    // 3. Calculate arrow position (if arrow element provided)\n    if (arrow) {\n      const axis = getAlignmentAxis(statefulPlacement);\n      const length = getAxisLength(axis);\n      const arrowDimensions = getDimensions(arrow);\n      const isYAxis = axis === 'y';\n      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n\n      const arrowOffsetParent = getOffsetParent(arrow);\n      let clientSize = arrowOffsetParent ? (arrowOffsetParent as Element)[clientProp] : 0;\n      if (!clientSize || !isElement(arrowOffsetParent)) {\n        clientSize = (floating as Element)[clientProp] || rects.floating[length];\n      }\n\n      const endDiff = rects.reference[length] + rects.reference[axis]\n        - (axis === 'y' ? y : x) - rects.floating[length];\n      const startDiff = (axis === 'y' ? y : x) - rects.reference[axis];\n      const centerToReference = endDiff / 2 - startDiff / 2;\n\n      const paddingObject = getPaddingObject(arrowPadding);\n      const minProp = isYAxis ? 'top' : 'left';\n      const maxProp = isYAxis ? 'bottom' : 'right';\n      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n      const minPadding = Math.min(paddingObject[minProp], largestPossiblePadding);\n      const maxPadding = Math.min(paddingObject[maxProp], largestPossiblePadding);\n\n      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n      const arrowOffset =\n        clamp(minPadding, center, clientSize - arrowDimensions[length] - maxPadding);\n\n      arrowData = {\n        [axis]: arrowOffset,\n        centerOffset: center - arrowOffset,\n      };\n    }\n\n    // 4. Check for flip\n    if (enableFlip) {\n      const overflow = detectOverflow(\n        { x, y, placement: statefulPlacement, strategy, rects, elements,\n          initialPlacement },\n        { padding: flipPadding },\n        cache\n      );\n\n      const side = getSide(statefulPlacement);\n      const isOverflowing = overflow[side] > 0;\n\n      if (isOverflowing) {\n        // Determine fallback placements\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const placements = fallbackPlacements || (\n          isBasePlacement ?\n            [getOppositePlacement(initialPlacement)]\n            : (() => {\n              const oppositePlacement = getOppositePlacement(initialPlacement);\n              return [\n                getOppositeAlignmentPlacement(initialPlacement),\n                oppositePlacement,\n                getOppositeAlignmentPlacement(oppositePlacement),\n              ];\n            })()\n        );\n        const allPlacements = [initialPlacement, ...placements];\n        const nextIndex = resetCount + 1;\n\n        if (nextIndex < allPlacements.length) {\n          statefulPlacement = allPlacements[nextIndex];\n          resetCount++;\n          continue; // Restart loop with new placement\n        }\n      }\n    }\n\n    // No reset needed, we're done\n    break;\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    arrow: arrowData,\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n * @param state - The position state\n * @param options - Detection options\n * @param cache - Cache for clipping ancestor calculations\n */\nfunction detectOverflow(\n  state: PositionState,\n  options: DetectOverflowOptions = {},\n  cache: Map<Element, Element[]>\n): SideObject {\n  const {\n    x,\n    y,\n    rects,\n    elements,\n    strategy,\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0,\n  } = options;\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(getClippingRect({\n    element: isElement(element) ?\n      element\n      : (getDocumentElement(elements.floating) || elements.floating),\n    boundary,\n    rootBoundary,\n    strategy,\n    cache,\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height,\n  } : rects.reference;\n  const offsetParent = getOffsetParent(elements.floating);\n  const offsetScale = (offsetParent && isElement(offsetParent)) ?\n    getScale(offsetParent) || { x: 1, y: 1 }\n    : { x: 1, y: 1 };\n  const elementClientRect = rectToClientRect(\n    offsetParent ?\n      convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements,\n        rect,\n        offsetParent,\n        strategy,\n      })\n      : rect,\n  );\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top)\n      / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom)\n      / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left)\n      / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right)\n      / offsetScale.x,\n  };\n}\n\nfunction convertValueToCoords(state: PositionState, options: OffsetValue): Coords {\n  const {\n    placement,\n    elements,\n  } = state;\n  const rtl = isRTL(elements.floating);\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n\n  const {\n    mainAxis,\n    crossAxis: initialCrossAxis,\n    alignmentAxis,\n  } = typeof options === 'number' ? {\n    mainAxis: options,\n    crossAxis: 0,\n    alignmentAxis: null,\n  } : {\n    mainAxis: options.mainAxis || 0,\n    crossAxis: options.crossAxis || 0,\n    alignmentAxis: options.alignmentAxis,\n  };\n  const crossAxis = alignment && typeof alignmentAxis === 'number' ?\n    alignment === 'end' ? alignmentAxis * -1 : alignmentAxis\n    : initialCrossAxis;\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti,\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti,\n  };\n}\n\n/**\n * Gets the CSS dimensions of an element, handling fallbacks for SVG elements.\n * @param element - The element to get dimensions for\n * @returns Object containing width, height, and fallback flag\n */\nfunction getCssDimensions(element: Element): CssDimensions {\n  const css = window.getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = Math.round(width) !== offsetWidth || Math.round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback,\n  };\n}\n\n/**\n * Gets the scale factor of an element based on its bounding rect vs CSS dimensions.\n * @param element - The element to get scale for\n * @returns Coordinates object with x and y scale factors\n */\nfunction getScale(element: Element): Coords {\n  if (!isHTMLElement(element)) {\n    return createCoords(1);\n  }\n  const rect = element.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $,\n  } = getCssDimensions(element);\n  let x = ($ ? Math.round(rect.width) : rect.width) / width;\n  let y = ($ ? Math.round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y,\n  };\n}\n\n/**\n * Gets the visual viewport offsets for an element in WebKit browsers.\n * @param element - The element to get visual offsets for\n * @returns Coordinates object with x and y offsets\n */\nfunction getVisualOffsets(): Coords {\n  const win = window;\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop,\n  };\n}\n\n/**\n * Determines if visual offsets should be added for positioning calculations.\n * @param element - The element to check\n * @param isFixed - Whether the element uses fixed positioning\n * @param floatingOffsetParent - The floating element's offset parent\n * @returns True if visual offsets should be added\n */\nfunction shouldAddVisualOffsets(\n  isFixed = false,\n  floatingOffsetParent?: Element | Window\n): boolean {\n  if (!floatingOffsetParent || (isFixed && floatingOffsetParent !== window)) {\n    return false;\n  }\n  return isFixed;\n}\n\n/**\n * Gets the bounding client rect of an element with optional scale and iframe handling.\n * @param element - The element to get bounding rect for\n * @param includeScale - Whether to include scale calculations\n * @param isFixedStrategy - Whether the element uses fixed positioning strategy\n * @param offsetParent - The offset parent for calculations\n * @returns Client rect object with position and dimensions\n */\nfunction getBoundingClientRect(\n  element: Element,\n  includeScale = false,\n  isFixedStrategy = false,\n  offsetParent?: Element | Window\n): ClientRectObject {\n  const clientRect = element.getBoundingClientRect();\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(isFixedStrategy, offsetParent) ?\n    getVisualOffsets()\n    : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (element) {\n    const win = window;\n    const offsetWin = offsetParent\n      && isElement(offsetParent) ? window : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = window.getComputedStyle(currentIFrame);\n      const left = iframeRect.left\n        + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top\n        + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = window;\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y,\n  });\n}\n\n/**\n * Gets the X position of the window scrollbar.\n * Note: If <html> has a CSS width greater than the viewport, this will be incorrect for RTL.\n * @param element - The element to get scrollbar position for\n * @param rect - Optional rect to use instead of calculating\n * @returns The X position of the scrollbar\n */\nfunction getWindowScrollBarX(element: Element, rect?: ClientRectObject): number {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)!).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\n/**\n * Gets the HTML offset for positioning calculations.\n * @param documentElement - The document element\n * @param scroll - The scroll position object\n * @param scroll.scrollTop\n * @param scroll.scrollLeft\n * @param ignoreScrollbarX - Whether to ignore X scrollbar in calculations\n * @returns Coordinates object with x and y offsets\n */\nfunction getHTMLOffset(\n  documentElement: Element,\n  scroll: { scrollLeft: number; scrollTop: number },\n  ignoreScrollbarX = false\n): Coords {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0\n  // RTL <body> scrollbar.\n  : getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y,\n  };\n}\n\n/**\n * Converts an offset parent relative rect to a viewport relative rect.\n * @param args - Object containing elements, rect, offsetParent, and strategy\n * @param args.strategy\n * @param args.offsetParent\n * @param args.rect\n * @param args.elements\n * @param args.elements.floating\n * @returns Viewport-relative rect\n */\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(args: {\n  elements?: { floating: Element };\n  rect: Rect;\n  offsetParent: Element | Window;\n  strategy: Strategy;\n}): Rect {\n  const { elements, rect, offsetParent, strategy } = args;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent)!;\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || (topLayer && isFixed)) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0,\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ?\n    getHTMLOffset(documentElement, scroll, true)\n    : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,\n  };\n}\n\n/**\n * Gets the entire size of the scrollable document area, even extending outside\n * of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n * @param element - The element to get document rect for\n * @returns Rect object with document dimensions and position\n */\nfunction getDocumentRect(element: Element): Rect {\n  const html = getDocumentElement(element)!;\n  const scroll = getNodeScroll(element);\n  const { body } = element.ownerDocument;\n  const width =\n    Math.max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height =\n    Math.max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (window.getComputedStyle(body).direction === 'rtl') {\n    x += Math.max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\n\n/**\n * Gets the viewport rect, accounting for visual viewport if available.\n * @param element - The element to get viewport rect for\n * @param strategy - The positioning strategy being used\n * @returns Rect object with viewport dimensions and position\n */\nfunction getViewportRect(element: Element, strategy: Strategy): Rect {\n  const win = window;\n  const html = getDocumentElement(element)!;\n  const { visualViewport } = win;\n  const width = visualViewport ? visualViewport.width : html.clientWidth;\n  const height = visualViewport ? visualViewport.height : html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || (visualViewportBased && strategy === 'fixed')) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\n\n/**\n * Returns the inner client rect, subtracting scrollbars if present.\n * @param element - The element to get inner rect for\n * @param strategy - The positioning strategy being used\n * @returns Rect object with inner dimensions and position\n */\nfunction getInnerBoundingClientRect(element: Element, strategy: Strategy): Rect {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + (element as HTMLElement).clientTop;\n  const left = clientRect.left + (element as HTMLElement).clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = (element as HTMLElement).clientWidth * scale.x;\n  const height = (element as HTMLElement).clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y,\n  };\n}\n\n/**\n * Gets the client rect from a clipping ancestor (viewport, document, or element).\n * @param element - The element being positioned\n * @param clippingAncestor - The clipping ancestor ('viewport', 'document', or element)\n * @param strategy - The positioning strategy being used\n * @returns Client rect object for the clipping boundary\n */\nfunction getClientRectFromClippingAncestor(\n  element: Element,\n  clippingAncestor: Element | RootBoundary | 'viewport' | 'document',\n  strategy: Strategy\n): ClientRectObject {\n  let rect: Rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element)!);\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets();\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height,\n    };\n  }\n  return rectToClientRect(rect);\n}\n\n/**\n * Checks if an element has a fixed position ancestor up to a stop node.\n * @param element - The element to check\n * @param stopNode - The node to stop checking at\n * @returns True if a fixed position ancestor is found\n */\nfunction hasFixedPositionAncestor(element: Element, stopNode: Element): boolean {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return window.getComputedStyle(parentNode).position === 'fixed'\n    || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n/**\n * A \"clipping ancestor\" is an `overflow` element with the characteristic of\n * clipping (or hiding) child elements. This returns all clipping ancestors\n * of the given element up the tree.\n * @param element - The element to find clipping ancestors for\n * @param cache - Cache map to store results\n * @returns Array of clipping ancestor elements\n */\nfunction getClippingElementAncestors(element: Element, cache: Map<Element, Element[]>): Element[] {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(\n    el => isElement(el) && getNodeName(el) !== 'body'\n  ) as Element[];\n  let currentContainingBlockComputedStyle: CSSStyleDeclaration | null = null;\n  const elementIsFixed = window.getComputedStyle(element).position === 'fixed';\n  let currentNode: Node | null = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = window.getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ?\n      !currentNodeIsContaining && !currentContainingBlockComputedStyle\n      : !currentNodeIsContaining && computedStyle.position === 'static'\n        && !!currentContainingBlockComputedStyle\n        && absoluteOrFixed.has(currentContainingBlockComputedStyle.position)\n        || isOverflowElement(currentNode)\n        && !currentNodeIsContaining\n        && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode as Element);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n/**\n * Gets the maximum area that the element is visible in due to any number of\n * clipping ancestors.\n * @param args - Object containing element, boundary, rootBoundary, strategy, and cache\n * @returns Rect object representing the clipping area\n */\nfunction getClippingRect(args: ClippingRectArgs): Rect {\n  const { element, boundary, rootBoundary, strategy, cache } = args;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ?\n    isTopLayer(element) ?\n      []\n      : getClippingElementAncestors(element, cache)\n    : [boundary].flat();\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const [firstClippingAncestor] = clippingAncestors;\n  const clippingRect = clippingAncestors.reduce((accRect: ClientRectObject, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top,\n  };\n}\n\n/**\n * Gets the dimensions of an element.\n * @param element - The element to get dimensions for\n * @returns Dimensions object with width and height\n */\nfunction getDimensions(element: Element): Dimensions {\n  const { width, height } = getCssDimensions(element);\n  return {\n    width,\n    height,\n  };\n}\n\n/**\n * Gets the rect of an element relative to its offset parent.\n * @param element - The element to get rect for\n * @param offsetParent - The offset parent element\n * @param strategy - The positioning strategy being used\n * @returns Rect object relative to the offset parent\n */\nfunction getRectRelativeToOffsetParent(\n  element: Element,\n  offsetParent: Element | Window,\n  strategy: Strategy\n): Rect {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent)!;\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0,\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset(): void {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ?\n    getHTMLOffset(documentElement, scroll)\n    : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/**\n * Checks if an element has static positioning.\n * @param element - The element to check\n * @returns True if the element is statically positioned\n */\nfunction isStaticPositioned(element: Element): boolean {\n  return window.getComputedStyle(element).position === 'static';\n}\n\n/**\n * Gets the true offset parent of an element, handling browser differences.\n * Firefox returns the <html> element as the offsetParent if it's non-static,\n * while Chrome and Safari return the <body> element. The <body> element must\n * be used to perform the correct calculations even if the <html> element is\n * non-static.\n * @param element - The element to get offset parent for\n * @param polyfill - Optional polyfill function for offset parent\n * @returns The true offset parent or null\n */\nfunction getTrueOffsetParent(element: Element, polyfill?: (element: Element) =>\n  Element | null): Element | null {\n  if (!isHTMLElement(element) || window.getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = (element as HTMLElement).offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n/**\n * Gets the closest ancestor positioned element. Handles some edge cases,\n * such as table ancestors and cross browser bugs.\n * @param element - The element to get offset parent for\n * @param polyfill - Optional polyfill function for offset parent\n * @returns The offset parent element or window\n */\nfunction getOffsetParent(element: Element, polyfill?: (element: Element) =>\n  Element | null): Element | Window {\n  const win = window;\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent)\n      && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\n/**\n * Gets the element rects for reference and floating elements.\n * @param data - Object containing reference, floating, and strategy\n * @param data.reference\n * @param data.floating\n * @param data.strategy\n * @returns Element rects\n */\nfunction getElementRects(data: {\n  reference: Element;\n  floating: Element;\n  strategy: Strategy;\n}): ElementRects {\n  const floatingDimensions = getDimensions(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(\n      data.reference,\n      getOffsetParent(data.floating),\n      data.strategy\n    ),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height,\n    },\n  };\n}\n\n/**\n * Checks if an element is in a right-to-left (RTL) context.\n * @param element - The element to check\n * @returns True if the element is in RTL context\n */\nfunction isRTL(element: Element): boolean {\n  return window.getComputedStyle(element).direction === 'rtl';\n}\n\n/**\n * Checks if two client rect objects are equal.\n * @param a - First rect object\n * @param b - Second rect object\n * @returns True if the rects are equal\n */\nfunction rectsAreEqual(a: ClientRectObject, b: ClientRectObject): boolean {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Observes an element for movement and calls a callback when it moves.\n * Based on https://samthor.au/2021/observing-dom/\n * @param element - The element to observe\n * @param onMove - Callback function called when element moves\n * @returns Cleanup function to stop observing\n */\nfunction observeMove(element: Element, onMove: () => void): () => void {\n  let io: IntersectionObserver | null = null;\n  let timeoutId: ReturnType<typeof setTimeout>;\n  const root = getDocumentElement(element)!;\n  function cleanup(): void {\n    clearTimeout(timeoutId);\n    io?.disconnect();\n    io = null;\n  }\n  function refresh(skip = false, threshold = 1): void {\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const { left, top, width, height } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = Math.floor(top);\n    const insetRight = Math.floor(root.clientWidth - (left + width));\n    const insetBottom = Math.floor(root.clientHeight - (top + height));\n    const insetLeft = Math.floor(left);\n    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;\n    const options = {\n      rootMargin,\n      threshold: Math.max(0, Math.min(1, threshold)) || 1,\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries: IntersectionObserverEntry[]): void {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1\n        && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument,\n      });\n    } catch {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @param referenceEl\n * @param floating\n * @param update\n * @param options\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(\n  referenceEl: Element,\n  floating: HTMLElement,\n  update: () => void,\n  options: AutoUpdateOptions = {}\n): () => void {\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false,\n  } = options;\n  const ancestors = ancestorScroll || ancestorResize ?\n    [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)]\n    : [];\n  ancestors.forEach(ancestor => {\n    if (ancestorScroll) {\n      ancestor.addEventListener('scroll', update, { passive: true });\n    }\n    if (ancestorResize) {\n      ancestor.addEventListener('resize', update);\n    }\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver: ResizeObserver | null = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(([firstEntry]) => {\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver?.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId: number;\n  let prevRefRect = animationFrame ? getBoundingClientRect(referenceEl) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop(): void {\n    const nextRefRect = getBoundingClientRect(referenceEl);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      if (ancestorScroll) {\n        ancestor.removeEventListener('scroll', update);\n      }\n      if (ancestorResize) {\n        ancestor.removeEventListener('resize', update);\n      }\n    });\n    cleanupIo?.();\n    resizeObserver?.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n"]}