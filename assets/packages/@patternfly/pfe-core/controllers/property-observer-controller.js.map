{"version":3,"file":"property-observer-controller.js","sourceRoot":"","sources":["property-observer-controller.ts"],"names":[],"mappings":";;AAEA,OAAO,EAAE,QAAQ,EAAE,MAAM,KAAK,CAAC;AAc/B,MAAM,aAAa,GAAG,MAAM,CAAC,eAAe,CAAC,CAAC;AAE9C,MAAM,OAAO,0BAA0B;IAKrC,YACU,IAAO,EACP,OAAmC;;QADnC,SAAI,GAAJ,IAAI,CAAG;QACP,YAAO,GAAP,OAAO,CAA4B;QAJrC,WAAM,GAAe,aAA2B,CAAC;QAQzD,+CAAY,IAAI,EAAC;IAFjB,CAAC;IAID,aAAa;QACX,uBAAA,IAAI,+EAAM,MAAV,IAAI,CAAQ,CAAC;IACf,CAAC;IAiBD,kFAAkF;IAClF,KAAK,CAAC,UAAU;QACd,uBAAA,IAAI,+EAAM,MAAV,IAAI,CAAQ,CAAC;QACb,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,EAAE,GAAG,IAAI,CAAC;QACtE,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CAAC,mBAAmB,YAAY,EAAE,CAAC,CAAC;QACrD,CAAC;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;YACtB,QAAQ,OAAO,EAAE,CAAC;gBAChB,KAAK,WAAW;oBACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;wBAC3B,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;wBAClD,MAAM,IAAI,OAAO,CAAO,OAAO,CAAC,EAAE;4BAChC,IAAI,CAAC,IAAI,CAAC,iBAAiB,GAAG;gCAC5B,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;4BACrC,CAAC,CAAC;wBACJ,CAAC,CAAC,CAAC;oBACL,CAAC;oBACD,MAAM;gBACR,KAAK,cAAc;oBACjB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;wBAC1B,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;oBACjC,CAAC;oBACD,MAAM;gBACR,KAAK,SAAS;oBACZ,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;oBAC/B,MAAM;YACV,CAAC;QACH,CAAC;QACD,MAAM,KAAK,GAAI,IAAI,CAAC,IAAI,CAAC,WAAsC,CAAC;QAChE,MAAM,UAAU,GAAG,KAAK;aACnB,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;aAC7C,UAAU,IAAI,QAAQ,CAAC;QAC5B,IAAI,uBAAA,IAAI,4CAAU,IAAI,UAAU,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;YACjD,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,MAAoB,EAAE,MAAM,CAAC,CAAC;YACvD,uBAAA,IAAI,wCAAa,KAAK,MAAA,CAAC;QACzB,CAAC;IACH,CAAC;CACF;;IA7CG,IAAI,IAAI,CAAC,MAAM,KAAK,aAAa,EAAE,CAAC;QAClC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;IACrD,CAAC;AACH,CAAC","sourcesContent":["import type { ReactiveController, ReactiveElement } from 'lit';\n\nimport { notEqual } from 'lit';\n\nexport type ChangeCallback<T extends ReactiveElement, V = T[keyof T]> = (\n  this: T,\n  old?: V,\n  newV?: V,\n) => void;\n\nexport interface PropertyObserverOptions<T extends ReactiveElement> {\n  propertyName: string & keyof T;\n  callback: ChangeCallback<T>;\n  waitFor?: 'connected' | 'updated' | 'firstUpdated';\n}\n\nconst UNINITIALIZED = Symbol('uninitialized');\n\nexport class PropertyObserverController<\n  T extends ReactiveElement\n> implements ReactiveController {\n  private oldVal: T[keyof T] = UNINITIALIZED as T[keyof T];\n\n  constructor(\n    private host: T,\n    private options: PropertyObserverOptions<T>\n  ) {\n  }\n\n  #neverRan = true;\n\n  hostConnected(): void {\n    this.#init();\n  }\n\n  /**\n   * Because of how typescript transpiles private fields,\n   * the __accessPrivate helper might not be entirely initialized\n   * by the time this constructor runs (in `addInitializer`'s instance callback')\n   * Therefore, we pull this shtick.\n   *\n   * When browser support improves to the point we can ship decorated private fields,\n   * we'll be able to get rid of this.\n   */\n  #init() {\n    if (this.oldVal === UNINITIALIZED) {\n      this.oldVal = this.host[this.options.propertyName];\n    }\n  }\n\n  /** Set any cached valued accumulated between constructor and connectedCallback */\n  async hostUpdate(): Promise<void> {\n    this.#init();\n    const { oldVal, options: { waitFor, propertyName, callback } } = this;\n    if (!callback) {\n      throw new Error(`no callback for ${propertyName}`);\n    }\n    const newVal = this.host[propertyName];\n    this.oldVal = newVal;\n    if (newVal !== oldVal) {\n      switch (waitFor) {\n        case 'connected':\n          if (!this.host.isConnected) {\n            const origConnected = this.host.connectedCallback;\n            await new Promise<void>(resolve => {\n              this.host.connectedCallback = function() {\n                resolve(origConnected?.call(this));\n              };\n            });\n          }\n          break;\n        case 'firstUpdated':\n          if (!this.host.hasUpdated) {\n            await this.host.updateComplete;\n          }\n          break;\n        case 'updated':\n          await this.host.updateComplete;\n          break;\n      }\n    }\n    const Class = (this.host.constructor as typeof ReactiveElement);\n    const hasChanged = Class\n        .getPropertyOptions(this.options.propertyName)\n        .hasChanged ?? notEqual;\n    if (this.#neverRan || hasChanged(oldVal, newVal)) {\n      callback.call(this.host, oldVal as T[keyof T], newVal);\n      this.#neverRan = false;\n    }\n  }\n}\n"]}