{"version":3,"file":"cascade-controller.js","sourceRoot":"","sources":["cascade-controller.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAC/C,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAC;AACpD,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAOrC,MAAM,OAAO,iBAAiB;IAW5B,YAAmB,IAAO,EAAS,OAAoB;QAApC,SAAI,GAAJ,IAAI,CAAG;QAAS,YAAO,GAAP,OAAO,CAAa;QAJvD,OAAE,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEtC,UAAK,GAAG,IAAI,GAAG,EAAoB,CAAC;QAGlC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAqC,CAAC;QACxD,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,EAAE,UAAU,IAAI,EAA8B,CAAC;QAC9E,KAAK,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YAC5D,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAClC;QACD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED,WAAW;QACT,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC3B,CAAC;IAED,aAAa;QACX,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QAClE,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC3B,CAAC;IAED,gBAAgB;QACd,IAAI,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,iBAAiB,CAAC,WAAoC,IAAI,CAAC,IAAI,CAAC,QAAQ;QACtE,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACzB,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;YAEpC,qGAAqG;YACrG,IAAI,CAAC,QAAQ,EAAE;gBACb,OAAO,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;aACvD;YAGD,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE;gBAC3B,kFAAkF;gBAClF,IAAI,IAAI,YAAY,OAAO,EAAE;oBAC3B,6EAA6E;oBAC7E,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;wBAChC,qEAAqE;wBACrE,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;4BAC1B,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;4BAC3C,6DAA6D;4BAC7D,oBAAoB;4BACpB,KAAK,MAAM,QAAQ,IAAI,SAAS,IAAI,EAAE,EAAE;gCACtC,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;6BACrC;yBACF;qBACF;iBACF;aACF;SACF;IACH,CAAC;IAED;;;;OAIG;IACH,QAAQ,CAAC,QAAgB,EAAE,OAAwB;QACjD,KAAK,MAAM,QAAQ,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,OAAO,CAAa,EAAE;YAC3E,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAE9D,MAAM,IAAI,GACN,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS;gBAC3C,CAAC,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAE3B,uEAAuE;YACvE,qCAAqC;YACrC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;gBAC7B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;aAClC;iBAAM;gBACL,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACtC;SACF;IACH,CAAC;IAEc,KAAK,CAAC,SAA2B;QAC9C,2DAA2D;QAC3D,KAAK,MAAM,QAAQ,IAAI,SAAS,IAAI,EAAE,EAAE;YACtC,8DAA8D;YAC9D,IAAI,QAAQ,CAAC,IAAI,KAAK,WAAW,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE;gBAC/D,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;aAC7C;iBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,YAAY,EAAE;gBACzC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;aACxD;SACF;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,cAAc,CAAC,IAAY,EAAE,EAAW;QACpD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,IAAI,OAAO,EAAE,EAAE,CAAC,CAAC;QAC5C,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,EAAE,CAAC,WAAW,EAAE;YAClB,IAAI,KAAK,IAAI,IAAI,EAAE;gBACjB,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;aAC1B;iBAAM;gBACL,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;aAC9B;SACF;IACH,CAAC;IAEO,kBAAkB,CAAC,SAAmC,EAAE,GAAkB;QAChF,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;YAChC,KAAK,MAAM,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE;gBAC1C,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;aACxC;SACF;IACH,CAAC;IAED;;;;;;OAMG;IACK,iBAAiB,CAAC,IAAY,EAAE,EAAU;QAChD,MAAM,UAAU,GAAG;YACjB,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC;YACjC,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,gBAAgB,CAAC,EAAE,CAAC,IAAI,EAAE;SACpD,CAAC;QAEF,KAAK,MAAM,IAAI,IAAI,UAAU,EAAE;YAC7B,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACjC;IACH,CAAC;;AA3IM,2BAAS,GAAiE,IAAI,OAAO,EAAE,CAAC;AAwFxF;IAAN,KAAK;8CAUL","sourcesContent":["import type { ReactiveController, ReactiveElement } from 'lit';\n\nimport { bound } from '../decorators/bound.js';\nimport { debounce } from '../functions/debounce.js';\nimport { Logger } from './logger.js';\n\nexport interface Options<E extends ReactiveElement> {\n  properties: Partial<Record<keyof E, string|string[]>>;\n  prefix?: string;\n}\n\nexport class CascadeController<E extends ReactiveElement> implements ReactiveController {\n  private class: typeof ReactiveElement;\n\n  private logger: Logger;\n\n  static instances: WeakMap<ReactiveElement, CascadeController<ReactiveElement>> = new WeakMap();\n\n  mo = new MutationObserver(this.parse);\n\n  cache = new Map<string, string[]>();\n\n  constructor(public host: E, public options?: Options<E>) {\n    this.class = host.constructor as typeof ReactiveElement;\n    this.logger = new Logger(this.host);\n    CascadeController.instances.set(host, this);\n    const properties = this.options?.properties ?? {} as Options<E>['properties'];\n    for (const [propName, cascade] of Object.entries(properties)) {\n      this.initProp(propName, cascade);\n    }\n    host.addController(this);\n    this.cascadeProperties = debounce(this.cascadeProperties, 1);\n  }\n\n  hostUpdated() {\n    this.cascadeProperties();\n  }\n\n  hostConnected() {\n    this.mo.observe(this.host, { attributes: true, childList: true });\n    this.cascadeProperties();\n  }\n\n  hostDisconnected() {\n    this.mo.disconnect();\n  }\n\n  /**\n   * Handles the cascading of properties to nested components when new elements are added\n   * Attribute updates/additions are handled by the attribute callback\n   */\n  cascadeProperties(nodeList: HTMLCollection|NodeList = this.host.children) {\n    if (this.host.isConnected) {\n      const selectors = this.cache.keys();\n\n      // Find out if anything in the nodeList matches any of the observed selectors for cacading properties\n      if (!nodeList) {\n        return this._cascadeAttributes(selectors, this.cache);\n      }\n\n\n      for (const node of nodeList) {\n        // if this node has a match function (i.e., it's an HTMLElement, not a text node),\n        if (node instanceof Element) {\n          // see if it matches one of the selectors, otherwise drop it (like it's hot).\n          for (const selector of selectors) {\n            // console.log('_copyAttribute', name, value, el.getAttribute(name));\n            if (node.matches(selector)) {\n              const attrNames = this.cache.get(selector);\n              // each selector can match multiple properties/attributes, so\n              // copy each of them\n              for (const attrName of attrNames ?? []) {\n                this._copyAttribute(attrName, node);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the configured attribute name for the decorated property,\n   * falling back to the lowercased property name, and caches the attribute name\n   * with it's designated child selectors for value-propagation on change\n   */\n  initProp(propName: string, cascade: string|string[]) {\n    for (const nodeItem of [cascade].flat(Infinity).filter(Boolean) as string[]) {\n      const { attribute } = this.class.getPropertyOptions(propName);\n\n      const attr =\n          typeof attribute === 'string' ? attribute\n        : propName.toLowerCase();\n\n      // Create an object with the node as the key and an array of attributes\n      // that are to be cascaded down to it\n      if (!this.cache.get(nodeItem)) {\n        this.cache.set(nodeItem, [attr]);\n      } else {\n        this.cache.get(nodeItem)?.push(attr);\n      }\n    }\n  }\n\n  @bound private parse(mutations: MutationRecord[]) {\n    // Iterate over the mutation list, look for cascade updates\n    for (const mutation of mutations ?? []) {\n      // If a new node is added, attempt to cascade attributes to it\n      if (mutation.type === 'childList' && mutation.addedNodes.length) {\n        this.cascadeProperties(mutation.addedNodes);\n      } else if (mutation.type === 'attributes') {\n        this._cascadeAttributes(this.cache.keys(), this.cache);\n      }\n    }\n  }\n\n  /**\n   * Copy the named attribute to a target element.\n   */\n  private async _copyAttribute(name: string, el: Element) {\n    this.logger.log(`copying ${name} to ${el}`);\n    const value = this.host.getAttribute(name);\n    if (el.isConnected) {\n      if (value == null) {\n        el.removeAttribute(name);\n      } else {\n        el.setAttribute(name, value);\n      }\n    }\n  }\n\n  private _cascadeAttributes(selectors: IterableIterator<string>, set: this['cache']) {\n    for (const selector of selectors) {\n      for (const attr of set.get(selector) ?? []) {\n        this._cascadeAttribute(attr, selector);\n      }\n    }\n  }\n\n  /**\n   * Trigger a cascade of the named attribute to any child elements that match\n   * the `to` selector.  The selector can match elements in the light DOM and\n   * shadow DOM.\n   * @param  name The name of the attribute to cascade (not necessarily the same as the property name).\n   * @param  to A CSS selector that matches the elements that should received the cascaded attribute.  The selector will be applied within `this` element's light and shadow DOM trees.\n   */\n  private _cascadeAttribute(name: string, to: string) {\n    const recipients = [\n      ...this.host.querySelectorAll(to),\n      ...this.host.shadowRoot?.querySelectorAll(to) ?? [],\n    ];\n\n    for (const node of recipients) {\n      this._copyAttribute(name, node);\n    }\n  }\n}\n"]}