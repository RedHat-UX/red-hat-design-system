{"version":3,"file":"observed.js","sourceRoot":"","sources":["observed.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,0BAA0B,EAAE,MAAM,gDAAgD,CAAC;AAgC5F,+CAA+C;AAC/C,MAAM,UAAU,QAAQ,CAA4B,GAAG,EAAS;IAC9D,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACpB,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;QAC5B,OAAO,mBAAmB,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;SAAM,CAAC;QACN,OAAO,oBAAoB,CAAC,GAAG,EAA2B,CAAC,CAAC;IAC9D,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,SAAS,oBAAoB,CAA4B,KAAQ,EAAE,YAA8B;IAC/F,MAAM,KAAK,GAAG,KAAK,CAAC,WAAqC,CAAC;IAC1D,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAClC,CAAM,EACN,YAAY,EACZ,CAAC,CAAC,IAAI,YAAY,SAA2B,CAAsB,CACpE,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,SAAS,mBAAmB,CAC1B,cAA0C;IAE1C,OAAO,UAAS,KAAK,EAAE,GAAG;QACxB,MAAM,YAAY,GAAG,GAAuB,CAAC;QAC7C,MAAM,KAAK,GAAG,KAAK,CAAC,WAAqC,CAAC;QAC1D,IAAI,OAAO,cAAc,KAAK,UAAU,EAAE,CAAC;YACzC,MAAM,QAAQ,GAAG,cAAc,CAAC;YAChC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAM,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC;QACxE,CAAC;aAAM,CAAC;YACN,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAClC,CAAM,EACN,YAAY,EACZ,CAAC,CAAC,cAAuC,CAAsB,CAChE,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,UAAU,CACjB,QAAW,EACX,YAA8B,EAC9B,QAA2B;IAE3B,MAAM,UAAU,GAAG,IAAI,0BAA0B,CAAI,QAAa,EAAE,EAAE,YAAY,EAAE,QAAQ,EAAE,CAAC,CAAC;IAChG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACrC,CAAC","sourcesContent":["import type { ReactiveElement } from 'lit';\nimport type { ChangeCallback } from '../controllers/property-observer-controller.js';\n\nimport { PropertyObserverController } from '../controllers/property-observer-controller.js';\n\ntype TypedFieldDecorator<T> = (proto: T, key: string | keyof T) => void ;\n\n// eslint-disable-next-line jsdoc/require-param\n/**\n * Calls a _fooChanged method on the instance when the value changes.\n * Works on any class field. When using on lit observed properties,\n * Make sure `@observed` is to the left (i.e. called after) the `@property`\n * or `@state` decorator.\n * @example observing a lit property\n *          ```ts\n *          @observed @property() foo = 'bar';\n *\n *          protected _fooChanged(oldValue?: string, newValue?: string) {}\n *          ```\n * @example using a custom callback\n *          ```ts\n *          @observed('_myCallback') size = 'lg';\n *\n *          _myCallback(_, size) {...}\n *          ```\n * @example using an arrow function\n *          ```ts\n *          @observed((oldVal, newVal) => console.log(`Size changed from ${oldVal} to ${newVal}`))\n *          ```\n */\nexport function observed<T extends ReactiveElement, V>(\n  cb: ChangeCallback<T, V>,\n): TypedFieldDecorator<T>;\nexport function observed<T extends ReactiveElement>(methodName: string): TypedFieldDecorator<T>;\nexport function observed<T extends ReactiveElement>(proto: T, key: string): void;\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function observed<T extends ReactiveElement>(...as: any[]): void | TypedFieldDecorator<T> {\n  if (as.length === 1) {\n    const [methodNameOrCb] = as;\n    return configuredDecorator(methodNameOrCb);\n  } else {\n    return executeBareDecorator(...as as [T, string & keyof T]);\n  }\n}\n\n/**\n * @param proto element prototype\n * @param propertyName propertyName\n * @example ```typescript\n *          @observed @property() foo?: string;\n *          ```\n */\nfunction executeBareDecorator<T extends ReactiveElement>(proto: T, propertyName: string & keyof T) {\n  const klass = proto.constructor as typeof ReactiveElement;\n  klass.addInitializer(x => initialize(\n    x as T,\n    propertyName,\n    x[`_${propertyName}Changed` as keyof typeof x] as ChangeCallback<T>,\n  ));\n}\n\n/**\n * @param methodNameOrCb string name of callback or function\n * @example ```typescript\n *          @observed('_myCallback') @property() foo?: string;\n *          @observed((old) => console.log(old)) @property() bar?: string;\n *          ```\n */\nfunction configuredDecorator<T extends ReactiveElement>(\n  methodNameOrCb: string | ChangeCallback<T>,\n): TypedFieldDecorator<T> {\n  return function(proto, key) {\n    const propertyName = key as string & keyof T;\n    const klass = proto.constructor as typeof ReactiveElement;\n    if (typeof methodNameOrCb === 'function') {\n      const callback = methodNameOrCb;\n      klass.addInitializer(x => initialize(x as T, propertyName, callback));\n    } else {\n      klass.addInitializer(x => initialize(\n        x as T,\n        propertyName,\n        x[methodNameOrCb as keyof ReactiveElement] as ChangeCallback<T>,\n      ));\n    }\n  };\n}\n\nfunction initialize<T extends ReactiveElement>(\n  instance: T,\n  propertyName: string & keyof T,\n  callback: ChangeCallback<T>,\n) {\n  const controller = new PropertyObserverController<T>(instance as T, { propertyName, callback });\n  instance.addController(controller);\n}\n"]}