{"version":3,"file":"controller.js","sourceRoot":"","sources":["controller.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,eAAe,EAAE,MAAM,KAAK,CAAC;AAEtC,OAAO,EAAE,eAAe,EAAE,MAAM,sDAAsD,CAAC;AAEvF,OAAO,EAAE,aAAa,EAAiD,MAAM,aAAa,CAAC;AAS3F;;;;;;;;;;;;;;;EAeE;AACF,MAAM,CAAC,MAAM,aAAa,GAAG,IAAI,GAAG,EAGjC,CAAC;AAEJ,MAAM,CAAC,MAAM,mBAAmB,GAC9B,CAAC,KAA0C,EAA8C,EAAE,CACzF,KAAK,CAAC,OAAO,KAAK,sBAAsB,CAAC,OAAO,CAAC;AAErD;;;;;;;;GAQG;AACH,MAAM,OAAgB,sBAAsB;IAc1C,YAAsB,IAAO,EAAE,MAAiC;QAA1C,SAAI,GAAJ,IAAI,CAAG;QAR7B,+CAA+C;QACrC,SAAI,GAAsB,IAAI,CAAC;QAQvC,IAAI,eAAe,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAClC,IAAI,IAAI,CAAC,IAAI,YAAY,eAAe,EAAE,CAAC;YACzC,MAAM,KAAK,GAAI,IAAI,CAAC,IAAI,CAAC,WAAsC,CAAC;YAChE,KAAK,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QACzE,CAAC;QACD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;;AAlBD,2EAA2E;AACpD,8BAAO,GAAG,aAAa,CAAoB,MAAM,CAAC,kBAAkB,CAAC,CAAC,AAA/D,CAAgE","sourcesContent":["import type { ColorTheme } from './consumer.js';\nimport type { CSSResult, ReactiveController } from 'lit';\n\nimport { ReactiveElement } from 'lit';\n\nimport { StyleController } from '@patternfly/pfe-core/controllers/style-controller.js';\n\nimport { createContext, type ContextRequestEvent, type UnknownContext } from '../event.js';\n\nexport interface ColorContextOptions<T extends ReactiveElement> {\n  prefix?: string;\n  propertyName?: keyof T;\n}\n\ntype ColorContext = typeof ColorContextController.context;\n\n/**\n* Maps from consumer host elements to already-fired request events\n* We hold these in memory in order to re-fire the events every time a new provider connects.\n* This is a hedge against cases where an early-upgrading provider claims an early-upgrading\n* consumer before a late-upgrading provider has a chance to register as the rightful provider\n* @example Monkey-in-the-middle error\n*          In this example, we must re-fire the event from eager-consumer when late-provider\n*          upgrades, so as to ensure that late-provider claims it for itself\n*          ```html\n*          <early-provider>\n*            <late-provider>\n*              <eager-consumer></eager-consumer>\n*            </late-provider>\n*          </early-provider>\n*          ```\n*/\nexport const contextEvents = new Map<\n  ReactiveElement,\n  ContextRequestEvent<ColorContext>\n>();\n\nexport const isColorContextEvent =\n  (event: ContextRequestEvent<UnknownContext>): event is ContextRequestEvent<ColorContext> =>\n    event.context === ColorContextController.context;\n\n/**\n * Color context is derived from the `--context` css custom property,\n * which *must* be set by the `color-palette` attribute\n * This property is set (in most cases) in `color-context.scss`,\n * which is added to components via `StyleController`.\n *\n * In this way, we avoid the need to execute javascript in order to convert from a given\n * `ColorPalette` to a given `ColorTheme`, since those relationships are specified in CSS.\n */\nexport abstract class ColorContextController<\n  T extends ReactiveElement\n> implements ReactiveController {\n  /** The context object which acts as the key for providers and consumers */\n  public static readonly context = createContext<ColorTheme | null>(Symbol('rh-color-context'));\n\n  /** The last-known color context on the host */\n  protected last: ColorTheme | null = null;\n\n  hostUpdate?(): void;\n\n  /** callback which updates the context value on consumers */\n  abstract update(next?: ColorTheme | null): void;\n\n  constructor(protected host: T, styles: CSSStyleSheet | CSSResult) {\n    new StyleController(host, styles);\n    if (this.host instanceof ReactiveElement) {\n      const Class = (this.host.constructor as typeof ReactiveElement);\n      Class.styles = [Class.styles].flat().filter(x => !!x).concat([styles]);\n    }\n    host.addController(this);\n  }\n}\n"]}