{"version":3,"file":"provider.js","sourceRoot":"","sources":["provider.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveController, type ReactiveElement } from 'lit';\nimport type { ContextCallback, ContextRequestEvent, UnknownContext } from '../event.js';\n\nimport {\n  contextEvents,\n  ColorContextController,\n  type ColorContextOptions,\n} from './controller.js';\n\nimport { ColorContextConsumer, type ColorTheme } from './consumer.js';\n\nimport { Logger } from '@patternfly/pfe-core/controllers/logger.js';\n\nimport styles from '@rhds/tokens/css/color-context-provider.css.js';\n\n/**\n * A `ColorPalette` is a collection of specific color values\n * Choosing a palette sets both color properties and, if the component is a context provider,\n * implies a color theme for descendents.\n *\n * `ColorPalette` is associated with the `color-palette` attribute\n */\nexport type ColorPalette = (\n  | 'base'\n  | 'accent'\n  | 'complement'\n  | 'light'\n  | 'lighter'\n  | 'lightest'\n  | 'dark'\n  | 'darker'\n  | 'darkest'\n);\n\nexport interface ColorContextProviderOptions<T extends ReactiveElement>\n  extends ColorContextOptions<T> {\n  /** Attribute to set context. Providers only */\n  attribute?: string;\n}\n\n/**\n * `ColorContextProvider` is responsible to derive a context value from CSS and provide it to its\n * descendents.\n */\nexport class ColorContextProvider<\n  T extends ReactiveElement\n> extends ColorContextController<T> implements ReactiveController {\n  static contexts = new Map(Object.entries({\n    darkest: 'dark' as const,\n    darker: 'dark' as const,\n    dark: 'dark' as const,\n    light: 'light' as const,\n    lighter: 'light' as const,\n    lightest: 'light' as const,\n  }));\n\n  #attribute: string;\n\n  /** Cache of context callbacks. Call each to update consumers */\n  #callbacks = new Set<ContextCallback<ColorTheme | null>>();\n\n  /** Mutation observer which updates consumers when `color-palette` attribute change. */\n  #mo = new MutationObserver(() => this.update());\n\n  /**\n   * Cached (live) computed style declaration\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\n   */\n  // eslint-disable-next-line no-unused-private-class-members\n  #style: CSSStyleDeclaration;\n\n  #initialized = false;\n\n  #logger: Logger;\n\n  #consumer: ColorContextConsumer<T>;\n\n  get local() {\n    return this.#local;\n  }\n\n  get #local() {\n    return ColorContextProvider\n        .contexts.get(this.host.getAttribute(this.#attribute) ?? '');\n  }\n\n  get value(): ColorTheme {\n    return this.#local ?? this.#consumer.value;\n  }\n\n  constructor(host: T, options?: ColorContextProviderOptions<T>) {\n    const { attribute = 'color-palette' } = options ?? {};\n    super(host, styles);\n    this.#consumer = new ColorContextConsumer(host, {\n      callback: value => this.update(value),\n    });\n    this.#logger = new Logger(host);\n    this.#style = window.getComputedStyle(host);\n    this.#attribute = attribute;\n    if (this.#attribute !== 'color-palette') {\n      this.#logger.warn('color context currently supports the `color-palette` attribute only.');\n    }\n  }\n\n  /**\n     * When a context provider connects, it listens for context-request events\n     * it also fires all previously fired context-request events from their hosts,\n     * in case this context provider upgraded after and is closer to a given consumer.\n     */\n  async hostConnected() {\n    this.host.addEventListener('context-request', e => this.#onChildContextRequestEvent(e));\n    this.#mo.observe(this.host, { attributes: true, attributeFilter: [this.#attribute] });\n    for (const [host, fired] of contextEvents) {\n      host.dispatchEvent(fired);\n    }\n    await this.host.updateComplete;\n    this.update();\n    return true;\n  }\n\n  async hostUpdated() {\n    if (!this.#initialized) {\n      this.hostConnected();\n    }\n    this.#initialized ||= await this.hostConnected();\n    if (this.#local && this.value !== this.#consumer.value) {\n      this.#consumer.update(this.#local);\n      this.update();\n    }\n    if (!isServer) {\n      // This is definitely overkill, but it's the only\n      // way we've found so far to work around lit-ssr hydration woes\n      this.update();\n    }\n  }\n\n  /**\n   * When a context provider disconnects, it disconnects its mutation observer\n   */\n  hostDisconnected() {\n    this.#callbacks.forEach(x => this.#callbacks.delete(x));\n    this.#mo.disconnect();\n  }\n\n  /**\n   * Was the context event fired requesting our colour-context context?\n   * @param event some event\n   */\n  #isColorContextEvent(\n    event: ContextRequestEvent<UnknownContext>\n  ): event is ContextRequestEvent<typeof ColorContextController.context> {\n    return event.composedPath().at(0) !== this.host\n      && event.context === ColorContextController.context;\n  }\n\n  /**\n   * Provider part of context API\n   * When a child connects, claim its context-request event\n   * and add its callback to the Set of children if it requests multiple updates\n   * @param event context-request event\n   */\n  async #onChildContextRequestEvent(event: ContextRequestEvent<UnknownContext>) {\n    // only handle ContextEvents relevant to colour context\n    if (this.#isColorContextEvent(event)) {\n      event.stopPropagation();\n\n      // Run the callback to initialize the child's colour-context\n      event.callback(this.value);\n\n      // Cache the callback for future updates, if requested\n      if (event.subscribe) {\n        this.#callbacks.add(event.callback);\n      }\n    }\n  }\n\n  /**\n   * Calls the context callback for all consumers\n   * @param [force] override theme\n   */\n  public override async update(force?: ColorTheme) {\n    for (const cb of this.#callbacks) {\n      cb(force ?? this.value);\n    }\n  }\n}\n\n/**\n * Makes this element a color context provider which updates its consumers when the decorated field changes\n * @param options options\n */\nexport function colorContextProvider<T extends ReactiveElement>(options?: ColorContextOptions<T>) {\n  return function(proto: T, _propertyName: string) {\n    const propertyName = _propertyName as keyof T;\n    const klass = (proto.constructor as typeof ReactiveElement);\n    const propOpts = klass.getPropertyOptions(_propertyName);\n    const attribute = typeof propOpts.attribute === 'boolean' ? undefined : propOpts.attribute;\n    klass.addInitializer(instance => {\n      const controller = new ColorContextProvider(instance as T, {\n        propertyName,\n        attribute,\n        ...options,\n      });\n      // @ts-expect-error: this assignment is strictly for debugging purposes\n      instance.__DEBUG_colorContextProvider = controller;\n    });\n  };\n}\n"]}