{"version":3,"file":"consumer.js","sourceRoot":"","sources":["consumer.ts"],"names":[],"mappings":";;AAAA,OAAO,EAAE,mBAAmB,EAAE,MAAM,aAAa,CAAC;AAElD,OAAO,EAAE,aAAa,EAAE,sBAAsB,EAAE,MAAM,iBAAiB,CAAC;AAQxE;;;GAGG;AACH,MAAM,OAAO,2BAA4B,SAAQ,sBAAsB;IAAvE;;;QACE,uDAAsB;IAoCxB,CAAC;IAlCC,+EAA+E;IAC/E,aAAa;QACX,MAAM,EAAE,OAAO,EAAE,GAAG,sBAAsB,CAAC;QAC3C,MAAM,KAAK,GAAG,IAAI,mBAAmB,CACnC,OAAO,EACP,CAAC,CAAC,EAAE,CAAC,uBAAA,IAAI,4FAAiB,MAArB,IAAI,EAAkB,CAAC,CAAC,EAC7B,IAAI,CACL,CAAC;QACF,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC/B,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACtC,CAAC;IAED,4EAA4E;IAC5E,gBAAgB;QACd,uBAAA,IAAI,4CAAS,EAAE,KAAf,IAAI,CAAa,CAAC;QAClB,uBAAA,IAAI,wCAAY,SAAS,MAAA,CAAC;QAC1B,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAYD,0FAA0F;IACnF,MAAM,CAAC,IAAY;QACxB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;IAC5B,CAAC;CACF;mNAdkB,KAAa,EAAE,OAAoB;IAClD,qCAAqC;IACrC,IAAI,OAAO,IAAI,OAAO,KAAK,uBAAA,IAAI,4CAAS,EAAE,CAAC;QACzC,uBAAA,IAAI,4CAAS,EAAE,KAAf,IAAI,CAAa,CAAC;QAClB,uBAAA,IAAI,wCAAY,OAAO,MAAA,CAAC;IAC1B,CAAC;IACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB,CAAC","sourcesContent":["import { ContextRequestEvent } from '../event.js';\n\nimport { contextEvents, HeadingLevelController } from './controller.js';\n\nexport interface HeadingTemplateOptions {\n  id?: string;\n  hidden?: boolean;\n  level?: number;\n}\n\n/**\n * Determines which heading level immediately precedes the host element,\n * and provides templates for shadow headings.\n */\nexport class HeadingLevelContextConsumer extends HeadingLevelController {\n  #dispose?: () => void;\n\n  /** When a consumer connects, it requests context from the closest provider. */\n  hostConnected() {\n    const { context } = HeadingLevelController;\n    const event = new ContextRequestEvent<typeof context>(\n      context,\n      e => this.#contextCallback(e),\n      true,\n    );\n    this.host.dispatchEvent(event);\n    contextEvents.set(this.host, event);\n  }\n\n  /** When a consumer disconnects, it's removed from the list of consumers. */\n  hostDisconnected() {\n    this.#dispose?.();\n    this.#dispose = undefined;\n    contextEvents.delete(this.host);\n  }\n\n  /** Register the dispose callback for hosts that requested multiple updates, then update the colour-context */\n  #contextCallback(value: number, dispose?: () => void) {\n    // protect against changing providers\n    if (dispose && dispose !== this.#dispose) {\n      this.#dispose?.();\n      this.#dispose = dispose;\n    }\n    this.update(value);\n  }\n\n  /** Sets the heading level on the host and any children that requested multiple updates */\n  public update(next: number) {\n    this.level = next;\n    this.host.requestUpdate();\n  }\n}\n"]}