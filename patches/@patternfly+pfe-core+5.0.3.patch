diff --git a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
index ba9af2b..a2ede6d 100644
--- a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
@@ -19,8 +19,14 @@ export class ATFocusController {
     }
     set atFocusedItemIndex(index) {
         const previousIndex = __classPrivateFieldGet(this, _ATFocusController_atFocusedItemIndex, "f");
-        const direction = index > previousIndex ? 1 : -1;
         const { items, atFocusableItems } = this;
+        // Fix direction calculation for Home/End keys:
+        // - Home (index=0): always search forward to find first focusable item
+        // - End (index=last): always search backward to find last focusable item
+        // - Other cases: use comparison to determine direction
+        const direction = index === 0 ? 1
+            : index >= items.length - 1 ? -1
+            : index > previousIndex ? 1 : -1;
         const itemsIndexOfLastATFocusableItem = items.indexOf(this.atFocusableItems.at(-1));
         let itemToGainFocus = items.at(index);
         let itemToGainFocusIsFocusable = atFocusableItems.includes(itemToGainFocus);
diff --git a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
index 86cfd13..9b870d3 100644
--- a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
@@ -86,9 +86,12 @@ export class ComboboxController {
     set items(value) {
         __classPrivateFieldGet(this, _ComboboxController_lb, "f").items = value;
+        // When items change dynamically (e.g. slotchange), refresh the focus controller
+        // so keyboard nav and aria-activedescendant use the new list.
+        __classPrivateFieldGet(this, _ComboboxController_fc, "f")?.initItems?.();
     }
     /** Whether the combobox is disabled */
@@ -309,8 +312,11 @@ export class ComboboxController {
         _ComboboxController_onFocusoutListbox.set(this, (event) => {
             if (!__classPrivateFieldGet(this, _ComboboxController_instances, "a", _ComboboxController_hasTextInput_get) && this.options.isExpanded()) {
                 const root = __classPrivateFieldGet(this, _ComboboxController_instances, "a", _ComboboxController_element_get)?.getRootNode();
+                // Also check if focus moved to the toggle button - if so, let the click handler manage toggle
+                const isToggleButton = event.relatedTarget === __classPrivateFieldGet(this, _ComboboxController_button, "f");
                 if ((root instanceof ShadowRoot || root instanceof Document)
-                    && !this.items.includes(event.relatedTarget)) {
+                    && !this.items.includes(event.relatedTarget)
+                    && !isToggleButton) {
                     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_hide).call(this);
                 }
             }
diff --git a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
index f0bd33c..8d6c824 100644
--- a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
@@ -59,6 +59,21 @@ export class RovingTabindexController extends ATFocusController {
         if (!isServer) {
             if (container instanceof HTMLElement) {
                 container.addEventListener('focusin', () => __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, true, "f"), { once: true });
+                // Sync atFocusedItemIndex when an item receives DOM focus (e.g., via mouse click)
+                // This ensures keyboard navigation starts from the correct position
+                container.addEventListener('focusin', (event) => {
+                    const target = event.target;
+                    const index = this.items.indexOf(target);
+                    // Only update if the target is a valid item and index differs
+                    if (index >= 0 && index !== this.atFocusedItemIndex) {
+                        // Update parent's index directly via setter, but we need to avoid
+                        // the focus() call. We do this by temporarily clearing gainedInitialFocus.
+                        const hadInitialFocus = __classPrivateFieldGet(this, _RovingTabindexController_gainedInitialFocus, "f");
+                        __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, false, "f");
+                        this.atFocusedItemIndex = index;
+                        __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, hadInitialFocus, "f");
+                    }
+                });
             }
             else {
                 __classPrivateFieldGet(this, _RovingTabindexController_logger, "f").warn('RovingTabindexController requires a getItemsContainer function');
