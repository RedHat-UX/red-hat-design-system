diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
index addc933..682be5f 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
@@ -25,9 +25,43 @@ export interface ScrollSpyControllerOptions extends IntersectionObserverInit {
      */
     onIntersection?(): void;
 }
+/**
+ * A reactive controller that implements the scroll-spy pattern for table of contents navigation.
+ *
+ * ## Logic Overview
+ *
+ * This controller tracks heading elements and activates the corresponding ToC link based on
+ * which headings are currently visible in the viewport.
+ *
+ * ### Key Behaviors:
+ *
+ * **Intersection-Based Activation**: Uses IntersectionObserver to detect when headings enter/exit
+ * the viewport. Activates the first intersecting heading, or maintains the current active heading
+ * when no headings are intersecting (persistence through long sections).
+ *
+ * **Responsive Debouncing**: Uses 16ms debounce delay (single frame) for responsive updates
+ * while preventing excessive DOM changes during scrolling.
+ *
+ * **Performance Optimized**: Leverages IO-provided bounding rects to avoid manual getBoundingClientRect
+ * calls, with automatic cache invalidation on window resize.
+ *
+ * **Manual Refresh**: Call `refresh()` method after DOM changes to reinitialize heading tracking.
+ *
+ * ### Edge Cases:
+ * - Page top: Activates first heading when no intersections
+ * - Page bottom: Activates last heading when no intersections
+ * - No intersections: Maintains current active heading or finds most recently passed
+ * - When the URL hash changes, if the targeted element is within a tracked section, that
+ *   section must be activated.
+ */
 export declare class ScrollSpyController implements ReactiveController {
     #private;
     private host;
+    /**
+     * Call to re-initialize scroll spy's DOM representation.
+     * Call this method if your SPA framework replaces the DOM, e.g. on route change.
+     */
+    static refresh(): void;
     get root(): Element | Document | null | undefined;
     set root(v: Element | Document | null | undefined);
     get rootMargin(): string | undefined;
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
index 1e8466d..8a4e874 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
@@ -1,7 +1,46 @@
-var _ScrollSpyController_instances, _a, _ScrollSpyController_instances_1, _ScrollSpyController_tagNames, _ScrollSpyController_activeAttribute, _ScrollSpyController_io, _ScrollSpyController_passedLinks, _ScrollSpyController_force, _ScrollSpyController_intersected, _ScrollSpyController_root, _ScrollSpyController_rootMargin, _ScrollSpyController_threshold, _ScrollSpyController_intersectingTargets, _ScrollSpyController_linkTargetMap, _ScrollSpyController_getRootNode, _ScrollSpyController_getHash, _ScrollSpyController_onIntersection, _ScrollSpyController_linkChildren_get, _ScrollSpyController_initializing, _ScrollSpyController_initIo, _ScrollSpyController_markPassed, _ScrollSpyController_setActive, _ScrollSpyController_activateHash, _ScrollSpyController_nextIntersection, _ScrollSpyController_onIo;
+var _ScrollSpyController_instances, _a, _ScrollSpyController_instances_1, _ScrollSpyController_tagNames, _ScrollSpyController_activeAttribute, _ScrollSpyController_io, _ScrollSpyController_intersected, _ScrollSpyController_root, _ScrollSpyController_rootMargin, _ScrollSpyController_threshold, _ScrollSpyController_headingStates, _ScrollSpyController_rectCache, _ScrollSpyController_activeHeading, _ScrollSpyController_debounceTimeout, _ScrollSpyController_isNavigating, _ScrollSpyController_linkTargetMap, _ScrollSpyController_targetLinkMap, _ScrollSpyController_getRootNode, _ScrollSpyController_getHash, _ScrollSpyController_onIntersection, _ScrollSpyController_linkChildren_get, _ScrollSpyController_initializing, _ScrollSpyController_reconcile, _ScrollSpyController_performReconciliation, _ScrollSpyController_getLastTrackedHeading, _ScrollSpyController_getDocumentOrder, _ScrollSpyController_getFirstTrackedHeading, _ScrollSpyController_getLastPassedHeading, _ScrollSpyController_getIntersectingHeadings, _ScrollSpyController_selectBestIntersectingHeading, _ScrollSpyController_findContainingTrackedSection, _ScrollSpyController_initIo, _ScrollSpyController_getHeadingLevel, _ScrollSpyController_setActive, _ScrollSpyController_activateHash, _ScrollSpyController_nextIntersection, _ScrollSpyController_onIo, _ScrollSpyController_setupResizeListener, _ScrollSpyController_refresh;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
 import { isServer } from 'lit';
+;
+/**
+ * A reactive controller that implements the scroll-spy pattern for table of contents navigation.
+ *
+ * ## Logic Overview
+ *
+ * This controller tracks heading elements and activates the corresponding ToC link based on
+ * which headings are currently visible in the viewport.
+ *
+ * ### Key Behaviors:
+ *
+ * **Intersection-Based Activation**: Uses IntersectionObserver to detect when headings enter/exit
+ * the viewport. Activates the first intersecting heading, or maintains the current active heading
+ * when no headings are intersecting (persistence through long sections).
+ *
+ * **Responsive Debouncing**: Uses 16ms debounce delay (single frame) for responsive updates
+ * while preventing excessive DOM changes during scrolling.
+ *
+ * **Performance Optimized**: Leverages IO-provided bounding rects to avoid manual getBoundingClientRect
+ * calls, with automatic cache invalidation on window resize.
+ *
+ * **Manual Refresh**: Call `refresh()` method after DOM changes to reinitialize heading tracking.
+ *
+ * ### Edge Cases:
+ * - Page top: Activates first heading when no intersections
+ * - Page bottom: Activates last heading when no intersections
+ * - No intersections: Maintains current active heading or finds most recently passed
+ * - When the URL hash changes, if the targeted element is within a tracked section, that
+ *   section must be activated.
+ */
 export class ScrollSpyController {
+    /**
+     * Call to re-initialize scroll spy's DOM representation.
+     * Call this method if your SPA framework replaces the DOM, e.g. on route change.
+     */
+    static refresh() {
+        for (const instance of __classPrivateFieldGet(this, _a, "f", _ScrollSpyController_instances_1)) {
+            __classPrivateFieldGet(instance, _ScrollSpyController_instances, "m", _ScrollSpyController_refresh).call(instance);
+        }
+    }
     get root() {
         return __classPrivateFieldGet(this, _ScrollSpyController_root, "f");
     }
@@ -32,17 +71,19 @@ export class ScrollSpyController {
         _ScrollSpyController_tagNames.set(this, void 0);
         _ScrollSpyController_activeAttribute.set(this, void 0);
         _ScrollSpyController_io.set(this, void 0);
-        /** Which link's targets have already scrolled past? */
-        _ScrollSpyController_passedLinks.set(this, new Set());
-        /** Ignore intersections? */
-        _ScrollSpyController_force.set(this, false);
         /** Has the intersection observer found an element? */
         _ScrollSpyController_intersected.set(this, false);
         _ScrollSpyController_root.set(this, void 0);
         _ScrollSpyController_rootMargin.set(this, void 0);
         _ScrollSpyController_threshold.set(this, void 0);
-        _ScrollSpyController_intersectingTargets.set(this, new Set());
+        _ScrollSpyController_headingStates.set(this, new Map());
+        _ScrollSpyController_rectCache.set(this, new Map());
+        /** The currently active heading that persists through long sections */
+        _ScrollSpyController_activeHeading.set(this, null);
+        _ScrollSpyController_debounceTimeout.set(this, null);
+        _ScrollSpyController_isNavigating.set(this, false);
         _ScrollSpyController_linkTargetMap.set(this, new Map());
+        _ScrollSpyController_targetLinkMap.set(this, new Map());
         _ScrollSpyController_getRootNode.set(this, void 0);
         _ScrollSpyController_getHash.set(this, void 0);
         _ScrollSpyController_onIntersection.set(this, void 0);
@@ -52,7 +93,7 @@ export class ScrollSpyController {
         __classPrivateFieldSet(this, _ScrollSpyController_root, options.root, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_rootMargin, options.rootMargin, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_activeAttribute, options.activeAttribute ?? 'active', "f");
-        __classPrivateFieldSet(this, _ScrollSpyController_threshold, options.threshold ?? 0.85, "f");
+        __classPrivateFieldSet(this, _ScrollSpyController_threshold, options.threshold ?? [0, 0.1], "f");
         __classPrivateFieldSet(this, _ScrollSpyController_getRootNode, () => options.rootNode ?? host.getRootNode?.() ?? null, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_getHash, options?.getHash ?? ((el) => el.getAttribute('href')), "f");
         __classPrivateFieldSet(this, _ScrollSpyController_onIntersection, options?.onIntersection, "f");
@@ -60,30 +101,26 @@ export class ScrollSpyController {
     hostConnected() {
         __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).add(this);
         __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_initIo).call(this);
+        __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setupResizeListener).call(this);
     }
     hostDisconnected() {
         __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).delete(this);
         __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.disconnect();
+        if (__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f")) {
+            clearTimeout(__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f"));
+            __classPrivateFieldSet(this, _ScrollSpyController_debounceTimeout, null, "f");
+        }
     }
     /**
      * Explicitly set the active item
      * @param link usually an `<a>`
      */
     async setActive(link) {
-        __classPrivateFieldSet(this, _ScrollSpyController_force, true, "f");
         __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, link);
-        let sawActive = false;
-        for (const child of __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)) {
-            __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_markPassed).call(this, child, !sawActive);
-            if (child === link) {
-                sawActive = true;
-            }
-        }
         await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
-        __classPrivateFieldSet(this, _ScrollSpyController_force, false, "f");
     }
 }
-_a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttribute = new WeakMap(), _ScrollSpyController_io = new WeakMap(), _ScrollSpyController_passedLinks = new WeakMap(), _ScrollSpyController_force = new WeakMap(), _ScrollSpyController_intersected = new WeakMap(), _ScrollSpyController_root = new WeakMap(), _ScrollSpyController_rootMargin = new WeakMap(), _ScrollSpyController_threshold = new WeakMap(), _ScrollSpyController_intersectingTargets = new WeakMap(), _ScrollSpyController_linkTargetMap = new WeakMap(), _ScrollSpyController_getRootNode = new WeakMap(), _ScrollSpyController_getHash = new WeakMap(), _ScrollSpyController_onIntersection = new WeakMap(), _ScrollSpyController_initializing = new WeakMap(), _ScrollSpyController_instances = new WeakSet(), _ScrollSpyController_linkChildren_get = function _ScrollSpyController_linkChildren_get() {
+_a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttribute = new WeakMap(), _ScrollSpyController_io = new WeakMap(), _ScrollSpyController_intersected = new WeakMap(), _ScrollSpyController_root = new WeakMap(), _ScrollSpyController_rootMargin = new WeakMap(), _ScrollSpyController_threshold = new WeakMap(), _ScrollSpyController_headingStates = new WeakMap(), _ScrollSpyController_rectCache = new WeakMap(), _ScrollSpyController_activeHeading = new WeakMap(), _ScrollSpyController_debounceTimeout = new WeakMap(), _ScrollSpyController_isNavigating = new WeakMap(), _ScrollSpyController_linkTargetMap = new WeakMap(), _ScrollSpyController_targetLinkMap = new WeakMap(), _ScrollSpyController_getRootNode = new WeakMap(), _ScrollSpyController_getHash = new WeakMap(), _ScrollSpyController_onIntersection = new WeakMap(), _ScrollSpyController_initializing = new WeakMap(), _ScrollSpyController_instances = new WeakSet(), _ScrollSpyController_linkChildren_get = function _ScrollSpyController_linkChildren_get() {
     if (isServer) {
         return [];
     }
@@ -91,11 +128,184 @@ _a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _Scroll
         return Array.from(this.host.querySelectorAll(__classPrivateFieldGet(this, _ScrollSpyController_tagNames, "f").join(',')))
             .filter(__classPrivateFieldGet(this, _ScrollSpyController_getHash, "f"));
     }
+}, _ScrollSpyController_reconcile = function _ScrollSpyController_reconcile() {
+    if (__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f")) {
+        clearTimeout(__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f"));
+    }
+    __classPrivateFieldSet(this, _ScrollSpyController_debounceTimeout, setTimeout(() => {
+        __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_performReconciliation).call(this);
+    }, 16), "f"); // Single frame delay
+}, _ScrollSpyController_performReconciliation = function _ScrollSpyController_performReconciliation() {
+    // Skip reconciliation during hash navigation to prevent flicker
+    if (__classPrivateFieldGet(this, _ScrollSpyController_isNavigating, "f")) {
+        return;
+    }
+    const { scrollY, innerHeight } = window;
+    const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
+    const isAtPageTop = scrollY <= 100; // Increased buffer for better UX
+    // More robust bottom detection with multiple conditions
+    const scrollBottom = scrollY + innerHeight;
+    const isAtPageBottom = (scrollBottom >= documentHeight - 50 // Within 50px of bottom
+        || Math.abs(scrollBottom - documentHeight) <= 5 // Very close to bottom
+        || scrollY + innerHeight >= document.documentElement.scrollHeight - 50 // Alternative check
+    );
+    let targetHeading = null;
+    const intersectingHeadings = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getIntersectingHeadings).call(this);
+    if (isAtPageTop) {
+        // Page top edge case: Always activate first heading when near top
+        targetHeading = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getFirstTrackedHeading).call(this);
+    }
+    else if (isAtPageBottom) {
+        // Page bottom edge case: Always activate last heading when near bottom
+        targetHeading = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getLastTrackedHeading).call(this);
+    }
+    else if (intersectingHeadings.length > 0) {
+        // Active intersections: Choose the most appropriate one
+        targetHeading = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_selectBestIntersectingHeading).call(this, intersectingHeadings);
+    }
+    else {
+        // No intersections: Maintain current or find most recently passed
+        targetHeading = __classPrivateFieldGet(this, _ScrollSpyController_activeHeading, "f") ?? __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getLastPassedHeading).call(this);
+        // Fallback: if no recently passed heading found, use first heading
+        if (!targetHeading) {
+            targetHeading = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getFirstTrackedHeading).call(this);
+        }
+    }
+    // Only update if heading has actually changed
+    if (targetHeading && targetHeading !== __classPrivateFieldGet(this, _ScrollSpyController_activeHeading, "f")) {
+        __classPrivateFieldSet(this, _ScrollSpyController_activeHeading, targetHeading, "f");
+        const link = __classPrivateFieldGet(this, _ScrollSpyController_targetLinkMap, "f").get(targetHeading);
+        if (link) {
+            __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, link);
+        }
+    }
+}, _ScrollSpyController_getLastTrackedHeading = function _ScrollSpyController_getLastTrackedHeading() {
+    const sortedHeadings = [...__classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").keys()]
+        .sort((a, b) => __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, b) - __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, a));
+    return sortedHeadings[0] ?? null;
+}, _ScrollSpyController_getDocumentOrder = function _ScrollSpyController_getDocumentOrder(element) {
+    return __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").get(element)?.documentOrder ?? 0;
+}, _ScrollSpyController_getFirstTrackedHeading = function _ScrollSpyController_getFirstTrackedHeading() {
+    const sortedHeadings = [...__classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").keys()]
+        .sort((a, b) => __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, a) - __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, b));
+    return sortedHeadings[0] ?? null;
+}, _ScrollSpyController_getLastPassedHeading = function _ScrollSpyController_getLastPassedHeading() {
+    // Reading position is 20% down the viewport - where users typically focus
+    const readingPosition = window.scrollY + window.innerHeight * 0.2;
+    const viewportTop = window.scrollY;
+    // Find all headings that have been scrolled past the reading position
+    const passedHeadings = [];
+    for (const [heading, state] of __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f")) {
+        // A heading is "passed" if its position is above the reading position
+        // Use a small buffer to handle edge cases with very small headings
+        const headingPosition = state.lastSeenY;
+        const hasPassedReadingPosition = headingPosition < readingPosition - 10;
+        if (hasPassedReadingPosition) {
+            passedHeadings.push({ heading, state });
+        }
+    }
+    if (passedHeadings.length === 0) {
+        // No headings have been passed, check if we're above all content
+        // and return the first heading if we're near the top
+        if (viewportTop < 200) {
+            return __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getFirstTrackedHeading).call(this);
+        }
+        return null;
+    }
+    // Sort by document order (descending) to get the last heading that was passed
+    passedHeadings.sort((a, b) => b.state.documentOrder - a.state.documentOrder);
+    // Return the heading with the highest document order that has been passed
+    return passedHeadings[0].heading;
+}, _ScrollSpyController_getIntersectingHeadings = function _ScrollSpyController_getIntersectingHeadings() {
+    const intersecting = [];
+    for (const [heading, state] of __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f")) {
+        if (state.isIntersecting) {
+            intersecting.push(heading);
+        }
+    }
+    return intersecting;
+}, _ScrollSpyController_selectBestIntersectingHeading = function _ScrollSpyController_selectBestIntersectingHeading(intersectingHeadings) {
+    if (intersectingHeadings.length === 1) {
+        return intersectingHeadings[0];
+    }
+    // Reading position is 20% down the viewport - where users typically focus
+    const readingPosition = window.scrollY + window.innerHeight * 0.2;
+    let [bestHeading] = intersectingHeadings;
+    let minDistance = Infinity;
+    for (const heading of intersectingHeadings) {
+        const state = __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").get(heading);
+        if (state) {
+            // Calculate distance from reading position to heading
+            const distance = Math.abs(state.lastSeenY - readingPosition);
+            // Prefer headings closer to reading position
+            // In case of tie, prefer earlier in document order
+            if (distance < minDistance
+                || (distance === minDistance
+                    && state.documentOrder < __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, bestHeading))) {
+                minDistance = distance;
+                bestHeading = heading;
+            }
+        }
+    }
+    return bestHeading;
+}, _ScrollSpyController_findContainingTrackedSection = function _ScrollSpyController_findContainingTrackedSection(targetElement) {
+    const trackedHeadings = [...__classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").keys()];
+    if (trackedHeadings.length === 0) {
+        return null;
+    }
+    // Sort headings by document order to process them in sequence
+    const sortedHeadings = trackedHeadings.sort((a, b) => __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, a) - __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getDocumentOrder).call(this, b));
+    // Use DOM position comparison for more reliable ordering
+    const targetRect = targetElement.getBoundingClientRect();
+    const targetTop = targetRect.top + window.scrollY;
+    let containingHeading = null;
+    let nextHeading = null;
+    // Find the heading that comes before the target and the one that comes after
+    for (let i = 0; i < sortedHeadings.length; i++) {
+        const heading = sortedHeadings[i];
+        const headingRect = heading.getBoundingClientRect();
+        const headingTop = headingRect.top + window.scrollY;
+        if (headingTop <= targetTop) {
+            containingHeading = heading;
+            nextHeading = sortedHeadings[i + 1] || null;
+        }
+        else {
+            break;
+        }
+    }
+    // If we found a containing heading, verify it's actually the right one
+    if (containingHeading) {
+        // If there's a next heading, make sure our target is before it
+        if (nextHeading) {
+            const nextRect = nextHeading.getBoundingClientRect();
+            const nextTop = nextRect.top + window.scrollY;
+            // If target is after the next heading, it doesn't belong to the containing section
+            if (targetTop >= nextTop) {
+                return null;
+            }
+        }
+        return containingHeading;
+    }
+    // If no heading comes before the target, check if target is before the first heading
+    if (sortedHeadings.length > 0) {
+        const [firstHeading] = sortedHeadings;
+        const firstRect = firstHeading.getBoundingClientRect();
+        const firstTop = firstRect.top + window.scrollY;
+        // If target is before the first heading, it belongs to the first section
+        if (targetTop < firstTop) {
+            return firstHeading;
+        }
+    }
+    return null;
 }, _ScrollSpyController_initIo = async function _ScrollSpyController_initIo() {
     const rootNode = __classPrivateFieldGet(this, _ScrollSpyController_getRootNode, "f").call(this);
     if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {
-        const { rootMargin, threshold, root } = this;
+        const { threshold, root } = this;
+        const rootMargin = this.rootMargin ?? '0px';
         __classPrivateFieldSet(this, _ScrollSpyController_io, new IntersectionObserver(r => __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_onIo).call(this, r), { root, rootMargin, threshold }), "f");
+        __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").clear();
+        __classPrivateFieldGet(this, _ScrollSpyController_rectCache, "f").clear();
+        let documentOrder = 0;
         for (const link of __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)) {
             const id = __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, link)?.replace('#', '');
             if (id) {
@@ -103,31 +313,87 @@ _a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _Scroll
                 if (target) {
                     __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.observe(target);
                     __classPrivateFieldGet(this, _ScrollSpyController_linkTargetMap, "f").set(link, target);
+                    __classPrivateFieldGet(this, _ScrollSpyController_targetLinkMap, "f").set(target, link);
+                    const level = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_getHeadingLevel).call(this, target);
+                    const rect = target.getBoundingClientRect();
+                    // Pre-populate rect cache and heading state
+                    __classPrivateFieldGet(this, _ScrollSpyController_rectCache, "f").set(target, rect);
+                    __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").set(target, {
+                        isIntersecting: false,
+                        lastSeenY: rect.top + window.scrollY,
+                        level,
+                        documentOrder: documentOrder++,
+                    });
                 }
             }
         }
     }
-}, _ScrollSpyController_markPassed = function _ScrollSpyController_markPassed(link, force) {
-    if (force) {
-        __classPrivateFieldGet(this, _ScrollSpyController_passedLinks, "f").add(link);
-    }
-    else {
-        __classPrivateFieldGet(this, _ScrollSpyController_passedLinks, "f").delete(link);
-    }
+}, _ScrollSpyController_getHeadingLevel = function _ScrollSpyController_getHeadingLevel(element) {
+    const tagName = element.tagName.toLowerCase();
+    const match = tagName.match(/^h(\d)$/);
+    return match ? parseInt(match[1], 10) : 999;
 }, _ScrollSpyController_setActive = function _ScrollSpyController_setActive(link) {
     for (const child of __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)) {
         child.toggleAttribute(__classPrivateFieldGet(this, _ScrollSpyController_activeAttribute, "f"), child === link);
     }
 }, _ScrollSpyController_activateHash = async function _ScrollSpyController_activateHash() {
+    // Set navigation flag to prevent reconciliation flicker
+    __classPrivateFieldSet(this, _ScrollSpyController_isNavigating, true, "f");
+    // Clear any pending reconciliation
+    if (__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f")) {
+        clearTimeout(__classPrivateFieldGet(this, _ScrollSpyController_debounceTimeout, "f"));
+        __classPrivateFieldSet(this, _ScrollSpyController_debounceTimeout, null, "f");
+    }
     const links = __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get);
     const { hash } = location;
     if (!hash) {
         this.setActive(links.at(0) ?? null);
     }
     else {
-        await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
-        this.setActive(links.find(x => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, x) === hash) ?? null);
+        // First try to find a direct link match
+        const directLink = links.find(x => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, x) === hash);
+        if (directLink) {
+            await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
+            this.setActive(directLink);
+            // Update active heading for consistency
+            const target = __classPrivateFieldGet(this, _ScrollSpyController_linkTargetMap, "f").get(directLink);
+            if (target) {
+                __classPrivateFieldSet(this, _ScrollSpyController_activeHeading, target, "f");
+            }
+        }
+        else {
+            // If no direct link match, check if the hash targets an element within a tracked section
+            const targetElement = document.getElementById(hash.slice(1));
+            if (targetElement) {
+                const containingSection = __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_findContainingTrackedSection).call(this, targetElement);
+                if (containingSection) {
+                    const sectionLink = __classPrivateFieldGet(this, _ScrollSpyController_targetLinkMap, "f").get(containingSection);
+                    if (sectionLink) {
+                        await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
+                        this.setActive(sectionLink);
+                        // Update active heading to maintain consistency
+                        __classPrivateFieldSet(this, _ScrollSpyController_activeHeading, containingSection, "f");
+                    }
+                }
+                else {
+                    // No containing section found, clear active state
+                    await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
+                    this.setActive(null);
+                    __classPrivateFieldSet(this, _ScrollSpyController_activeHeading, null, "f");
+                }
+            }
+            else {
+                // Hash target not found, clear active state
+                await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
+                this.setActive(null);
+                __classPrivateFieldSet(this, _ScrollSpyController_activeHeading, null, "f");
+            }
+        }
     }
+    // Clear navigation flag after a short delay to allow scroll to settle
+    setTimeout(() => {
+        __classPrivateFieldSet(this, _ScrollSpyController_isNavigating, false, "f");
+    }, 300); // Give time for any programmatic scrolling to complete
 }, _ScrollSpyController_nextIntersection = async function _ScrollSpyController_nextIntersection() {
     __classPrivateFieldSet(this, _ScrollSpyController_intersected, false, "f");
     // safeguard the loop
@@ -136,50 +402,44 @@ _a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _Scroll
         await new Promise(requestAnimationFrame);
     }
 }, _ScrollSpyController_onIo = async function _ScrollSpyController_onIo(entries) {
-    if (!__classPrivateFieldGet(this, _ScrollSpyController_force, "f")) {
-        for (const { target, boundingClientRect, intersectionRect } of entries) {
-            const selector = `:is(${__classPrivateFieldGet(this, _ScrollSpyController_tagNames, "f").join(',')})[href="#${target.id}"]`;
-            const link = this.host.querySelector(selector);
-            if (link) {
-                __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_markPassed).call(this, link, boundingClientRect.top < intersectionRect.top);
-            }
-        }
-        const link = [...__classPrivateFieldGet(this, _ScrollSpyController_passedLinks, "f")];
-        const last = link.at(-1);
-        __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, last ?? __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).at(0));
-    }
     __classPrivateFieldSet(this, _ScrollSpyController_intersected, true, "f");
-    __classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").clear();
     for (const entry of entries) {
-        if (entry.isIntersecting) {
-            __classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").add(entry.target);
+        const state = __classPrivateFieldGet(this, _ScrollSpyController_headingStates, "f").get(entry.target);
+        if (state) {
+            state.isIntersecting = entry.isIntersecting;
+            const rect = entry.boundingClientRect;
+            state.lastSeenY = rect.top + window.scrollY;
+            // Update rect cache with IO-provided rect (performance optimization)
+            __classPrivateFieldGet(this, _ScrollSpyController_rectCache, "f").set(entry.target, rect);
         }
     }
     if (__classPrivateFieldGet(this, _ScrollSpyController_initializing, "f")) {
-        const ints = entries?.filter(x => x.isIntersecting) ?? [];
-        if (__classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").size > 0) {
-            const [{ target = null } = {}] = ints;
-            const { id } = target ?? {};
-            if (id) {
-                const link = __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).find(link => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, link) === `#${id}`);
-                if (link) {
-                    __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, link);
-                }
-            }
-        }
         __classPrivateFieldSet(this, _ScrollSpyController_initializing, false, "f");
     }
     __classPrivateFieldGet(this, _ScrollSpyController_onIntersection, "f")?.call(this);
+    __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_reconcile).call(this);
+}, _ScrollSpyController_setupResizeListener = function _ScrollSpyController_setupResizeListener() {
+    if (!isServer) {
+        addEventListener('resize', () => {
+            __classPrivateFieldGet(this, _ScrollSpyController_rectCache, "f").clear();
+        }, { passive: true });
+    }
+}, _ScrollSpyController_refresh = function _ScrollSpyController_refresh() {
+    __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.disconnect();
+    __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_initIo).call(this);
 };
 _ScrollSpyController_instances_1 = { value: new Set };
 (() => {
     if (!isServer) {
         addEventListener('scroll', () => {
-            if (Math.round(window.innerHeight + window.scrollY) >= document.body.scrollHeight) {
-                __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
-                    __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(ssc, __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).at(-1));
-                });
-            }
+            __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
+                __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "m", _ScrollSpyController_reconcile).call(ssc);
+            });
+        }, { passive: true });
+        addEventListener('scrollend', () => {
+            __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
+                __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "m", _ScrollSpyController_reconcile).call(ssc);
+            });
         }, { passive: true });
         addEventListener('hashchange', () => {
             __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
index f350c7e..beb1433 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"scroll-spy-controller.js","sourceRoot":"","sources":["scroll-spy-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';\n\nexport interface ScrollSpyControllerOptions extends IntersectionObserverInit {\n  /**\n   * Tag names of legal link children.\n   * Legal children must have an `href` property/attribute pair, like `<a>`.\n   */\n  tagNames: string[];\n\n  /**\n   * Attribute to set on the active link element.\n   * @default 'active'\n   */\n  activeAttribute?: string;\n\n  /**\n   * The root node to query content for\n   * @default the host's root node\n   */\n  rootNode?: Node;\n\n  /**\n   * function to call on link children to get their URL hash (i.e. id to scroll to)\n   * @default el => el.getAttribute('href');\n   */\n  getHash?: (el: Element) => string | null;\n\n  /**\n   * Optional callback for when an intersection occurs\n   */\n  onIntersection?(): void;\n}\n\nexport class ScrollSpyController implements ReactiveController {\n  static #instances = new Set<ScrollSpyController>;\n\n  static {\n    if (!isServer) {\n      addEventListener('scroll', () => {\n        if (Math.round(window.innerHeight + window.scrollY) >= document.body.scrollHeight) {\n          this.#instances.forEach(ssc => {\n            ssc.#setActive(ssc.#linkChildren.at(-1));\n          });\n        }\n      }, { passive: true });\n      addEventListener('hashchange', () => {\n        this.#instances.forEach(ssc => {\n          ssc.#activateHash();\n        });\n      });\n    }\n  }\n\n  #tagNames: string[];\n\n  #activeAttribute: string;\n\n  #io?: IntersectionObserver;\n\n  /** Which link's targets have already scrolled past? */\n  #passedLinks = new Set<Element>();\n\n  /** Ignore intersections? */\n  #force = false;\n\n  /** Has the intersection observer found an element? */\n  #intersected = false;\n\n  #root: ScrollSpyControllerOptions['root'];\n\n  #rootMargin?: string;\n\n  #threshold: number | number[];\n\n  #intersectingTargets = new Set<Element>();\n\n  #linkTargetMap = new Map<Element, Element | null>();\n\n  #getRootNode: () => Node | null;\n\n  #getHash: (el: Element) => string | null;\n\n  #onIntersection?: () => void;\n\n  get #linkChildren(): Element[] {\n    if (isServer) {\n      return [];\n    } else {\n      return Array.from(this.host.querySelectorAll(this.#tagNames.join(',')))\n          .filter(this.#getHash);\n    }\n  }\n\n  get root(): Element | Document | null | undefined {\n    return this.#root;\n  }\n\n  set root(v) {\n    this.#root = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get rootMargin(): string | undefined {\n    return this.#rootMargin;\n  }\n\n  set rootMargin(v) {\n    this.#rootMargin = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get threshold(): number | number[] {\n    return this.#threshold;\n  }\n\n  set threshold(v) {\n    this.#threshold = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  constructor(\n    private host: ReactiveControllerHost & HTMLElement,\n    options: ScrollSpyControllerOptions,\n  ) {\n    host.addController(this);\n    this.#tagNames = options.tagNames;\n    this.#root = options.root;\n    this.#rootMargin = options.rootMargin;\n    this.#activeAttribute = options.activeAttribute ?? 'active';\n    this.#threshold = options.threshold ?? 0.85;\n    this.#getRootNode = () => options.rootNode ?? host.getRootNode?.() ?? null;\n    this.#getHash = options?.getHash ?? ((el: Element) => el.getAttribute('href'));\n    this.#onIntersection = options?.onIntersection;\n  }\n\n  hostConnected(): void {\n    ScrollSpyController.#instances.add(this);\n    this.#initIo();\n  }\n\n  hostDisconnected(): void {\n    ScrollSpyController.#instances.delete(this);\n    this.#io?.disconnect();\n  }\n\n  #initializing = true;\n\n  async #initIo() {\n    const rootNode = this.#getRootNode();\n    if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {\n      const { rootMargin, threshold, root } = this;\n      this.#io = new IntersectionObserver(r => this.#onIo(r), { root, rootMargin, threshold });\n      for (const link of this.#linkChildren) {\n        const id = this.#getHash(link)?.replace('#', '');\n        if (id) {\n          const target = document.getElementById(id);\n          if (target) {\n            this.#io?.observe(target);\n            this.#linkTargetMap.set(link, target);\n          }\n        }\n      }\n    }\n  }\n\n  #markPassed(link: Element, force: boolean) {\n    if (force) {\n      this.#passedLinks.add(link);\n    } else {\n      this.#passedLinks.delete(link);\n    }\n  }\n\n  #setActive(link?: EventTarget | null) {\n    for (const child of this.#linkChildren) {\n      child.toggleAttribute(this.#activeAttribute, child === link);\n    }\n  }\n\n  async #activateHash() {\n    const links = this.#linkChildren;\n    const { hash } = location;\n    if (!hash) {\n      this.setActive(links.at(0) ?? null);\n    } else {\n      await this.#nextIntersection();\n      this.setActive(links.find(x => this.#getHash(x) === hash) ?? null);\n    }\n  }\n\n  async #nextIntersection() {\n    this.#intersected = false;\n    // safeguard the loop\n    setTimeout(() => this.#intersected = false, 3000);\n    while (!this.#intersected) {\n      await new Promise(requestAnimationFrame);\n    }\n  }\n\n  async #onIo(entries: IntersectionObserverEntry[]) {\n    if (!this.#force) {\n      for (const { target, boundingClientRect, intersectionRect } of entries) {\n        const selector = `:is(${this.#tagNames.join(',')})[href=\"#${target.id}\"]`;\n        const link = this.host.querySelector(selector);\n        if (link) {\n          this.#markPassed(link, boundingClientRect.top < intersectionRect.top);\n        }\n      }\n      const link = [...this.#passedLinks];\n      const last = link.at(-1);\n      this.#setActive(last ?? this.#linkChildren.at(0));\n    }\n    this.#intersected = true;\n    this.#intersectingTargets.clear();\n    for (const entry of entries) {\n      if (entry.isIntersecting) {\n        this.#intersectingTargets.add(entry.target);\n      }\n    }\n    if (this.#initializing) {\n      const ints = entries?.filter(x => x.isIntersecting) ?? [];\n      if (this.#intersectingTargets.size > 0) {\n        const [{ target = null } = {}] = ints;\n        const { id } = target ?? {};\n        if (id) {\n          const link = this.#linkChildren.find(link => this.#getHash(link) === `#${id}`);\n          if (link) {\n            this.#setActive(link);\n          }\n        }\n      }\n      this.#initializing = false;\n    }\n    this.#onIntersection?.();\n  }\n\n  /**\n   * Explicitly set the active item\n   * @param link usually an `<a>`\n   */\n  public async setActive(link: EventTarget | null): Promise<void> {\n    this.#force = true;\n    this.#setActive(link);\n    let sawActive = false;\n    for (const child of this.#linkChildren) {\n      this.#markPassed(child, !sawActive);\n      if (child === link) {\n        sawActive = true;\n      }\n    }\n    await this.#nextIntersection();\n    this.#force = false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"scroll-spy-controller.js","sourceRoot":"","sources":["scroll-spy-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';\n\nexport interface ScrollSpyControllerOptions extends IntersectionObserverInit {\n  /**\n   * Tag names of legal link children.\n   * Legal children must have an `href` property/attribute pair, like `<a>`.\n   */\n  tagNames: string[];\n\n  /**\n   * Attribute to set on the active link element.\n   * @default 'active'\n   */\n  activeAttribute?: string;\n\n  /**\n   * The root node to query content for\n   * @default the host's root node\n   */\n  rootNode?: Node;\n\n  /**\n   * function to call on link children to get their URL hash (i.e. id to scroll to)\n   * @default el => el.getAttribute('href');\n   */\n  getHash?: (el: Element) => string | null;\n\n  /**\n   * Optional callback for when an intersection occurs\n   */\n  onIntersection?(): void;\n}\n\ninterface HeadingState {\n  isIntersecting: boolean;\n  lastSeenY: number;\n  level: number;\n  documentOrder: number;\n};\n\n/**\n * A reactive controller that implements the scroll-spy pattern for table of contents navigation.\n *\n * ## Logic Overview\n *\n * This controller tracks heading elements and activates the corresponding ToC link based on\n * which headings are currently visible in the viewport.\n *\n * ### Key Behaviors:\n *\n * **Intersection-Based Activation**: Uses IntersectionObserver to detect when headings enter/exit\n * the viewport. Activates the first intersecting heading, or maintains the current active heading\n * when no headings are intersecting (persistence through long sections).\n *\n * **Responsive Debouncing**: Uses 16ms debounce delay (single frame) for responsive updates\n * while preventing excessive DOM changes during scrolling.\n *\n * **Performance Optimized**: Leverages IO-provided bounding rects to avoid manual getBoundingClientRect\n * calls, with automatic cache invalidation on window resize.\n *\n * **Manual Refresh**: Call `refresh()` method after DOM changes to reinitialize heading tracking.\n *\n * ### Edge Cases:\n * - Page top: Activates first heading when no intersections\n * - Page bottom: Activates last heading when no intersections\n * - No intersections: Maintains current active heading or finds most recently passed\n * - When the URL hash changes, if the targeted element is within a tracked section, that\n *   section must be activated.\n */\nexport class ScrollSpyController implements ReactiveController {\n  static #instances = new Set<ScrollSpyController>;\n\n  static {\n    if (!isServer) {\n      addEventListener('scroll', () => {\n        this.#instances.forEach(ssc => {\n          ssc.#reconcile();\n        });\n      }, { passive: true });\n      addEventListener('scrollend', () => {\n        this.#instances.forEach(ssc => {\n          ssc.#reconcile();\n        });\n      }, { passive: true });\n      addEventListener('hashchange', () => {\n        this.#instances.forEach(ssc => {\n          ssc.#activateHash();\n        });\n      });\n    }\n  }\n\n  /**\n   * Call to re-initialize scroll spy's DOM representation.\n   * Call this method if your SPA framework replaces the DOM, e.g. on route change.\n   */\n  static refresh(): void {\n    for (const instance of this.#instances) {\n      instance.#refresh();\n    }\n  }\n\n  #tagNames: string[];\n\n  #activeAttribute: string;\n\n  #io?: IntersectionObserver;\n\n  /** Has the intersection observer found an element? */\n  #intersected = false;\n\n  #root: ScrollSpyControllerOptions['root'];\n\n  #rootMargin?: string;\n\n  #threshold: number | number[];\n\n  #headingStates = new Map<Element, HeadingState>();\n\n  #rectCache = new Map<Element, DOMRect>();\n\n  /** The currently active heading that persists through long sections */\n  #activeHeading: Element | null = null;\n\n  #debounceTimeout: number | null = null;\n\n  #isNavigating = false;\n\n\n  #linkTargetMap = new Map<Element, Element | null>();\n  #targetLinkMap = new Map<Element, Element | null>();\n\n  #getRootNode: () => Node | null;\n\n  #getHash: (el: Element) => string | null;\n\n  #onIntersection?: () => void;\n\n  get #linkChildren(): Element[] {\n    if (isServer) {\n      return [];\n    } else {\n      return Array.from(this.host.querySelectorAll(this.#tagNames.join(',')))\n          .filter(this.#getHash);\n    }\n  }\n\n  get root(): Element | Document | null | undefined {\n    return this.#root;\n  }\n\n  set root(v) {\n    this.#root = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get rootMargin(): string | undefined {\n    return this.#rootMargin;\n  }\n\n  set rootMargin(v) {\n    this.#rootMargin = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get threshold(): number | number[] {\n    return this.#threshold;\n  }\n\n  set threshold(v) {\n    this.#threshold = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  constructor(\n    private host: ReactiveControllerHost & HTMLElement,\n    options: ScrollSpyControllerOptions,\n  ) {\n    host.addController(this);\n    this.#tagNames = options.tagNames;\n    this.#root = options.root;\n    this.#rootMargin = options.rootMargin;\n    this.#activeAttribute = options.activeAttribute ?? 'active';\n    this.#threshold = options.threshold ?? [0, 0.1];\n    this.#getRootNode = () => options.rootNode ?? host.getRootNode?.() ?? null;\n    this.#getHash = options?.getHash ?? ((el: Element) => el.getAttribute('href'));\n    this.#onIntersection = options?.onIntersection;\n  }\n\n  hostConnected(): void {\n    ScrollSpyController.#instances.add(this);\n    this.#initIo();\n    this.#setupResizeListener();\n  }\n\n  hostDisconnected(): void {\n    ScrollSpyController.#instances.delete(this);\n    this.#io?.disconnect();\n\n    if (this.#debounceTimeout) {\n      clearTimeout(this.#debounceTimeout);\n      this.#debounceTimeout = null;\n    }\n  }\n\n  #initializing = true;\n\n  /** Debounced reconciliation trigger - called on scroll events */\n  #reconcile() {\n    if (this.#debounceTimeout) {\n      clearTimeout(this.#debounceTimeout);\n    }\n\n    this.#debounceTimeout = setTimeout(() => {\n      this.#performReconciliation();\n    }, 16) as unknown as number; // Single frame delay\n  }\n\n  /** Main logic to determine and set the active heading */\n  #performReconciliation() {\n    // Skip reconciliation during hash navigation to prevent flicker\n    if (this.#isNavigating) {\n      return;\n    }\n\n    const { scrollY, innerHeight } = window;\n    const documentHeight = Math.max(\n      document.body.scrollHeight,\n      document.body.offsetHeight,\n      document.documentElement.clientHeight,\n      document.documentElement.scrollHeight,\n      document.documentElement.offsetHeight\n    );\n\n    const isAtPageTop = scrollY <= 100; // Increased buffer for better UX\n    // More robust bottom detection with multiple conditions\n    const scrollBottom = scrollY + innerHeight;\n    const isAtPageBottom = (\n      scrollBottom >= documentHeight - 50 // Within 50px of bottom\n      || Math.abs(scrollBottom - documentHeight) <= 5 // Very close to bottom\n      || scrollY + innerHeight >= document.documentElement.scrollHeight - 50 // Alternative check\n    );\n\n    let targetHeading: Element | null = null;\n    const intersectingHeadings = this.#getIntersectingHeadings();\n\n    if (isAtPageTop) {\n      // Page top edge case: Always activate first heading when near top\n      targetHeading = this.#getFirstTrackedHeading();\n    } else if (isAtPageBottom) {\n      // Page bottom edge case: Always activate last heading when near bottom\n      targetHeading = this.#getLastTrackedHeading();\n    } else if (intersectingHeadings.length > 0) {\n      // Active intersections: Choose the most appropriate one\n      targetHeading = this.#selectBestIntersectingHeading(intersectingHeadings);\n    } else {\n      // No intersections: Maintain current or find most recently passed\n      targetHeading = this.#activeHeading ?? this.#getLastPassedHeading();\n\n      // Fallback: if no recently passed heading found, use first heading\n      if (!targetHeading) {\n        targetHeading = this.#getFirstTrackedHeading();\n      }\n    }\n\n    // Only update if heading has actually changed\n    if (targetHeading && targetHeading !== this.#activeHeading) {\n      this.#activeHeading = targetHeading;\n      const link = this.#targetLinkMap.get(targetHeading);\n      if (link) {\n        this.#setActive(link);\n      }\n    }\n  }\n\n  #getLastTrackedHeading(): Element | null {\n    const sortedHeadings = [...this.#headingStates.keys()]\n        .sort((a, b) => this.#getDocumentOrder(b) - this.#getDocumentOrder(a));\n    return sortedHeadings[0] ?? null;\n  }\n\n  #getDocumentOrder(element: Element): number {\n    return this.#headingStates.get(element)?.documentOrder ?? 0;\n  }\n\n  #getFirstTrackedHeading(): Element | null {\n    const sortedHeadings = [...this.#headingStates.keys()]\n        .sort((a, b) => this.#getDocumentOrder(a) - this.#getDocumentOrder(b));\n    return sortedHeadings[0] ?? null;\n  }\n\n  /** Find the last heading that has been scrolled past (most recently passed) */\n  #getLastPassedHeading(): Element | null {\n    // Reading position is 20% down the viewport - where users typically focus\n    const readingPosition = window.scrollY + window.innerHeight * 0.2;\n    const viewportTop = window.scrollY;\n\n    // Find all headings that have been scrolled past the reading position\n    const passedHeadings: { heading: Element; state: HeadingState }[] = [];\n\n    for (const [heading, state] of this.#headingStates) {\n      // A heading is \"passed\" if its position is above the reading position\n      // Use a small buffer to handle edge cases with very small headings\n      const headingPosition = state.lastSeenY;\n      const hasPassedReadingPosition = headingPosition < readingPosition - 10;\n\n      if (hasPassedReadingPosition) {\n        passedHeadings.push({ heading, state });\n      }\n    }\n\n    if (passedHeadings.length === 0) {\n      // No headings have been passed, check if we're above all content\n      // and return the first heading if we're near the top\n      if (viewportTop < 200) {\n        return this.#getFirstTrackedHeading();\n      }\n      return null;\n    }\n\n    // Sort by document order (descending) to get the last heading that was passed\n    passedHeadings.sort((a, b) => b.state.documentOrder - a.state.documentOrder);\n\n    // Return the heading with the highest document order that has been passed\n    return passedHeadings[0].heading;\n  }\n\n  /** Get all currently intersecting headings */\n  #getIntersectingHeadings(): Element[] {\n    const intersecting: Element[] = [];\n    for (const [heading, state] of this.#headingStates) {\n      if (state.isIntersecting) {\n        intersecting.push(heading);\n      }\n    }\n    return intersecting;\n  }\n\n  /**\n   * Select the best heading from multiple intersecting ones.\n   * Prioritizes headings that are closer to the reading position (20% down viewport).\n   * @param intersectingHeadings - all headings that are currently intersecting the viewport\n   */\n  #selectBestIntersectingHeading(intersectingHeadings: Element[]): Element {\n    if (intersectingHeadings.length === 1) {\n      return intersectingHeadings[0];\n    }\n\n    // Reading position is 20% down the viewport - where users typically focus\n    const readingPosition = window.scrollY + window.innerHeight * 0.2;\n    let [bestHeading] = intersectingHeadings;\n    let minDistance = Infinity;\n\n    for (const heading of intersectingHeadings) {\n      const state = this.#headingStates.get(heading);\n      if (state) {\n        // Calculate distance from reading position to heading\n        const distance = Math.abs(state.lastSeenY - readingPosition);\n\n        // Prefer headings closer to reading position\n        // In case of tie, prefer earlier in document order\n        if (distance < minDistance\n            || (\n              distance === minDistance\n              && state.documentOrder < this.#getDocumentOrder(bestHeading)\n            )\n        ) {\n          minDistance = distance;\n          bestHeading = heading;\n        }\n      }\n    }\n\n    return bestHeading;\n  }\n\n  /**\n   * Find the tracked heading section that contains the given element.\n   * This determines which section an element logically belongs to based on document order.\n   * @param targetElement element tracked by scroll-spy-controller (i.e. link)\n   */\n  #findContainingTrackedSection(targetElement: Element): Element | null {\n    const trackedHeadings = [...this.#headingStates.keys()];\n    if (trackedHeadings.length === 0) {\n      return null;\n    }\n\n    // Sort headings by document order to process them in sequence\n    const sortedHeadings = trackedHeadings.sort((a, b) =>\n      this.#getDocumentOrder(a) - this.#getDocumentOrder(b)\n    );\n\n    // Use DOM position comparison for more reliable ordering\n    const targetRect = targetElement.getBoundingClientRect();\n    const targetTop = targetRect.top + window.scrollY;\n\n    let containingHeading: Element | null = null;\n    let nextHeading: Element | null = null;\n\n    // Find the heading that comes before the target and the one that comes after\n    for (let i = 0; i < sortedHeadings.length; i++) {\n      const heading = sortedHeadings[i];\n      const headingRect = heading.getBoundingClientRect();\n      const headingTop = headingRect.top + window.scrollY;\n\n      if (headingTop <= targetTop) {\n        containingHeading = heading;\n        nextHeading = sortedHeadings[i + 1] || null;\n      } else {\n        break;\n      }\n    }\n\n    // If we found a containing heading, verify it's actually the right one\n    if (containingHeading) {\n      // If there's a next heading, make sure our target is before it\n      if (nextHeading) {\n        const nextRect = nextHeading.getBoundingClientRect();\n        const nextTop = nextRect.top + window.scrollY;\n\n        // If target is after the next heading, it doesn't belong to the containing section\n        if (targetTop >= nextTop) {\n          return null;\n        }\n      }\n\n      return containingHeading;\n    }\n\n    // If no heading comes before the target, check if target is before the first heading\n    if (sortedHeadings.length > 0) {\n      const [firstHeading] = sortedHeadings;\n      const firstRect = firstHeading.getBoundingClientRect();\n      const firstTop = firstRect.top + window.scrollY;\n\n      // If target is before the first heading, it belongs to the first section\n      if (targetTop < firstTop) {\n        return firstHeading;\n      }\n    }\n\n    return null;\n  }\n\n  async #initIo() {\n    const rootNode = this.#getRootNode();\n    if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {\n      const { threshold, root } = this;\n      const rootMargin = this.rootMargin ?? '0px';\n      this.#io = new IntersectionObserver(r => this.#onIo(r), { root, rootMargin, threshold });\n\n      this.#headingStates.clear();\n      this.#rectCache.clear();\n      let documentOrder = 0;\n\n      for (const link of this.#linkChildren) {\n        const id = this.#getHash(link)?.replace('#', '');\n        if (id) {\n          const target = document.getElementById(id);\n          if (target) {\n            this.#io?.observe(target);\n            this.#linkTargetMap.set(link, target);\n            this.#targetLinkMap.set(target, link);\n\n            const level = this.#getHeadingLevel(target);\n            const rect = target.getBoundingClientRect();\n\n            // Pre-populate rect cache and heading state\n            this.#rectCache.set(target, rect);\n            this.#headingStates.set(target, {\n              isIntersecting: false,\n              lastSeenY: rect.top + window.scrollY,\n              level,\n              documentOrder: documentOrder++,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  #getHeadingLevel(element: Element): number {\n    const tagName = element.tagName.toLowerCase();\n    const match = tagName.match(/^h(\\d)$/);\n    return match ? parseInt(match[1], 10) : 999;\n  }\n\n  #setActive(link?: EventTarget | null) {\n    for (const child of this.#linkChildren) {\n      child.toggleAttribute(this.#activeAttribute, child === link);\n    }\n  }\n\n  async #activateHash() {\n    // Set navigation flag to prevent reconciliation flicker\n    this.#isNavigating = true;\n\n    // Clear any pending reconciliation\n    if (this.#debounceTimeout) {\n      clearTimeout(this.#debounceTimeout);\n      this.#debounceTimeout = null;\n    }\n\n    const links = this.#linkChildren;\n    const { hash } = location;\n\n    if (!hash) {\n      this.setActive(links.at(0) ?? null);\n    } else {\n      // First try to find a direct link match\n      const directLink = links.find(x => this.#getHash(x) === hash);\n      if (directLink) {\n        await this.#nextIntersection();\n        this.setActive(directLink);\n        // Update active heading for consistency\n        const target = this.#linkTargetMap.get(directLink);\n        if (target) {\n          this.#activeHeading = target;\n        }\n      } else {\n        // If no direct link match, check if the hash targets an element within a tracked section\n        const targetElement = document.getElementById(hash.slice(1));\n        if (targetElement) {\n          const containingSection = this.#findContainingTrackedSection(targetElement);\n          if (containingSection) {\n            const sectionLink = this.#targetLinkMap.get(containingSection);\n            if (sectionLink) {\n              await this.#nextIntersection();\n              this.setActive(sectionLink);\n              // Update active heading to maintain consistency\n              this.#activeHeading = containingSection;\n            }\n          } else {\n            // No containing section found, clear active state\n            await this.#nextIntersection();\n            this.setActive(null);\n            this.#activeHeading = null;\n          }\n        } else {\n          // Hash target not found, clear active state\n          await this.#nextIntersection();\n          this.setActive(null);\n          this.#activeHeading = null;\n        }\n      }\n    }\n\n    // Clear navigation flag after a short delay to allow scroll to settle\n    setTimeout(() => {\n      this.#isNavigating = false;\n    }, 300); // Give time for any programmatic scrolling to complete\n  }\n\n  async #nextIntersection() {\n    this.#intersected = false;\n    // safeguard the loop\n    setTimeout(() => this.#intersected = false, 3000);\n    while (!this.#intersected) {\n      await new Promise(requestAnimationFrame);\n    }\n  }\n\n  async #onIo(entries: IntersectionObserverEntry[]) {\n    this.#intersected = true;\n\n    for (const entry of entries) {\n      const state = this.#headingStates.get(entry.target);\n      if (state) {\n        state.isIntersecting = entry.isIntersecting;\n        const rect = entry.boundingClientRect;\n        state.lastSeenY = rect.top + window.scrollY;\n\n        // Update rect cache with IO-provided rect (performance optimization)\n        this.#rectCache.set(entry.target, rect);\n      }\n    }\n\n    if (this.#initializing) {\n      this.#initializing = false;\n    }\n\n    this.#onIntersection?.();\n    this.#reconcile();\n  }\n\n  /**\n   * Explicitly set the active item\n   * @param link usually an `<a>`\n   */\n  public async setActive(link: EventTarget | null): Promise<void> {\n    this.#setActive(link);\n    await this.#nextIntersection();\n  }\n\n  #setupResizeListener(): void {\n    if (!isServer) {\n      addEventListener('resize', () => {\n        this.#rectCache.clear();\n      }, { passive: true });\n    }\n  }\n\n  /**\n   * Manually refresh heading tracking (call after DOM changes)\n   */\n  #refresh(): void {\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/custom-elements.json b/node_modules/@patternfly/pfe-core/custom-elements.json
index 20da7f5..91e9bed 100644
--- a/node_modules/@patternfly/pfe-core/custom-elements.json
+++ b/node_modules/@patternfly/pfe-core/custom-elements.json
@@ -650,7 +650,6 @@
       "declarations": [
         {
           "name": "InternalsController",
-          "description": "reactively forward the internals object's aria mixin prototype",
           "members": [
             {
               "name": "instances",
@@ -1477,7 +1476,7 @@
         },
         {
           "name": "ListboxController",
-          "description": "Options for listbox controller",
+          "description": "Implements listbox semantics and accesibility. As there are two recognized\npatterns for implementing keyboard interactions with listbox patterns,\nprovide a secondary controller (either RovingTabindexController or\nActiveDescendantController) to complete the implementation.",
           "members": [
             {
               "name": "instances",
@@ -2216,7 +2215,19 @@
       "declarations": [
         {
           "name": "ScrollSpyController",
+          "description": "A reactive controller that implements the scroll-spy pattern for table of contents navigation.\n* ## Logic Overview\n* This controller tracks heading elements and activates the corresponding ToC link based on\nwhich headings are currently visible in the viewport.\n* ### Key Behaviors:\n* **Intersection-Based Activation**: Uses IntersectionObserver to detect when headings enter/exit\nthe viewport. Activates the first intersecting heading, or maintains the current active heading\nwhen no headings are intersecting (persistence through long sections).\n* **Responsive Debouncing**: Uses 16ms debounce delay (single frame) for responsive updates\nwhile preventing excessive DOM changes during scrolling.\n* **Performance Optimized**: Leverages IO-provided bounding rects to avoid manual getBoundingClientRect\ncalls, with automatic cache invalidation on window resize.\n* **Manual Refresh**: Call `refresh()` method after DOM changes to reinitialize heading tracking.\n* ### Edge Cases:\n- Page top: Activates first heading when no intersections\n- Page bottom: Activates last heading when no intersections\n- No intersections: Maintains current active heading or finds most recently passed\n- When the URL hash changes, if the targeted element is within a tracked section, that\nsection must be activated.",
           "members": [
+            {
+              "return": {
+                "type": {
+                  "text": "void"
+                }
+              },
+              "name": "refresh",
+              "description": "Call to re-initialize scroll spy's DOM representation.\nCall this method if your SPA framework replaces the DOM, e.g. on route change.",
+              "kind": "method",
+              "static": true
+            },
             {
               "name": "root",
               "type": {
@@ -2879,7 +2890,6 @@
         },
         {
           "name": "Deprecation",
-          "description": "Aliases the decorated field to an existing property, and logs a warning if it is used",
           "members": [
             {
               "name": "logger",
