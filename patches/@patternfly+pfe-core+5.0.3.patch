diff --git a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.d.ts
index 802086a..071d4e8 100644
--- a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.d.ts
@@ -84,6 +84,12 @@ export declare class ActivedescendantController<Item extends HTMLElement = HTMLE
     set atFocusedItemIndex(index: number);
     protected get controlsElements(): HTMLElement[];
     protected set controlsElements(elements: HTMLElement[]);
+    /**
+     * Check the source item's focusable state, not the clone's.
+     * This is needed because filtering sets `hidden` on the light DOM item,
+     * and the MutationObserver sync to clones is asynchronous.
+     */
+    get atFocusableItems(): Item[];
     /** All items */
     get items(): Item[];
     /**
@@ -92,7 +98,8 @@ export declare class ActivedescendantController<Item extends HTMLElement = HTMLE
      */
     set items(items: Item[]);
     private constructor();
-    protected initItems(): void;
+    /** @internal */
+    initItems(): void;
     hostDisconnected(): void;
     protected onKeydown(event: KeyboardEvent): void;
     renderItemsToShadowRoot(): typeof nothing | Node[];
diff --git a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js
index 2a10c41..378c383 100644
--- a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js
@@ -70,7 +70,10 @@ export class ActivedescendantController extends ATFocusController {
         super.atFocusedItemIndex = index;
         const item = this._items.at(this.atFocusedItemIndex);
         for (const _item of this.items) {
-            this.options.setItemActive?.(_item, _item === item);
+            const isActive = _item === item;
+            // Map clone back to original item for setItemActive callback
+            const originalItem = __classPrivateFieldGet(this, _ActivedescendantController_shadowToLightMap, "f").get(_item) ?? _item;
+            this.options.setItemActive?.(originalItem, isActive);
         }
         const container = this.options.getActiveDescendantContainer();
         if (!ActivedescendantController.supportsCrossRootActiveDescendant) {
@@ -85,6 +88,12 @@ export class ActivedescendantController extends ATFocusController {
         return __classPrivateFieldGet(this, _ActivedescendantController_controlsElements, "f");
     }
     set controlsElements(elements) {
+        // Avoid removing/re-adding listeners if elements haven't changed
+        // This prevents breaking event listeners during active event dispatch
+        if (elements.length === __classPrivateFieldGet(this, _ActivedescendantController_controlsElements, "f").length
+            && elements.every((el, i) => el === __classPrivateFieldGet(this, _ActivedescendantController_controlsElements, "f")[i])) {
+            return;
+        }
         for (const old of __classPrivateFieldGet(this, _ActivedescendantController_controlsElements, "f")) {
             old?.removeEventListener('keydown', this.onKeydown);
         }
@@ -93,6 +102,21 @@ export class ActivedescendantController extends ATFocusController {
             element.addEventListener('keydown', this.onKeydown);
         }
     }
+    /**
+     * Check the source item's focusable state, not the clone's.
+     * This is needed because filtering sets `hidden` on the light DOM item,
+     * and the MutationObserver sync to clones is asynchronous.
+     */
+    get atFocusableItems() {
+        return this._items.filter(item => {
+            // Map clone to source item to check actual hidden state
+            const sourceItem = __classPrivateFieldGet(this, _ActivedescendantController_shadowToLightMap, "f").get(item) ?? item;
+            return !!sourceItem
+                && sourceItem.ariaHidden !== 'true'
+                && !sourceItem.hasAttribute('inert')
+                && !sourceItem.hasAttribute('hidden');
+        });
+    }
     /** All items */
     get items() {
         return this._items;
@@ -130,6 +154,11 @@ export class ActivedescendantController extends ATFocusController {
                     return item;
                 }
                 else {
+                    // Reuse existing clone if available to maintain stable IDs
+                    const existingClone = __classPrivateFieldGet(this, _ActivedescendantController_lightToShadowMap, "f").get(item);
+                    if (existingClone) {
+                        return existingClone;
+                    }
                     const clone = item.cloneNode(true);
                     clone.id = getRandomId();
                     __classPrivateFieldGet(this, _ActivedescendantController_lightToShadowMap, "f").set(item, clone);
@@ -160,12 +189,14 @@ export class ActivedescendantController extends ATFocusController {
         _ActivedescendantController_observing.set(this, false);
         _ActivedescendantController_listMO.set(this, new MutationObserver(records => __classPrivateFieldGet(this, _ActivedescendantController_instances, "m", _ActivedescendantController_onItemsDOMChange).call(this, records)));
         _ActivedescendantController_attrMO.set(this, new MutationObserver(records => __classPrivateFieldGet(this, _ActivedescendantController_instances, "m", _ActivedescendantController_onItemAttributeChange).call(this, records)));
+        this.initItems();
         (_a = this.options).getItemValue ?? (_a.getItemValue = function () {
             return this.value;
         });
     }
     ;
     ;
+    /** @internal */
     initItems() {
         __classPrivateFieldGet(this, _ActivedescendantController_attrMO, "f").disconnect();
         super.initItems();
diff --git a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js.map
index d29c284..a0e28c3 100644
--- a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"activedescendant-controller.js","sourceRoot":"","sources":["activedescendant-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveControllerHost } from 'lit';\n\nimport { type ATFocusControllerOptions, ATFocusController } from './at-focus-controller.js';\n\nimport { isServer, nothing } from 'lit';\nimport { getRandomId } from '../functions/random.js';\nimport { bound } from '../decorators/bound.js';\n\nexport interface ActivedescendantControllerOptions<\n  Item extends HTMLElement\n> extends ATFocusControllerOptions<Item> {\n  /**\n   * Returns a reference to the element which acts as the assistive technology container for\n   * the items. In the case of a combobox, this is the input element.\n   */\n  getActiveDescendantContainer(): HTMLElement | null;\n  /**\n   * Optional callback to control the assistive technology focus behavior of items.\n   * By default, ActivedescendantController will not do anything special to items when they receive\n   * assistive technology focus, and will only set the `activedescendant` property on the container.\n   * If you provide this callback, ActivedescendantController will call it on your item with the\n   * active state. You may use this to set active styles.\n   */\n  setItemActive?(item: Item, active: boolean): void;\n  /**\n   * Optional callback to retrieve the value from an option element.\n   * By default, retrieves the `value` attribute, or the text content.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement\n   */\n  getItemValue?(item: Item): string;\n}\n\n/**\n * Implements activedescendant pattern, as described in WAI-ARIA practices,\n * [Managing Focus in Composites Using aria-activedescendant][ad]\n *\n * The steps for using the aria-activedescendant method of managing focus are as follows.\n *\n *  - When the container element that has a role that supports aria-activedescendant is loaded\n *    or created, ensure that:\n *    - The container element is included in the tab sequence as described in\n *      Keyboard Navigation Between Components or is a focusable element of a composite\n *      that implements a roving tabindex.\n *    - It has aria-activedescendant=\"IDREF\" where IDREF is the ID of the element within\n *      the container that should be identified as active when the widget receives focus.\n *      The referenced element needs to meet the DOM relationship requirements described below.\n *  - When the container element receives DOM focus, draw a visual focus indicator on the active\n *    element and ensure the active element is scrolled into view.\n *  - When the composite widget contains focus and the user presses a navigation key that moves\n *    focus within the widget, such as an arrow key:\n *    - Change the value of aria-activedescendant on the container to refer to the element\n *      that should be reported to assistive technologies as active.\n *    - Move the visual focus indicator and, if necessary, scrolled the active element into view.\n *  - If the design calls for a specific element to be focused the next time a user moves focus\n *    into the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to\n *    that target element when the container loses focus. If it is not, set aria-activedescendant\n *    to refer to the target element.\n *\n * The specification for aria-activedescendant places important restrictions on the\n * DOM relationship between the focused element that has the aria-activedescendant attribute\n * and the element referenced as active by the value of the attribute.\n * One of the following three conditions must be met.\n *\n * 1. The element referenced as active is a DOM descendant of the focused referencing element.\n * 2. The focused referencing element has a value specified for the aria-owns property that\n *    includes the ID of the element referenced as active.\n * 3. The focused referencing element has role of combobox, textbox, or searchbox\n *    and has aria-controls property referring to an element with a role that supports\n *    aria-activedescendant and either:\n *   1. The element referenced as active is a descendant of the controlled element.\n *   2. The controlled element has a value specified for the aria-owns property that includes\n *      the ID of the element referenced as active.\n *\n * [ad]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant\n */\nexport class ActivedescendantController<\n  Item extends HTMLElement = HTMLElement\n> extends ATFocusController<Item> {\n  /**\n   * When true, the browser supports cross-root ARIA such that the controller does not need\n   * to copy item nodes into the controlling nodes' root\n   */\n  public static get supportsCrossRootActiveDescendant(): boolean {\n    return !isServer && 'ariaActiveDescendantElement' in HTMLElement.prototype;\n  }\n\n  static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: ActivedescendantControllerOptions<Item>,\n  ): ActivedescendantController<Item> {\n    return new ActivedescendantController(host, options);\n  }\n\n  /** Maps from original element to shadow DOM clone */\n  #lightToShadowMap = new WeakMap<Item, Item>();\n\n  /** Maps from shadow DOM clone to original element */\n  #shadowToLightMap = new WeakMap<Item, Item>();\n\n  /** Set of item which should not be cloned */\n  #noCloneSet = new WeakSet<Item>();\n\n  /** Element which controls the list i.e. combobox */\n  #controlsElements: HTMLElement[] = [];\n\n  #observing = false;\n\n  #listMO = new MutationObserver(records => this.#onItemsDOMChange(records));\n\n  #attrMO = new MutationObserver(records => this.#onItemAttributeChange(records));\n\n  #syncAttr(attributeName: string, fromNode: Item) {\n    const toNode = this.#shadowToLightMap.get(fromNode as Item)\n                ?? this.#lightToShadowMap.get(fromNode as Item);\n    const newVal = fromNode.getAttribute(attributeName);\n    const oldVal = toNode?.getAttribute(attributeName);\n    if (!fromNode.hasAttribute(attributeName)) {\n      toNode?.removeAttribute(attributeName);\n    } else if (oldVal !== newVal) {\n      toNode?.setAttribute(attributeName, newVal!);\n    }\n  }\n\n  get atFocusedItemIndex(): number {\n    return super.atFocusedItemIndex;\n  }\n\n  /**\n   * Rather than setting DOM focus, applies the `aria-activedescendant` attribute,\n   * using AriaIDLAttributes for cross-root aria, if supported by the browser\n   * @param item item\n   */\n  set atFocusedItemIndex(index: number) {\n    super.atFocusedItemIndex = index;\n    const item = this._items.at(this.atFocusedItemIndex);\n    for (const _item of this.items) {\n      this.options.setItemActive?.(_item, _item === item);\n    }\n    const container = this.options.getActiveDescendantContainer();\n    if (!ActivedescendantController.supportsCrossRootActiveDescendant) {\n      container?.setAttribute('aria-activedescendant', item?.id ?? '');\n    } else if (container) {\n      container.ariaActiveDescendantElement = item ?? null;\n    }\n    this.host.requestUpdate();\n  }\n\n  protected get controlsElements(): HTMLElement[] {\n    return this.#controlsElements;\n  }\n\n  protected set controlsElements(elements: HTMLElement[]) {\n    for (const old of this.#controlsElements) {\n      old?.removeEventListener('keydown', this.onKeydown);\n    }\n    this.#controlsElements = elements;\n    for (const element of this.#controlsElements) {\n      element.addEventListener('keydown', this.onKeydown);\n    }\n  }\n\n  /** All items */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * Sets the list of items and activates the next activatable item after the current one\n   * @param items tabindex items\n   */\n  override set items(items: Item[]) {\n    const container = this.options.getItemsContainer?.() ?? this.host;\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('items container must be an HTMLElement');\n    }\n    this.itemsContainerElement = container;\n    const { supportsCrossRootActiveDescendant } = ActivedescendantController;\n    if (supportsCrossRootActiveDescendant\n        || [container] // all nodes are in the same root\n            .concat(this.controlsElements)\n            .concat(items)\n            .every((node, _, a) => node.getRootNode() === a[0].getRootNode())) {\n      this._items = items.map(x => {\n        if (!supportsCrossRootActiveDescendant) {\n          x.id ||= getRandomId();\n        }\n        return x;\n      });\n    } else {\n      this._items = items?.map((item: Item) => {\n        item.removeAttribute('tabindex');\n        if (container.contains(item)) {\n          item.id ||= getRandomId();\n          this.#noCloneSet.add(item);\n          this.#shadowToLightMap.set(item, item);\n          return item;\n        } else {\n          const clone = item.cloneNode(true) as Item;\n          clone.id = getRandomId();\n          this.#lightToShadowMap.set(item, clone);\n          this.#shadowToLightMap.set(clone, item);\n          // Though efforts were taken to disconnect\n          // this observer, it may still be a memory leak\n          this.#attrMO.observe(clone, { attributes: true });\n          this.#attrMO.observe(item, { attributes: true });\n          return clone;\n        }\n      });\n    }\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    protected options: ActivedescendantControllerOptions<Item>,\n  ) {\n    super(host, options);\n    this.options.getItemValue ??= function(this: Item) {\n      return (this as unknown as HTMLOptionElement).value;\n    };\n  }\n\n  #onItemsDOMChange(records: MutationRecord[]) {\n    for (const { removedNodes } of records) {\n      for (const removed of removedNodes as NodeListOf<Item>) {\n        this.#lightToShadowMap.get(removed)?.remove();\n        this.#lightToShadowMap.delete(removed);\n      }\n    }\n  };\n\n  #onItemAttributeChange(records: MutationRecord[]) {\n    for (const { target, attributeName } of records) {\n      if (attributeName) {\n        this.#syncAttr(attributeName, target as Item);\n      }\n    }\n  };\n\n  protected override initItems(): void {\n    this.#attrMO.disconnect();\n    super.initItems();\n    this.controlsElements = this.options.getControlsElements?.() ?? [];\n    if (!this.#observing && this.itemsContainerElement && this.itemsContainerElement.isConnected) {\n      this.#listMO.observe(this.itemsContainerElement, { childList: true });\n      this.#observing = true;\n    }\n  }\n\n  hostDisconnected(): void {\n    this.controlsElements = [];\n    this.#observing = false;\n    this.#listMO.disconnect();\n    this.#attrMO.disconnect();\n  }\n\n  @bound\n  protected override onKeydown(event: KeyboardEvent): void {\n    if (!event.ctrlKey\n        && !event.altKey\n        && !event.metaKey\n        && !!this.atFocusableItems.length) {\n      super.onKeydown(event);\n    };\n  }\n\n  public renderItemsToShadowRoot(): typeof nothing | Node[] {\n    if (ActivedescendantController.supportsCrossRootActiveDescendant) {\n      return nothing;\n    } else {\n      return this.items?.filter(x => !this.#noCloneSet.has(x));\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"activedescendant-controller.js","sourceRoot":"","sources":["activedescendant-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveControllerHost } from 'lit';\n\nimport { type ATFocusControllerOptions, ATFocusController } from './at-focus-controller.js';\n\nimport { isServer, nothing } from 'lit';\nimport { getRandomId } from '../functions/random.js';\nimport { bound } from '../decorators/bound.js';\n\nexport interface ActivedescendantControllerOptions<\n  Item extends HTMLElement\n> extends ATFocusControllerOptions<Item> {\n  /**\n   * Returns a reference to the element which acts as the assistive technology container for\n   * the items. In the case of a combobox, this is the input element.\n   */\n  getActiveDescendantContainer(): HTMLElement | null;\n  /**\n   * Optional callback to control the assistive technology focus behavior of items.\n   * By default, ActivedescendantController will not do anything special to items when they receive\n   * assistive technology focus, and will only set the `activedescendant` property on the container.\n   * If you provide this callback, ActivedescendantController will call it on your item with the\n   * active state. You may use this to set active styles.\n   */\n  setItemActive?(item: Item, active: boolean): void;\n  /**\n   * Optional callback to retrieve the value from an option element.\n   * By default, retrieves the `value` attribute, or the text content.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement\n   */\n  getItemValue?(item: Item): string;\n}\n\n/**\n * Implements activedescendant pattern, as described in WAI-ARIA practices,\n * [Managing Focus in Composites Using aria-activedescendant][ad]\n *\n * The steps for using the aria-activedescendant method of managing focus are as follows.\n *\n *  - When the container element that has a role that supports aria-activedescendant is loaded\n *    or created, ensure that:\n *    - The container element is included in the tab sequence as described in\n *      Keyboard Navigation Between Components or is a focusable element of a composite\n *      that implements a roving tabindex.\n *    - It has aria-activedescendant=\"IDREF\" where IDREF is the ID of the element within\n *      the container that should be identified as active when the widget receives focus.\n *      The referenced element needs to meet the DOM relationship requirements described below.\n *  - When the container element receives DOM focus, draw a visual focus indicator on the active\n *    element and ensure the active element is scrolled into view.\n *  - When the composite widget contains focus and the user presses a navigation key that moves\n *    focus within the widget, such as an arrow key:\n *    - Change the value of aria-activedescendant on the container to refer to the element\n *      that should be reported to assistive technologies as active.\n *    - Move the visual focus indicator and, if necessary, scrolled the active element into view.\n *  - If the design calls for a specific element to be focused the next time a user moves focus\n *    into the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to\n *    that target element when the container loses focus. If it is not, set aria-activedescendant\n *    to refer to the target element.\n *\n * The specification for aria-activedescendant places important restrictions on the\n * DOM relationship between the focused element that has the aria-activedescendant attribute\n * and the element referenced as active by the value of the attribute.\n * One of the following three conditions must be met.\n *\n * 1. The element referenced as active is a DOM descendant of the focused referencing element.\n * 2. The focused referencing element has a value specified for the aria-owns property that\n *    includes the ID of the element referenced as active.\n * 3. The focused referencing element has role of combobox, textbox, or searchbox\n *    and has aria-controls property referring to an element with a role that supports\n *    aria-activedescendant and either:\n *   1. The element referenced as active is a descendant of the controlled element.\n *   2. The controlled element has a value specified for the aria-owns property that includes\n *      the ID of the element referenced as active.\n *\n * [ad]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant\n */\nexport class ActivedescendantController<\n  Item extends HTMLElement = HTMLElement\n> extends ATFocusController<Item> {\n  /**\n   * When true, the browser supports cross-root ARIA such that the controller does not need\n   * to copy item nodes into the controlling nodes' root\n   */\n  public static get supportsCrossRootActiveDescendant(): boolean {\n    return !isServer && 'ariaActiveDescendantElement' in HTMLElement.prototype;\n  }\n\n  static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: ActivedescendantControllerOptions<Item>,\n  ): ActivedescendantController<Item> {\n    return new ActivedescendantController(host, options);\n  }\n\n  /** Maps from original element to shadow DOM clone */\n  #lightToShadowMap = new WeakMap<Item, Item>();\n\n  /** Maps from shadow DOM clone to original element */\n  #shadowToLightMap = new WeakMap<Item, Item>();\n\n  /** Set of item which should not be cloned */\n  #noCloneSet = new WeakSet<Item>();\n\n  /** Element which controls the list i.e. combobox */\n  #controlsElements: HTMLElement[] = [];\n\n  #observing = false;\n\n  #listMO = new MutationObserver(records => this.#onItemsDOMChange(records));\n\n  #attrMO = new MutationObserver(records => this.#onItemAttributeChange(records));\n\n  #syncAttr(attributeName: string, fromNode: Item) {\n    const toNode = this.#shadowToLightMap.get(fromNode as Item)\n                ?? this.#lightToShadowMap.get(fromNode as Item);\n    const newVal = fromNode.getAttribute(attributeName);\n    const oldVal = toNode?.getAttribute(attributeName);\n    if (!fromNode.hasAttribute(attributeName)) {\n      toNode?.removeAttribute(attributeName);\n    } else if (oldVal !== newVal) {\n      toNode?.setAttribute(attributeName, newVal!);\n    }\n  }\n\n  get atFocusedItemIndex(): number {\n    return super.atFocusedItemIndex;\n  }\n\n  /**\n   * Rather than setting DOM focus, applies the `aria-activedescendant` attribute,\n   * using AriaIDLAttributes for cross-root aria, if supported by the browser\n   * @param item item\n   */\n  set atFocusedItemIndex(index: number) {\n    super.atFocusedItemIndex = index;\n    const item = this._items.at(this.atFocusedItemIndex);\n    for (const _item of this.items) {\n      const isActive = _item === item;\n      // Map clone back to original item for setItemActive callback\n      const originalItem = this.#shadowToLightMap.get(_item) ?? _item;\n      this.options.setItemActive?.(originalItem, isActive);\n    }\n    const container = this.options.getActiveDescendantContainer();\n    if (!ActivedescendantController.supportsCrossRootActiveDescendant) {\n      container?.setAttribute('aria-activedescendant', item?.id ?? '');\n    } else if (container) {\n      container.ariaActiveDescendantElement = item ?? null;\n    }\n    this.host.requestUpdate();\n  }\n\n  protected get controlsElements(): HTMLElement[] {\n    return this.#controlsElements;\n  }\n\n  protected set controlsElements(elements: HTMLElement[]) {\n    // Avoid removing/re-adding listeners if elements haven't changed\n    // This prevents breaking event listeners during active event dispatch\n    if (elements.length === this.#controlsElements.length\n        && elements.every((el, i) => el === this.#controlsElements[i])) {\n      return;\n    }\n    for (const old of this.#controlsElements) {\n      old?.removeEventListener('keydown', this.onKeydown);\n    }\n    this.#controlsElements = elements;\n    for (const element of this.#controlsElements) {\n      element.addEventListener('keydown', this.onKeydown);\n    }\n  }\n\n  /**\n   * Check the source item's focusable state, not the clone's.\n   * This is needed because filtering sets `hidden` on the light DOM item,\n   * and the MutationObserver sync to clones is asynchronous.\n   */\n  override get atFocusableItems(): Item[] {\n    return this._items.filter(item => {\n      // Map clone to source item to check actual hidden state\n      const sourceItem = this.#shadowToLightMap.get(item) ?? item;\n      return !!sourceItem\n          && sourceItem.ariaHidden !== 'true'\n          && !sourceItem.hasAttribute('inert')\n          && !sourceItem.hasAttribute('hidden');\n    });\n  }\n\n  /** All items */\n  get items() {\n    return this._items;\n  }\n\n  /**\n   * Sets the list of items and activates the next activatable item after the current one\n   * @param items tabindex items\n   */\n  override set items(items: Item[]) {\n    const container = this.options.getItemsContainer?.() ?? this.host;\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('items container must be an HTMLElement');\n    }\n    this.itemsContainerElement = container;\n    const { supportsCrossRootActiveDescendant } = ActivedescendantController;\n    if (supportsCrossRootActiveDescendant\n        || [container] // all nodes are in the same root\n            .concat(this.controlsElements)\n            .concat(items)\n            .every((node, _, a) => node.getRootNode() === a[0].getRootNode())) {\n      this._items = items.map(x => {\n        if (!supportsCrossRootActiveDescendant) {\n          x.id ||= getRandomId();\n        }\n        return x;\n      });\n    } else {\n      this._items = items?.map((item: Item) => {\n        item.removeAttribute('tabindex');\n        if (container.contains(item)) {\n          item.id ||= getRandomId();\n          this.#noCloneSet.add(item);\n          this.#shadowToLightMap.set(item, item);\n          return item;\n        } else {\n          // Reuse existing clone if available to maintain stable IDs\n          const existingClone = this.#lightToShadowMap.get(item);\n          if (existingClone) {\n            return existingClone;\n          }\n          const clone = item.cloneNode(true) as Item;\n          clone.id = getRandomId();\n          this.#lightToShadowMap.set(item, clone);\n          this.#shadowToLightMap.set(clone, item);\n          // Though efforts were taken to disconnect\n          // this observer, it may still be a memory leak\n          this.#attrMO.observe(clone, { attributes: true });\n          this.#attrMO.observe(item, { attributes: true });\n          return clone;\n        }\n      });\n    }\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    protected options: ActivedescendantControllerOptions<Item>,\n  ) {\n    super(host, options);\n    this.initItems();\n    this.options.getItemValue ??= function(this: Item) {\n      return (this as unknown as HTMLOptionElement).value;\n    };\n  }\n\n  #onItemsDOMChange(records: MutationRecord[]) {\n    for (const { removedNodes } of records) {\n      for (const removed of removedNodes as NodeListOf<Item>) {\n        this.#lightToShadowMap.get(removed)?.remove();\n        this.#lightToShadowMap.delete(removed);\n      }\n    }\n  };\n\n  #onItemAttributeChange(records: MutationRecord[]) {\n    for (const { target, attributeName } of records) {\n      if (attributeName) {\n        this.#syncAttr(attributeName, target as Item);\n      }\n    }\n  };\n\n  /** @internal */\n  override initItems(): void {\n    this.#attrMO.disconnect();\n    super.initItems();\n    this.controlsElements = this.options.getControlsElements?.() ?? [];\n    if (!this.#observing && this.itemsContainerElement && this.itemsContainerElement.isConnected) {\n      this.#listMO.observe(this.itemsContainerElement, { childList: true });\n      this.#observing = true;\n    }\n  }\n\n  hostDisconnected(): void {\n    this.controlsElements = [];\n    this.#observing = false;\n    this.#listMO.disconnect();\n    this.#attrMO.disconnect();\n  }\n\n  @bound\n  protected override onKeydown(event: KeyboardEvent): void {\n    if (!event.ctrlKey\n        && !event.altKey\n        && !event.metaKey\n        && !!this.atFocusableItems.length) {\n      super.onKeydown(event);\n    };\n  }\n\n  public renderItemsToShadowRoot(): typeof nothing | Node[] {\n    if (ActivedescendantController.supportsCrossRootActiveDescendant) {\n      return nothing;\n    } else {\n      return this.items?.filter(x => !this.#noCloneSet.has(x));\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.ts b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.ts
new file mode 100644
index 0000000..12bb488
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/activedescendant-controller.ts
@@ -0,0 +1,305 @@
+import type { ReactiveControllerHost } from 'lit';
+
+import { type ATFocusControllerOptions, ATFocusController } from './at-focus-controller.js';
+
+import { isServer, nothing } from 'lit';
+import { getRandomId } from '../functions/random.js';
+import { bound } from '../decorators/bound.js';
+
+export interface ActivedescendantControllerOptions<
+  Item extends HTMLElement
+> extends ATFocusControllerOptions<Item> {
+  /**
+   * Returns a reference to the element which acts as the assistive technology container for
+   * the items. In the case of a combobox, this is the input element.
+   */
+  getActiveDescendantContainer(): HTMLElement | null;
+  /**
+   * Optional callback to control the assistive technology focus behavior of items.
+   * By default, ActivedescendantController will not do anything special to items when they receive
+   * assistive technology focus, and will only set the `activedescendant` property on the container.
+   * If you provide this callback, ActivedescendantController will call it on your item with the
+   * active state. You may use this to set active styles.
+   */
+  setItemActive?(item: Item, active: boolean): void;
+  /**
+   * Optional callback to retrieve the value from an option element.
+   * By default, retrieves the `value` attribute, or the text content.
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement
+   */
+  getItemValue?(item: Item): string;
+}
+
+/**
+ * Implements activedescendant pattern, as described in WAI-ARIA practices,
+ * [Managing Focus in Composites Using aria-activedescendant][ad]
+ *
+ * The steps for using the aria-activedescendant method of managing focus are as follows.
+ *
+ *  - When the container element that has a role that supports aria-activedescendant is loaded
+ *    or created, ensure that:
+ *    - The container element is included in the tab sequence as described in
+ *      Keyboard Navigation Between Components or is a focusable element of a composite
+ *      that implements a roving tabindex.
+ *    - It has aria-activedescendant="IDREF" where IDREF is the ID of the element within
+ *      the container that should be identified as active when the widget receives focus.
+ *      The referenced element needs to meet the DOM relationship requirements described below.
+ *  - When the container element receives DOM focus, draw a visual focus indicator on the active
+ *    element and ensure the active element is scrolled into view.
+ *  - When the composite widget contains focus and the user presses a navigation key that moves
+ *    focus within the widget, such as an arrow key:
+ *    - Change the value of aria-activedescendant on the container to refer to the element
+ *      that should be reported to assistive technologies as active.
+ *    - Move the visual focus indicator and, if necessary, scrolled the active element into view.
+ *  - If the design calls for a specific element to be focused the next time a user moves focus
+ *    into the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to
+ *    that target element when the container loses focus. If it is not, set aria-activedescendant
+ *    to refer to the target element.
+ *
+ * The specification for aria-activedescendant places important restrictions on the
+ * DOM relationship between the focused element that has the aria-activedescendant attribute
+ * and the element referenced as active by the value of the attribute.
+ * One of the following three conditions must be met.
+ *
+ * 1. The element referenced as active is a DOM descendant of the focused referencing element.
+ * 2. The focused referencing element has a value specified for the aria-owns property that
+ *    includes the ID of the element referenced as active.
+ * 3. The focused referencing element has role of combobox, textbox, or searchbox
+ *    and has aria-controls property referring to an element with a role that supports
+ *    aria-activedescendant and either:
+ *   1. The element referenced as active is a descendant of the controlled element.
+ *   2. The controlled element has a value specified for the aria-owns property that includes
+ *      the ID of the element referenced as active.
+ *
+ * [ad]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant
+ */
+export class ActivedescendantController<
+  Item extends HTMLElement = HTMLElement
+> extends ATFocusController<Item> {
+  /**
+   * When true, the browser supports cross-root ARIA such that the controller does not need
+   * to copy item nodes into the controlling nodes' root
+   */
+  public static get supportsCrossRootActiveDescendant(): boolean {
+    return !isServer && 'ariaActiveDescendantElement' in HTMLElement.prototype;
+  }
+
+  static of<Item extends HTMLElement>(
+    host: ReactiveControllerHost,
+    options: ActivedescendantControllerOptions<Item>,
+  ): ActivedescendantController<Item> {
+    return new ActivedescendantController(host, options);
+  }
+
+  /** Maps from original element to shadow DOM clone */
+  #lightToShadowMap = new WeakMap<Item, Item>();
+
+  /** Maps from shadow DOM clone to original element */
+  #shadowToLightMap = new WeakMap<Item, Item>();
+
+  /** Set of item which should not be cloned */
+  #noCloneSet = new WeakSet<Item>();
+
+  /** Element which controls the list i.e. combobox */
+  #controlsElements: HTMLElement[] = [];
+
+  #observing = false;
+
+  #listMO = new MutationObserver(records => this.#onItemsDOMChange(records));
+
+  #attrMO = new MutationObserver(records => this.#onItemAttributeChange(records));
+
+  #syncAttr(attributeName: string, fromNode: Item) {
+    const toNode = this.#shadowToLightMap.get(fromNode as Item)
+                ?? this.#lightToShadowMap.get(fromNode as Item);
+    const newVal = fromNode.getAttribute(attributeName);
+    const oldVal = toNode?.getAttribute(attributeName);
+    if (!fromNode.hasAttribute(attributeName)) {
+      toNode?.removeAttribute(attributeName);
+    } else if (oldVal !== newVal) {
+      toNode?.setAttribute(attributeName, newVal!);
+    }
+  }
+
+  get atFocusedItemIndex(): number {
+    return super.atFocusedItemIndex;
+  }
+
+  /**
+   * Rather than setting DOM focus, applies the `aria-activedescendant` attribute,
+   * using AriaIDLAttributes for cross-root aria, if supported by the browser
+   * @param item item
+   */
+  set atFocusedItemIndex(index: number) {
+    super.atFocusedItemIndex = index;
+    const item = this._items.at(this.atFocusedItemIndex);
+    for (const _item of this.items) {
+      const isActive = _item === item;
+      // Map clone back to original item for setItemActive callback
+      const originalItem = this.#shadowToLightMap.get(_item) ?? _item;
+      this.options.setItemActive?.(originalItem, isActive);
+    }
+    const container = this.options.getActiveDescendantContainer();
+    if (!ActivedescendantController.supportsCrossRootActiveDescendant) {
+      container?.setAttribute('aria-activedescendant', item?.id ?? '');
+    } else if (container) {
+      container.ariaActiveDescendantElement = item ?? null;
+    }
+    this.host.requestUpdate();
+  }
+
+  protected get controlsElements(): HTMLElement[] {
+    return this.#controlsElements;
+  }
+
+  protected set controlsElements(elements: HTMLElement[]) {
+    // Avoid removing/re-adding listeners if elements haven't changed
+    // This prevents breaking event listeners during active event dispatch
+    if (elements.length === this.#controlsElements.length
+        && elements.every((el, i) => el === this.#controlsElements[i])) {
+      return;
+    }
+    for (const old of this.#controlsElements) {
+      old?.removeEventListener('keydown', this.onKeydown);
+    }
+    this.#controlsElements = elements;
+    for (const element of this.#controlsElements) {
+      element.addEventListener('keydown', this.onKeydown);
+    }
+  }
+
+  /**
+   * Check the source item's focusable state, not the clone's.
+   * This is needed because filtering sets `hidden` on the light DOM item,
+   * and the MutationObserver sync to clones is asynchronous.
+   */
+  override get atFocusableItems(): Item[] {
+    return this._items.filter(item => {
+      // Map clone to source item to check actual hidden state
+      const sourceItem = this.#shadowToLightMap.get(item) ?? item;
+      return !!sourceItem
+          && sourceItem.ariaHidden !== 'true'
+          && !sourceItem.hasAttribute('inert')
+          && !sourceItem.hasAttribute('hidden');
+    });
+  }
+
+  /** All items */
+  get items() {
+    return this._items;
+  }
+
+  /**
+   * Sets the list of items and activates the next activatable item after the current one
+   * @param items tabindex items
+   */
+  override set items(items: Item[]) {
+    const container = this.options.getItemsContainer?.() ?? this.host;
+    if (!(container instanceof HTMLElement)) {
+      throw new Error('items container must be an HTMLElement');
+    }
+    this.itemsContainerElement = container;
+    const { supportsCrossRootActiveDescendant } = ActivedescendantController;
+    if (supportsCrossRootActiveDescendant
+        || [container] // all nodes are in the same root
+            .concat(this.controlsElements)
+            .concat(items)
+            .every((node, _, a) => node.getRootNode() === a[0].getRootNode())) {
+      this._items = items.map(x => {
+        if (!supportsCrossRootActiveDescendant) {
+          x.id ||= getRandomId();
+        }
+        return x;
+      });
+    } else {
+      this._items = items?.map((item: Item) => {
+        item.removeAttribute('tabindex');
+        if (container.contains(item)) {
+          item.id ||= getRandomId();
+          this.#noCloneSet.add(item);
+          this.#shadowToLightMap.set(item, item);
+          return item;
+        } else {
+          // Reuse existing clone if available to maintain stable IDs
+          const existingClone = this.#lightToShadowMap.get(item);
+          if (existingClone) {
+            return existingClone;
+          }
+          const clone = item.cloneNode(true) as Item;
+          clone.id = getRandomId();
+          this.#lightToShadowMap.set(item, clone);
+          this.#shadowToLightMap.set(clone, item);
+          // Though efforts were taken to disconnect
+          // this observer, it may still be a memory leak
+          this.#attrMO.observe(clone, { attributes: true });
+          this.#attrMO.observe(item, { attributes: true });
+          return clone;
+        }
+      });
+    }
+  }
+
+  private constructor(
+    public host: ReactiveControllerHost,
+    protected options: ActivedescendantControllerOptions<Item>,
+  ) {
+    super(host, options);
+    this.initItems();
+    this.options.getItemValue ??= function(this: Item) {
+      return (this as unknown as HTMLOptionElement).value;
+    };
+  }
+
+  #onItemsDOMChange(records: MutationRecord[]) {
+    for (const { removedNodes } of records) {
+      for (const removed of removedNodes as NodeListOf<Item>) {
+        this.#lightToShadowMap.get(removed)?.remove();
+        this.#lightToShadowMap.delete(removed);
+      }
+    }
+  };
+
+  #onItemAttributeChange(records: MutationRecord[]) {
+    for (const { target, attributeName } of records) {
+      if (attributeName) {
+        this.#syncAttr(attributeName, target as Item);
+      }
+    }
+  };
+
+  /** @internal */
+  override initItems(): void {
+    this.#attrMO.disconnect();
+    super.initItems();
+    this.controlsElements = this.options.getControlsElements?.() ?? [];
+    if (!this.#observing && this.itemsContainerElement && this.itemsContainerElement.isConnected) {
+      this.#listMO.observe(this.itemsContainerElement, { childList: true });
+      this.#observing = true;
+    }
+  }
+
+  hostDisconnected(): void {
+    this.controlsElements = [];
+    this.#observing = false;
+    this.#listMO.disconnect();
+    this.#attrMO.disconnect();
+  }
+
+  @bound
+  protected override onKeydown(event: KeyboardEvent): void {
+    if (!event.ctrlKey
+        && !event.altKey
+        && !event.metaKey
+        && !!this.atFocusableItems.length) {
+      super.onKeydown(event);
+    };
+  }
+
+  public renderItemsToShadowRoot(): typeof nothing | Node[] {
+    if (ActivedescendantController.supportsCrossRootActiveDescendant) {
+      return nothing;
+    } else {
+      return this.items?.filter(x => !this.#noCloneSet.has(x));
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.d.ts
index 38e83a4..ddb6f9f 100644
--- a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.d.ts
@@ -31,7 +31,7 @@ export declare abstract class ATFocusController<Item extends HTMLElement> {
      * wrap around to the other side of the list.
      */
     get atFocusedItemIndex(): number;
-    set atFocusedItemIndex(index: number);
+    set atFocusedItemIndex(requestedIndex: number);
     /** Elements which control the items container e.g. a combobox input */
     protected get controlsElements(): HTMLElement[];
     /** All items which are able to receive assistive technology focus */
@@ -41,9 +41,12 @@ export declare abstract class ATFocusController<Item extends HTMLElement> {
     set itemsContainerElement(container: HTMLElement | null);
     constructor(host: ReactiveControllerHost, options: ATFocusControllerOptions<Item>);
     /**
-     * Initialize the items and itemsContainerElement fields
+     * Initialize the items and itemsContainerElement fields.
+     * Call this when the list of items has changed
+     * (e.g. when a parent controller sets items).
+     * @internal not for use by element authors
      */
-    protected initItems(): void;
+    initItems(): void;
     hostConnected(): void;
     hostDisconnected(): void;
     hostUpdate(): void;
diff --git a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
index ba9af2b..2cde134 100644
--- a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js
@@ -1,4 +1,4 @@
-var _ATFocusController_instances, _ATFocusController_itemsContainerElement, _ATFocusController_atFocusedItemIndex, _ATFocusController_initContainer;
+var _ATFocusController_instances, _ATFocusController_itemsContainerElement, _ATFocusController_atFocusedItemIndex, _ATFocusController_initContainer, _ATFocusController_getNextFocusableItem;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
 import { isServer } from 'lit';
 import { bound } from '../decorators/bound.js';
@@ -17,33 +17,41 @@ export class ATFocusController {
     get atFocusedItemIndex() {
         return __classPrivateFieldGet(this, _ATFocusController_atFocusedItemIndex, "f");
     }
-    set atFocusedItemIndex(index) {
-        const previousIndex = __classPrivateFieldGet(this, _ATFocusController_atFocusedItemIndex, "f");
-        const direction = index > previousIndex ? 1 : -1;
+    set atFocusedItemIndex(requestedIndex) {
         const { items, atFocusableItems } = this;
-        const itemsIndexOfLastATFocusableItem = items.indexOf(this.atFocusableItems.at(-1));
-        let itemToGainFocus = items.at(index);
-        let itemToGainFocusIsFocusable = atFocusableItems.includes(itemToGainFocus);
-        if (atFocusableItems.length) {
-            let count = 0;
-            while (!itemToGainFocus || !itemToGainFocusIsFocusable && count++ <= 1000) {
-                if (index < 0) {
-                    index = itemsIndexOfLastATFocusableItem;
-                }
-                else if (index >= itemsIndexOfLastATFocusableItem) {
-                    index = 0;
-                }
-                else {
-                    index = index + direction;
-                }
-                itemToGainFocus = items.at(index);
-                itemToGainFocusIsFocusable = atFocusableItems.includes(itemToGainFocus);
-            }
-            if (count >= 1000) {
-                throw new Error('Could not atFocusedItemIndex');
-            }
+        if (!atFocusableItems.length) {
+            __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, requestedIndex, "f");
+            return;
+        }
+        // Fast path: requested item is already focusable
+        if (requestedIndex >= 0
+            && requestedIndex < items.length
+            && atFocusableItems.includes(items[requestedIndex])) {
+            __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, requestedIndex, "f");
+            return;
+        }
+        const lastFocusableIndex = items.indexOf(atFocusableItems.at(-1));
+        // Navigated before start  wrap to last focusable
+        if (requestedIndex < 0) {
+            __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, lastFocusableIndex, "f");
+            return;
         }
-        __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, index, "f");
+        const firstFocusableIndex = items.indexOf(atFocusableItems[0]);
+        // Navigated past end or past last focusable  wrap to first focusable
+        if (requestedIndex >= items.length
+            || requestedIndex > lastFocusableIndex) {
+            __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, firstFocusableIndex, "f");
+            return;
+        }
+        // Before first focusable (e.g. disabled placeholder at index 0).
+        // ArrowUp from first focusable  wrap to last; otherwise snap to first.
+        if (requestedIndex < firstFocusableIndex) {
+            __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, __classPrivateFieldGet(this, _ATFocusController_atFocusedItemIndex, "f") === firstFocusableIndex ? lastFocusableIndex
+                : firstFocusableIndex, "f");
+            return;
+        }
+        // Mid-list non-focusable item: find nearest focusable in the navigation direction
+        __classPrivateFieldSet(this, _ATFocusController_atFocusedItemIndex, items.indexOf(__classPrivateFieldGet(this, _ATFocusController_instances, "m", _ATFocusController_getNextFocusableItem).call(this, requestedIndex)), "f");
     }
     /** Elements which control the items container e.g. a combobox input */
     get controlsElements() {
@@ -75,7 +83,10 @@ export class ATFocusController {
         this.host.updateComplete.then(() => this.initItems());
     }
     /**
-     * Initialize the items and itemsContainerElement fields
+     * Initialize the items and itemsContainerElement fields.
+     * Call this when the list of items has changed
+     * (e.g. when a parent controller sets items).
+     * @internal not for use by element authors
      */
     initItems() {
         this.items = this.options.getItems();
@@ -136,24 +147,30 @@ export class ATFocusController {
                 event.stopPropagation();
                 event.preventDefault();
                 break;
-            case 'Home':
+            case 'Home': {
                 if (!(event.target instanceof HTMLElement
                     && (event.target.hasAttribute('aria-activedescendant')
                         || event.target.ariaActiveDescendantElement))) {
-                    this.atFocusedItemIndex = 0;
+                    // Use first focusable index so the setter doesn't see 0 (reserved for Up-from-first wrap).
+                    const first = this.atFocusableItems.at(0);
+                    this.atFocusedItemIndex = first != null ? this.items.indexOf(first) : 0;
                     event.stopPropagation();
                     event.preventDefault();
                 }
                 break;
-            case 'End':
+            }
+            case 'End': {
                 if (!(event.target instanceof HTMLElement
                     && (event.target.hasAttribute('aria-activedescendant')
                         || event.target.ariaActiveDescendantElement))) {
-                    this.atFocusedItemIndex = this.items.length - 1;
+                    // Use last focusable index for consistency with lists that have non-focusable items.
+                    const last = this.atFocusableItems.at(-1);
+                    this.atFocusedItemIndex = last != null ? this.items.indexOf(last) : this.items.length - 1;
                     event.stopPropagation();
                     event.preventDefault();
                 }
                 break;
+            }
             default:
                 break;
         }
@@ -164,5 +181,13 @@ export class ATFocusController {
 _ATFocusController_itemsContainerElement = new WeakMap(), _ATFocusController_atFocusedItemIndex = new WeakMap(), _ATFocusController_instances = new WeakSet(), _ATFocusController_initContainer = function _ATFocusController_initContainer() {
     return this.options.getItemsContainer?.()
         ?? (!isServer && this.host instanceof HTMLElement ? this.host : null);
+}, _ATFocusController_getNextFocusableItem = function _ATFocusController_getNextFocusableItem(requestedIndex) {
+    const { items, atFocusableItems } = this;
+    if (requestedIndex > __classPrivateFieldGet(this, _ATFocusController_atFocusedItemIndex, "f")) {
+        return atFocusableItems.find(item => items.indexOf(item) > requestedIndex);
+    }
+    else {
+        return atFocusableItems.findLast(item => items.indexOf(item) < requestedIndex);
+    }
 };
 //# sourceMappingURL=at-focus-controller.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js.map
index 17b0fbf..0dba36c 100644
--- a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"at-focus-controller.js","sourceRoot":"","sources":["at-focus-controller.ts"],"names":[],"mappings":";;AAAA,OAAO,EAAE,QAAQ,EAA+B,MAAM,KAAK,CAAC;AAC5D,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAE/C,SAAS,iBAAiB,CAAC,EAAW;IACpC,OAAO,CAAC,CAAC,EAAE;WACJ,EAAE,CAAC,UAAU,KAAK,MAAM;WACxB,CAAC,EAAE,CAAC,YAAY,CAAC,OAAO,CAAC;WACzB,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;AACpC,CAAC;AAsBD,MAAM,OAAgB,iBAAiB;IAUrC;;;;OAIG;IACH,IAAI,kBAAkB;QACpB,OAAO,uBAAA,IAAI,6CAAoB,CAAC;IAClC,CAAC;IAED,IAAI,kBAAkB,CAAC,KAAa;QAClC,MAAM,aAAa,GAAG,uBAAA,IAAI,6CAAoB,CAAC;QAC/C,MAAM,SAAS,GAAG,KAAK,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACjD,MAAM,EAAE,KAAK,EAAE,gBAAgB,EAAE,GAAG,IAAI,CAAC;QACzC,MAAM,+BAA+B,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC;QACrF,IAAI,eAAe,GAAG,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,0BAA0B,GAAG,gBAAgB,CAAC,QAAQ,CAAC,eAAgB,CAAC,CAAC;QAC7E,IAAI,gBAAgB,CAAC,MAAM,EAAE,CAAC;YAC5B,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,OAAO,CAAC,eAAe,IAAI,CAAC,0BAA0B,IAAI,KAAK,EAAE,IAAI,IAAI,EAAE,CAAC;gBAC1E,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;oBACd,KAAK,GAAG,+BAA+B,CAAC;gBAC1C,CAAC;qBAAM,IAAI,KAAK,IAAI,+BAA+B,EAAE,CAAC;oBACpD,KAAK,GAAG,CAAC,CAAC;gBACZ,CAAC;qBAAM,CAAC;oBACN,KAAK,GAAG,KAAK,GAAG,SAAS,CAAC;gBAC5B,CAAC;gBACD,eAAe,GAAG,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;gBAClC,0BAA0B,GAAG,gBAAgB,CAAC,QAAQ,CAAC,eAAgB,CAAC,CAAC;YAC3E,CAAC;YACD,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;gBAClB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;YAClD,CAAC;QACH,CAAC;QACD,uBAAA,IAAI,yCAAuB,KAAK,MAAA,CAAC;IACnC,CAAC;IAED,uEAAuE;IACvE,IAAc,gBAAgB;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE,EAAE,IAAI,EAAE,CAAC;IACpD,CAAC;IAED,qEAAqE;IACrE,IAAI,gBAAgB;QAClB,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IAC/C,CAAC;IAED,6DAA6D;IAC7D,IAAI,qBAAqB;QACvB,OAAO,uBAAA,IAAI,gDAAuB,IAAI,IAAI,CAAC;IAC7C,CAAC;IAED,IAAI,qBAAqB,CAAC,SAA6B;QACrD,IAAI,SAAS,KAAK,uBAAA,IAAI,gDAAuB,EAAE,CAAC;YAC9C,uBAAA,IAAI,gDAAuB,EAAE,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5E,uBAAA,IAAI,4CAA0B,SAAS,MAAA,CAAC;YACxC,uBAAA,IAAI,gDAAuB,EAAE,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YACzE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;IAED,YACS,IAA4B,EACzB,OAAuC;;QAD1C,SAAI,GAAJ,IAAI,CAAwB;QACzB,YAAO,GAAP,OAAO,CAAgC;QAvEnD,mDAA6C,IAAI,EAAC;QAElD,gDAAsB,CAAC,CAAC,EAAC;QAEf,WAAM,GAAW,EAAE,CAAC;QAqE5B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;IACxD,CAAC;IAED;;OAEG;IACO,SAAS;QACjB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;QACrC,IAAI,CAAC,qBAAqB,KAA1B,IAAI,CAAC,qBAAqB,GAAK,uBAAA,IAAI,sEAAe,MAAnB,IAAI,CAAiB,EAAC;IACvD,CAAC;IAED,aAAa;QACX,IAAI,CAAC,UAAU,EAAE,CAAC;IACpB,CAAC;IAED,gBAAgB;QACd,uBAAA,IAAI,gDAAuB,EAAE,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;IAC9E,CAAC;IAED,UAAU;QACR,IAAI,CAAC,qBAAqB,KAA1B,IAAI,CAAC,qBAAqB,GAAK,uBAAA,IAAI,sEAAe,MAAnB,IAAI,CAAiB,EAAC;IACvD,CAAC;IAOD;;;;OAIG;IACO,SAAS,CAAC,KAAoB;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,IAAI,uBAAA,IAAI,gDAChC;YACvB,EAAE,YAAY,CAAC,kBAAkB,CACmB,CAAC;QAEzD,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAErD,MAAM,cAAc,GAChB,WAAW,KAAK,YAAY;eACzB,IAAI,EAAE,OAAO,KAAK,QAAQ;eAC1B,IAAI,EAAE,YAAY,CAAC,MAAM,CAAC,KAAK,YAAY,CAAC;QAEnD,MAAM,YAAY,GAAG,WAAW,KAAK,UAAU,CAAC;QAEhD,QAAQ,KAAK,CAAC,GAAG,EAAE,CAAC;YAClB,KAAK,WAAW;gBACd,IAAI,YAAY,EAAE,CAAC;oBACjB,OAAO;gBACT,CAAC;gBACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC1B,KAAK,CAAC,eAAe,EAAE,CAAC;gBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACvB,MAAM;YACR,KAAK,YAAY;gBACf,IAAI,YAAY,EAAE,CAAC;oBACjB,OAAO;gBACT,CAAC;gBACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC1B,KAAK,CAAC,eAAe,EAAE,CAAC;gBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACvB,MAAM;YACR,KAAK,SAAS;gBACZ,IAAI,cAAc,EAAE,CAAC;oBACnB,OAAO;gBACT,CAAC;gBACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC1B,KAAK,CAAC,eAAe,EAAE,CAAC;gBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACvB,MAAM;YACR,KAAK,WAAW;gBACd,IAAI,cAAc,EAAE,CAAC;oBACnB,OAAO;gBACT,CAAC;gBACD,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC1B,KAAK,CAAC,eAAe,EAAE,CAAC;gBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACvB,MAAM;YACR,KAAK,MAAM;gBACT,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,YAAY,WAAW;uBAClC,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,uBAAuB,CAAC;2BAClD,KAAK,CAAC,MAAM,CAAC,2BAA2B,CAAC,CAAC,EAAE,CAAC;oBACnD,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;oBAC5B,KAAK,CAAC,eAAe,EAAE,CAAC;oBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACzB,CAAC;gBACD,MAAM;YACR,KAAK,KAAK;gBACR,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,YAAY,WAAW;uBAClC,CAAC,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,uBAAuB,CAAC;2BAClD,KAAK,CAAC,MAAM,CAAC,2BAA2B,CAAC,CAAC,EAAE,CAAC;oBACnD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;oBAChD,KAAK,CAAC,eAAe,EAAE,CAAC;oBACxB,KAAK,CAAC,cAAc,EAAE,CAAC;gBACzB,CAAC;gBACD,MAAM;YACR;gBACE,MAAM;QACV,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;IAC5B,CAAC;IAAA,CAAC;CACH;;IAhFG,OAAO,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,EAAE;WACpC,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,YAAY,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AAC1E,CAAC","sourcesContent":["import { isServer, type ReactiveControllerHost } from 'lit';\nimport { bound } from '../decorators/bound.js';\n\nfunction isATFocusableItem(el: Element): el is HTMLElement {\n  return !!el\n      && el.ariaHidden !== 'true'\n      && !el.hasAttribute('inert')\n      && !el.hasAttribute('hidden');\n}\n\nexport interface ATFocusControllerOptions<Item extends HTMLElement> {\n  /**\n   * Callback to return the list of items\n   */\n  getItems(): Item[];\n  /**\n   * Callback to return the listbox container element\n   */\n  getItemsContainer?(): HTMLElement | null;\n  /**\n   * Callback to return the direction of navigation in the list box.\n   */\n  getOrientation?(): 'horizontal' | 'vertical' | 'both' | 'undefined';\n  /**\n   * Function returning the DOM nodes which are accessibility controllers of item container\n   * e.g. the button toggle and combobox input which control a listbox.\n   */\n  getControlsElements?(): HTMLElement[];\n}\n\nexport abstract class ATFocusController<Item extends HTMLElement> {\n  #itemsContainerElement: HTMLElement | null = null;\n\n  #atFocusedItemIndex = -1;\n\n  protected _items: Item[] = [];\n\n  /** All items */\n  abstract items: Item[];\n\n  /**\n   * Index of the Item which currently has assistive technology focus\n   * Set this to change focus. Setting to an out-of-bounds value will\n   * wrap around to the other side of the list.\n   */\n  get atFocusedItemIndex() {\n    return this.#atFocusedItemIndex;\n  }\n\n  set atFocusedItemIndex(index: number) {\n    const previousIndex = this.#atFocusedItemIndex;\n    const direction = index > previousIndex ? 1 : -1;\n    const { items, atFocusableItems } = this;\n    const itemsIndexOfLastATFocusableItem = items.indexOf(this.atFocusableItems.at(-1)!);\n    let itemToGainFocus = items.at(index);\n    let itemToGainFocusIsFocusable = atFocusableItems.includes(itemToGainFocus!);\n    if (atFocusableItems.length) {\n      let count = 0;\n      while (!itemToGainFocus || !itemToGainFocusIsFocusable && count++ <= 1000) {\n        if (index < 0) {\n          index = itemsIndexOfLastATFocusableItem;\n        } else if (index >= itemsIndexOfLastATFocusableItem) {\n          index = 0;\n        } else {\n          index = index + direction;\n        }\n        itemToGainFocus = items.at(index);\n        itemToGainFocusIsFocusable = atFocusableItems.includes(itemToGainFocus!);\n      }\n      if (count >= 1000) {\n        throw new Error('Could not atFocusedItemIndex');\n      }\n    }\n    this.#atFocusedItemIndex = index;\n  }\n\n  /** Elements which control the items container e.g. a combobox input */\n  protected get controlsElements(): HTMLElement[] {\n    return this.options.getControlsElements?.() ?? [];\n  }\n\n  /** All items which are able to receive assistive technology focus */\n  get atFocusableItems(): Item[] {\n    return this._items.filter(isATFocusableItem);\n  }\n\n  /** The element containing focusable items, e.g. a listbox */\n  get itemsContainerElement() {\n    return this.#itemsContainerElement ?? null;\n  }\n\n  set itemsContainerElement(container: HTMLElement | null) {\n    if (container !== this.#itemsContainerElement) {\n      this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);\n      this.#itemsContainerElement = container;\n      this.#itemsContainerElement?.addEventListener('keydown', this.onKeydown);\n      this.host.requestUpdate();\n    }\n  }\n\n  constructor(\n    public host: ReactiveControllerHost,\n    protected options: ATFocusControllerOptions<Item>,\n  ) {\n    this.host.updateComplete.then(() => this.initItems());\n  }\n\n  /**\n   * Initialize the items and itemsContainerElement fields\n   */\n  protected initItems(): void {\n    this.items = this.options.getItems();\n    this.itemsContainerElement ??= this.#initContainer();\n  }\n\n  hostConnected(): void {\n    this.hostUpdate();\n  }\n\n  hostDisconnected(): void {\n    this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);\n  }\n\n  hostUpdate(): void {\n    this.itemsContainerElement ??= this.#initContainer();\n  }\n\n  #initContainer() {\n    return this.options.getItemsContainer?.()\n      ?? (!isServer && this.host instanceof HTMLElement ? this.host : null);\n  }\n\n  /**\n   * Override and conditionally call `super.onKeydown` to filter out keyboard events\n   * which should not result in a focus change. Ensure that subclass' method is bound\n   * @param event keyboard event\n   */\n  protected onKeydown(event: KeyboardEvent): void {\n    const orientation = this.options.getOrientation?.() ?? this\n        .#itemsContainerElement\n        ?.getAttribute('aria-orientation') as\n            'horizontal' | 'vertical' | 'grid' | 'undefined';\n\n    const item = this._items.at(this.atFocusedItemIndex);\n\n    const horizontalOnly =\n        orientation === 'horizontal'\n        || item?.tagName === 'SELECT'\n        || item?.getAttribute('role') === 'spinbutton';\n\n    const verticalOnly = orientation === 'vertical';\n\n    switch (event.key) {\n      case 'ArrowLeft':\n        if (verticalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex--;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowRight':\n        if (verticalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex++;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowUp':\n        if (horizontalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex--;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowDown':\n        if (horizontalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex++;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Home':\n        if (!(event.target instanceof HTMLElement\n            && (event.target.hasAttribute('aria-activedescendant')\n             || event.target.ariaActiveDescendantElement))) {\n          this.atFocusedItemIndex = 0;\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n      case 'End':\n        if (!(event.target instanceof HTMLElement\n            && (event.target.hasAttribute('aria-activedescendant')\n             || event.target.ariaActiveDescendantElement))) {\n          this.atFocusedItemIndex = this.items.length - 1;\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n      default:\n        break;\n    }\n    this.host.requestUpdate();\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"at-focus-controller.js","sourceRoot":"","sources":["at-focus-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveControllerHost } from 'lit';\nimport { bound } from '../decorators/bound.js';\n\nfunction isATFocusableItem(el: Element): el is HTMLElement {\n  return !!el\n      && el.ariaHidden !== 'true'\n      && !el.hasAttribute('inert')\n      && !el.hasAttribute('hidden');\n}\n\nexport interface ATFocusControllerOptions<Item extends HTMLElement> {\n  /**\n   * Callback to return the list of items\n   */\n  getItems(): Item[];\n  /**\n   * Callback to return the listbox container element\n   */\n  getItemsContainer?(): HTMLElement | null;\n  /**\n   * Callback to return the direction of navigation in the list box.\n   */\n  getOrientation?(): 'horizontal' | 'vertical' | 'both' | 'undefined';\n  /**\n   * Function returning the DOM nodes which are accessibility controllers of item container\n   * e.g. the button toggle and combobox input which control a listbox.\n   */\n  getControlsElements?(): HTMLElement[];\n}\n\nexport abstract class ATFocusController<Item extends HTMLElement> {\n  #itemsContainerElement: HTMLElement | null = null;\n\n  #atFocusedItemIndex = -1;\n\n  protected _items: Item[] = [];\n\n  /** All items */\n  abstract items: Item[];\n\n  /**\n   * Index of the Item which currently has assistive technology focus\n   * Set this to change focus. Setting to an out-of-bounds value will\n   * wrap around to the other side of the list.\n   */\n  get atFocusedItemIndex() {\n    return this.#atFocusedItemIndex;\n  }\n\n  set atFocusedItemIndex(requestedIndex: number) {\n    const { items, atFocusableItems } = this;\n\n    if (!atFocusableItems.length) {\n      this.#atFocusedItemIndex = requestedIndex;\n      return;\n    }\n\n    // Fast path: requested item is already focusable\n    if (requestedIndex >= 0\n      && requestedIndex < items.length\n      && atFocusableItems.includes(items[requestedIndex])) {\n      this.#atFocusedItemIndex = requestedIndex;\n      return;\n    }\n\n    const lastFocusableIndex = items.indexOf(atFocusableItems.at(-1)!);\n\n    // Navigated before start  wrap to last focusable\n    if (requestedIndex < 0) {\n      this.#atFocusedItemIndex = lastFocusableIndex;\n      return;\n    }\n\n    const firstFocusableIndex = items.indexOf(atFocusableItems[0]);\n\n    // Navigated past end or past last focusable  wrap to first focusable\n    if (requestedIndex >= items.length\n      || requestedIndex > lastFocusableIndex) {\n      this.#atFocusedItemIndex = firstFocusableIndex;\n      return;\n    }\n\n    // Before first focusable (e.g. disabled placeholder at index 0).\n    // ArrowUp from first focusable  wrap to last; otherwise snap to first.\n    if (requestedIndex < firstFocusableIndex) {\n      this.#atFocusedItemIndex =\n          this.#atFocusedItemIndex === firstFocusableIndex ? lastFocusableIndex\n        : firstFocusableIndex;\n      return;\n    }\n\n    // Mid-list non-focusable item: find nearest focusable in the navigation direction\n    this.#atFocusedItemIndex =\n      items.indexOf(this.#getNextFocusableItem(requestedIndex));\n  }\n\n  /** Elements which control the items container e.g. a combobox input */\n  protected get controlsElements(): HTMLElement[] {\n    return this.options.getControlsElements?.() ?? [];\n  }\n\n  /** All items which are able to receive assistive technology focus */\n  get atFocusableItems(): Item[] {\n    return this._items.filter(isATFocusableItem);\n  }\n\n  /** The element containing focusable items, e.g. a listbox */\n  get itemsContainerElement() {\n    return this.#itemsContainerElement ?? null;\n  }\n\n  set itemsContainerElement(container: HTMLElement | null) {\n    if (container !== this.#itemsContainerElement) {\n      this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);\n      this.#itemsContainerElement = container;\n      this.#itemsContainerElement?.addEventListener('keydown', this.onKeydown);\n      this.host.requestUpdate();\n    }\n  }\n\n  constructor(\n    public host: ReactiveControllerHost,\n    protected options: ATFocusControllerOptions<Item>,\n  ) {\n    this.host.updateComplete.then(() => this.initItems());\n  }\n\n  /**\n   * Initialize the items and itemsContainerElement fields.\n   * Call this when the list of items has changed\n   * (e.g. when a parent controller sets items).\n   * @internal not for use by element authors\n   */\n  initItems(): void {\n    this.items = this.options.getItems();\n    this.itemsContainerElement ??= this.#initContainer();\n  }\n\n  hostConnected(): void {\n    this.hostUpdate();\n  }\n\n  hostDisconnected(): void {\n    this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);\n  }\n\n  hostUpdate(): void {\n    this.itemsContainerElement ??= this.#initContainer();\n  }\n\n  #initContainer() {\n    return this.options.getItemsContainer?.()\n      ?? (!isServer && this.host instanceof HTMLElement ? this.host : null);\n  }\n\n  /**\n   * When setting atFocusedItemIndex, and the current focus is on a\n   * mid-list non-focusable item: find nearest focusable in the navigation direction.\n   * disabled items will be skipped, and out of bounds items will be wrapped\n   *\n   * @param requestedIndex the desired index\n   */\n  #getNextFocusableItem(requestedIndex: number) {\n    const { items, atFocusableItems } = this;\n    if (requestedIndex > this.#atFocusedItemIndex) {\n      return atFocusableItems.find(item => items.indexOf(item) > requestedIndex)!;\n    } else {\n      return atFocusableItems.findLast(item => items.indexOf(item) < requestedIndex)!;\n    }\n  }\n\n  /**\n   * Override and conditionally call `super.onKeydown` to filter out keyboard events\n   * which should not result in a focus change. Ensure that subclass' method is bound\n   * @param event keyboard event\n   */\n  protected onKeydown(event: KeyboardEvent): void {\n    const orientation = this.options.getOrientation?.() ?? this\n        .#itemsContainerElement\n        ?.getAttribute('aria-orientation') as\n            'horizontal' | 'vertical' | 'grid' | 'undefined';\n\n    const item = this._items.at(this.atFocusedItemIndex);\n\n    const horizontalOnly =\n        orientation === 'horizontal'\n        || item?.tagName === 'SELECT'\n        || item?.getAttribute('role') === 'spinbutton';\n\n    const verticalOnly = orientation === 'vertical';\n\n    switch (event.key) {\n      case 'ArrowLeft':\n        if (verticalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex--;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowRight':\n        if (verticalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex++;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowUp':\n        if (horizontalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex--;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'ArrowDown':\n        if (horizontalOnly) {\n          return;\n        }\n        this.atFocusedItemIndex++;\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Home': {\n        if (!(event.target instanceof HTMLElement\n            && (event.target.hasAttribute('aria-activedescendant')\n             || event.target.ariaActiveDescendantElement))) {\n          // Use first focusable index so the setter doesn't see 0 (reserved for Up-from-first wrap).\n          const first = this.atFocusableItems.at(0);\n          this.atFocusedItemIndex = first != null ? this.items.indexOf(first) : 0;\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n      }\n      case 'End': {\n        if (!(event.target instanceof HTMLElement\n            && (event.target.hasAttribute('aria-activedescendant')\n             || event.target.ariaActiveDescendantElement))) {\n          // Use last focusable index for consistency with lists that have non-focusable items.\n          const last = this.atFocusableItems.at(-1);\n          this.atFocusedItemIndex = last != null ? this.items.indexOf(last) : this.items.length - 1;\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    this.host.requestUpdate();\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.ts b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.ts
new file mode 100644
index 0000000..17f21f7
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/at-focus-controller.ts
@@ -0,0 +1,254 @@
+import { isServer, type ReactiveControllerHost } from 'lit';
+import { bound } from '../decorators/bound.js';
+
+function isATFocusableItem(el: Element): el is HTMLElement {
+  return !!el
+      && el.ariaHidden !== 'true'
+      && !el.hasAttribute('inert')
+      && !el.hasAttribute('hidden');
+}
+
+export interface ATFocusControllerOptions<Item extends HTMLElement> {
+  /**
+   * Callback to return the list of items
+   */
+  getItems(): Item[];
+  /**
+   * Callback to return the listbox container element
+   */
+  getItemsContainer?(): HTMLElement | null;
+  /**
+   * Callback to return the direction of navigation in the list box.
+   */
+  getOrientation?(): 'horizontal' | 'vertical' | 'both' | 'undefined';
+  /**
+   * Function returning the DOM nodes which are accessibility controllers of item container
+   * e.g. the button toggle and combobox input which control a listbox.
+   */
+  getControlsElements?(): HTMLElement[];
+}
+
+export abstract class ATFocusController<Item extends HTMLElement> {
+  #itemsContainerElement: HTMLElement | null = null;
+
+  #atFocusedItemIndex = -1;
+
+  protected _items: Item[] = [];
+
+  /** All items */
+  abstract items: Item[];
+
+  /**
+   * Index of the Item which currently has assistive technology focus
+   * Set this to change focus. Setting to an out-of-bounds value will
+   * wrap around to the other side of the list.
+   */
+  get atFocusedItemIndex() {
+    return this.#atFocusedItemIndex;
+  }
+
+  set atFocusedItemIndex(requestedIndex: number) {
+    const { items, atFocusableItems } = this;
+
+    if (!atFocusableItems.length) {
+      this.#atFocusedItemIndex = requestedIndex;
+      return;
+    }
+
+    // Fast path: requested item is already focusable
+    if (requestedIndex >= 0
+      && requestedIndex < items.length
+      && atFocusableItems.includes(items[requestedIndex])) {
+      this.#atFocusedItemIndex = requestedIndex;
+      return;
+    }
+
+    const lastFocusableIndex = items.indexOf(atFocusableItems.at(-1)!);
+
+    // Navigated before start  wrap to last focusable
+    if (requestedIndex < 0) {
+      this.#atFocusedItemIndex = lastFocusableIndex;
+      return;
+    }
+
+    const firstFocusableIndex = items.indexOf(atFocusableItems[0]);
+
+    // Navigated past end or past last focusable  wrap to first focusable
+    if (requestedIndex >= items.length
+      || requestedIndex > lastFocusableIndex) {
+      this.#atFocusedItemIndex = firstFocusableIndex;
+      return;
+    }
+
+    // Before first focusable (e.g. disabled placeholder at index 0).
+    // ArrowUp from first focusable  wrap to last; otherwise snap to first.
+    if (requestedIndex < firstFocusableIndex) {
+      this.#atFocusedItemIndex =
+          this.#atFocusedItemIndex === firstFocusableIndex ? lastFocusableIndex
+        : firstFocusableIndex;
+      return;
+    }
+
+    // Mid-list non-focusable item: find nearest focusable in the navigation direction
+    this.#atFocusedItemIndex =
+      items.indexOf(this.#getNextFocusableItem(requestedIndex));
+  }
+
+  /** Elements which control the items container e.g. a combobox input */
+  protected get controlsElements(): HTMLElement[] {
+    return this.options.getControlsElements?.() ?? [];
+  }
+
+  /** All items which are able to receive assistive technology focus */
+  get atFocusableItems(): Item[] {
+    return this._items.filter(isATFocusableItem);
+  }
+
+  /** The element containing focusable items, e.g. a listbox */
+  get itemsContainerElement() {
+    return this.#itemsContainerElement ?? null;
+  }
+
+  set itemsContainerElement(container: HTMLElement | null) {
+    if (container !== this.#itemsContainerElement) {
+      this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);
+      this.#itemsContainerElement = container;
+      this.#itemsContainerElement?.addEventListener('keydown', this.onKeydown);
+      this.host.requestUpdate();
+    }
+  }
+
+  constructor(
+    public host: ReactiveControllerHost,
+    protected options: ATFocusControllerOptions<Item>,
+  ) {
+    this.host.updateComplete.then(() => this.initItems());
+  }
+
+  /**
+   * Initialize the items and itemsContainerElement fields.
+   * Call this when the list of items has changed
+   * (e.g. when a parent controller sets items).
+   * @internal not for use by element authors
+   */
+  initItems(): void {
+    this.items = this.options.getItems();
+    this.itemsContainerElement ??= this.#initContainer();
+  }
+
+  hostConnected(): void {
+    this.hostUpdate();
+  }
+
+  hostDisconnected(): void {
+    this.#itemsContainerElement?.removeEventListener('keydown', this.onKeydown);
+  }
+
+  hostUpdate(): void {
+    this.itemsContainerElement ??= this.#initContainer();
+  }
+
+  #initContainer() {
+    return this.options.getItemsContainer?.()
+      ?? (!isServer && this.host instanceof HTMLElement ? this.host : null);
+  }
+
+  /**
+   * When setting atFocusedItemIndex, and the current focus is on a
+   * mid-list non-focusable item: find nearest focusable in the navigation direction.
+   * disabled items will be skipped, and out of bounds items will be wrapped
+   *
+   * @param requestedIndex the desired index
+   */
+  #getNextFocusableItem(requestedIndex: number) {
+    const { items, atFocusableItems } = this;
+    if (requestedIndex > this.#atFocusedItemIndex) {
+      return atFocusableItems.find(item => items.indexOf(item) > requestedIndex)!;
+    } else {
+      return atFocusableItems.findLast(item => items.indexOf(item) < requestedIndex)!;
+    }
+  }
+
+  /**
+   * Override and conditionally call `super.onKeydown` to filter out keyboard events
+   * which should not result in a focus change. Ensure that subclass' method is bound
+   * @param event keyboard event
+   */
+  protected onKeydown(event: KeyboardEvent): void {
+    const orientation = this.options.getOrientation?.() ?? this
+        .#itemsContainerElement
+        ?.getAttribute('aria-orientation') as
+            'horizontal' | 'vertical' | 'grid' | 'undefined';
+
+    const item = this._items.at(this.atFocusedItemIndex);
+
+    const horizontalOnly =
+        orientation === 'horizontal'
+        || item?.tagName === 'SELECT'
+        || item?.getAttribute('role') === 'spinbutton';
+
+    const verticalOnly = orientation === 'vertical';
+
+    switch (event.key) {
+      case 'ArrowLeft':
+        if (verticalOnly) {
+          return;
+        }
+        this.atFocusedItemIndex--;
+        event.stopPropagation();
+        event.preventDefault();
+        break;
+      case 'ArrowRight':
+        if (verticalOnly) {
+          return;
+        }
+        this.atFocusedItemIndex++;
+        event.stopPropagation();
+        event.preventDefault();
+        break;
+      case 'ArrowUp':
+        if (horizontalOnly) {
+          return;
+        }
+        this.atFocusedItemIndex--;
+        event.stopPropagation();
+        event.preventDefault();
+        break;
+      case 'ArrowDown':
+        if (horizontalOnly) {
+          return;
+        }
+        this.atFocusedItemIndex++;
+        event.stopPropagation();
+        event.preventDefault();
+        break;
+      case 'Home': {
+        if (!(event.target instanceof HTMLElement
+            && (event.target.hasAttribute('aria-activedescendant')
+             || event.target.ariaActiveDescendantElement))) {
+          // Use first focusable index so the setter doesn't see 0 (reserved for Up-from-first wrap).
+          const first = this.atFocusableItems.at(0);
+          this.atFocusedItemIndex = first != null ? this.items.indexOf(first) : 0;
+          event.stopPropagation();
+          event.preventDefault();
+        }
+        break;
+      }
+      case 'End': {
+        if (!(event.target instanceof HTMLElement
+            && (event.target.hasAttribute('aria-activedescendant')
+             || event.target.ariaActiveDescendantElement))) {
+          // Use last focusable index for consistency with lists that have non-focusable items.
+          const last = this.atFocusableItems.at(-1);
+          this.atFocusedItemIndex = last != null ? this.items.indexOf(last) : this.items.length - 1;
+          event.stopPropagation();
+          event.preventDefault();
+        }
+        break;
+      }
+      default:
+        break;
+    }
+    this.host.requestUpdate();
+  };
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/cascade-controller.ts b/node_modules/@patternfly/pfe-core/controllers/cascade-controller.ts
new file mode 100644
index 0000000..bde105c
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/cascade-controller.ts
@@ -0,0 +1,169 @@
+import type { ReactiveController, ReactiveElement } from 'lit';
+
+import { bound } from '../decorators/bound.js';
+import { debounce } from '../functions/debounce.js';
+import { Logger } from './logger.js';
+
+/**
+ * @deprecated use context, especially via `@patternfly/pfe-core/functions/context.js`;
+ */
+export interface Options<E extends ReactiveElement> {
+  properties: Partial<Record<keyof E, string | string[]>>;
+  prefix?: string;
+}
+
+/**
+ * @deprecated use context, especially via `@patternfly/pfe-core/functions/context.js`;
+ */
+export class CascadeController<E extends ReactiveElement> implements ReactiveController {
+  private class: typeof ReactiveElement;
+
+  private logger: Logger;
+
+  static instances: WeakMap<ReactiveElement, CascadeController<ReactiveElement>> =
+    new WeakMap<ReactiveElement, CascadeController<ReactiveElement>>();
+
+  mo: MutationObserver = new MutationObserver(this.parse);
+
+  cache: Map<string, string[]> = new Map<string, string[]>();
+
+  constructor(public host: E, public options?: Options<E> | undefined) {
+    this.class = host.constructor as typeof ReactiveElement;
+    this.logger = new Logger(this.host);
+    CascadeController.instances.set(host, this);
+    const properties = this.options?.properties ?? {} as Options<E>['properties'];
+    for (const [propName, cascade] of Object.entries(properties)) {
+      this.initProp(propName, cascade);
+    }
+    host.addController(this);
+    this.cascadeProperties = debounce(this.cascadeProperties, 1);
+  }
+
+  hostUpdated(): void {
+    this.cascadeProperties();
+  }
+
+  hostConnected(): void {
+    this.mo.observe(this.host, { attributes: true, childList: true });
+    this.cascadeProperties();
+  }
+
+  hostDisconnected(): void {
+    this.mo.disconnect();
+  }
+
+  /**
+   * Handles the cascading of properties to nested components when new elements are added
+   * Attribute updates/additions are handled by the attribute callback
+   * @param [nodeList=this.host.children]
+   */
+  cascadeProperties(nodeList: HTMLCollection | NodeList = this.host.children): void {
+    if (this.host.isConnected) {
+      const selectors = this.cache.keys();
+
+      // Find out if anything in the nodeList matches any of the observed selectors for cacading properties
+      if (!nodeList) {
+        return this._cascadeAttributes(selectors, this.cache);
+      }
+
+
+      for (const node of nodeList) {
+        // if this node has a match function (i.e., it's an HTMLElement, not a text node),
+        if (node instanceof Element) {
+          // see if it matches one of the selectors, otherwise drop it (like it's hot).
+          for (const selector of selectors) {
+            // console.log('_copyAttribute', name, value, el.getAttribute(name));
+            if (node.matches(selector)) {
+              const attrNames = this.cache.get(selector);
+              // each selector can match multiple properties/attributes, so
+              // copy each of them
+              for (const attrName of attrNames ?? []) {
+                this._copyAttribute(attrName, node);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Gets the configured attribute name for the decorated property,
+   * falling back to the lowercased property name, and caches the attribute name
+   * with it's designated child selectors for value-propagation on change
+   * @param propName
+   * @param cascade
+   */
+  initProp(propName: string, cascade: string | string[]): void {
+    for (const nodeItem of [cascade].flat(Infinity).filter(Boolean) as string[]) {
+      const { attribute } = this.class.getPropertyOptions(propName);
+
+      const attr =
+          typeof attribute === 'string' ? attribute
+        : propName.toLowerCase();
+
+      // Create an object with the node as the key and an array of attributes
+      // that are to be cascaded down to it
+      if (!this.cache.get(nodeItem)) {
+        this.cache.set(nodeItem, [attr]);
+      } else {
+        this.cache.get(nodeItem)?.push(attr);
+      }
+    }
+  }
+
+  @bound private parse(mutations: MutationRecord[]) {
+    // Iterate over the mutation list, look for cascade updates
+    for (const mutation of mutations ?? []) {
+      // If a new node is added, attempt to cascade attributes to it
+      if (mutation.type === 'childList' && mutation.addedNodes.length) {
+        this.cascadeProperties(mutation.addedNodes);
+      } else if (mutation.type === 'attributes') {
+        this._cascadeAttributes(this.cache.keys(), this.cache);
+      }
+    }
+  }
+
+  /**
+   * Copy the named attribute to a target element.
+   * @param name attr name
+   * @param el element
+   */
+  private async _copyAttribute(name: string, el: Element) {
+    this.logger.log(`copying ${name} to ${el}`);
+    const value = this.host.getAttribute(name);
+    if (el.isConnected) {
+      if (value == null) {
+        el.removeAttribute(name);
+      } else {
+        el.setAttribute(name, value);
+      }
+    }
+  }
+
+  private _cascadeAttributes(selectors: IterableIterator<string>, set: this['cache']) {
+    for (const selector of selectors) {
+      for (const attr of set.get(selector) ?? []) {
+        this._cascadeAttribute(attr, selector);
+      }
+    }
+  }
+
+  /**
+   * Trigger a cascade of the named attribute to any child elements that match
+   * the `to` selector.  The selector can match elements in the light DOM and
+   * shadow DOM.
+   * @param  name The name of the attribute to cascade (not necessarily the same as the property name).
+   * @param  to A CSS selector that matches the elements that should received the cascaded attribute.  The selector will be applied within `this` element's light and shadow DOM trees.
+   */
+  private _cascadeAttribute(name: string, to: string) {
+    const recipients = [
+      ...this.host.querySelectorAll(to),
+      ...this.host.shadowRoot?.querySelectorAll(to) ?? [],
+    ];
+
+    for (const node of recipients) {
+      this._copyAttribute(name, node);
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.d.ts
index 652a6f4..eb91189 100644
--- a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.d.ts
@@ -81,8 +81,8 @@ export interface ComboboxControllerOptions<Item extends HTMLElement> extends Omi
  */
 export declare class ComboboxController<Item extends HTMLElement> implements ReactiveController {
     #private;
-    host: ReactiveControllerHost;
-    static of<T extends HTMLElement>(host: ReactiveControllerHost, options: ComboboxControllerOptions<T>): ComboboxController<T>;
+    host: ReactiveControllerHost & HTMLElement;
+    static of<T extends HTMLElement>(host: ReactiveControllerHost & HTMLElement, options: ComboboxControllerOptions<T>): ComboboxController<T>;
     /**
      * Whether the `ariaActiveDescendantElement` IDL attribute is supported for cross-root ARIA.
      */
@@ -109,7 +109,7 @@ export declare class ComboboxController<Item extends HTMLElement> implements Rea
     hostUpdated(): void;
     hostDisconnected(): void;
     disconnect(): void;
-    _onFocusoutElement(): Promise<void>;
+    private _onFocusoutElement;
     /**
      * For Browsers which do not support `ariaActiveDescendantElement`, we must clone
      * the listbox items into the same root as the combobox input
diff --git a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
index 1c47fdd..bb9c90e 100644
--- a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js
@@ -1,4 +1,4 @@
-var _ComboboxController_instances, _a, _ComboboxController_alert, _ComboboxController_alertTemplate, _ComboboxController_lb, _ComboboxController_fc, _ComboboxController_preventListboxGainingFocus, _ComboboxController_input, _ComboboxController_button, _ComboboxController_listbox, _ComboboxController_buttonInitialRole, _ComboboxController_mo, _ComboboxController_microcopy, _ComboboxController_hasTextInput_get, _ComboboxController_focusedItem_get, _ComboboxController_element_get, _ComboboxController_init, _ComboboxController_initListbox, _ComboboxController_initButton, _ComboboxController_initInput, _ComboboxController_initLabels, _ComboboxController_initController, _ComboboxController_initItems, _ComboboxController_show, _ComboboxController_hide, _ComboboxController_toggle, _ComboboxController_translate, _ComboboxController_announce, _ComboboxController_filterItems, _ComboboxController_onClickButton, _ComboboxController_onClickListbox, _ComboboxController_onKeydownInput, _ComboboxController_onKeyupInput, _ComboboxController_onKeydownButton, _ComboboxController_onKeydownListbox, _ComboboxController_onFocusoutListbox, _ComboboxController_onKeydownToggleButton;
+var _ComboboxController_instances, _a, _ComboboxController_alert, _ComboboxController_alertTemplate, _ComboboxController_lb, _ComboboxController_fc, _ComboboxController_initializing, _ComboboxController_preventListboxGainingFocus, _ComboboxController_input, _ComboboxController_button, _ComboboxController_listbox, _ComboboxController_buttonInitialRole, _ComboboxController_buttonHasMouseDown, _ComboboxController_mo, _ComboboxController_microcopy, _ComboboxController_hasTextInput_get, _ComboboxController_focusedItem_get, _ComboboxController_element_get, _ComboboxController_init, _ComboboxController_initListbox, _ComboboxController_initButton, _ComboboxController_initInput, _ComboboxController_initLabels, _ComboboxController_initController, _ComboboxController_initItems, _ComboboxController_show, _ComboboxController_hide, _ComboboxController_toggle, _ComboboxController_translate, _ComboboxController_announce, _ComboboxController_filterItems, _ComboboxController_onClickButton, _ComboboxController_onMousedownButton, _ComboboxController_onMouseupButton, _ComboboxController_onClickListbox, _ComboboxController_onKeydownInput, _ComboboxController_onKeyupInput, _ComboboxController_onKeydownButton, _ComboboxController_onKeydownListbox, _ComboboxController_onFocusoutListbox, _ComboboxController_onKeydownToggleButton;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
 import { isServer, nothing } from 'lit';
 import { ListboxController, isItem, isItemDisabled } from './listbox-controller.js';
@@ -89,6 +89,7 @@ export class ComboboxController {
     }
     set items(value) {
         __classPrivateFieldGet(this, _ComboboxController_lb, "f").items = value;
+        __classPrivateFieldGet(this, _ComboboxController_fc, "f")?.initItems();
     }
     /** Whether the combobox is disabled */
     get disabled() {
@@ -116,11 +117,13 @@ export class ComboboxController {
         this.host = host;
         _ComboboxController_lb.set(this, void 0);
         _ComboboxController_fc.set(this, void 0);
+        _ComboboxController_initializing.set(this, false);
         _ComboboxController_preventListboxGainingFocus.set(this, false);
         _ComboboxController_input.set(this, null);
         _ComboboxController_button.set(this, null);
         _ComboboxController_listbox.set(this, null);
         _ComboboxController_buttonInitialRole.set(this, null);
+        _ComboboxController_buttonHasMouseDown.set(this, false);
         _ComboboxController_mo.set(this, new MutationObserver(() => __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initItems).call(this)));
         _ComboboxController_microcopy.set(this, new Map(Object.entries({
             dimmed: {
@@ -159,6 +162,15 @@ export class ComboboxController {
                 __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_hide).call(this);
             }
         });
+        /**
+         * Distinguish click-to-toggle vs Tab/Shift+Tab
+        */
+        _ComboboxController_onMousedownButton.set(this, () => {
+            __classPrivateFieldSet(this, _ComboboxController_buttonHasMouseDown, true, "f");
+        });
+        _ComboboxController_onMouseupButton.set(this, () => {
+            __classPrivateFieldSet(this, _ComboboxController_buttonHasMouseDown, false, "f");
+        });
         _ComboboxController_onClickListbox.set(this, (event) => {
             if (!this.multi && event.composedPath().some(this.options.isItem)) {
                 __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_hide).call(this);
@@ -309,8 +321,13 @@ export class ComboboxController {
         _ComboboxController_onFocusoutListbox.set(this, (event) => {
             if (!__classPrivateFieldGet(this, _ComboboxController_instances, "a", _ComboboxController_hasTextInput_get) && this.options.isExpanded()) {
                 const root = __classPrivateFieldGet(this, _ComboboxController_instances, "a", _ComboboxController_element_get)?.getRootNode();
+                // Check if focus moved to the toggle button via mouse click
+                // If so, let the click handler manage toggle (prevents double-toggle)
+                // But if focus moved via Shift+Tab (no mousedown), we should still hide
+                const isClickOnToggleButton = event.relatedTarget === __classPrivateFieldGet(this, _ComboboxController_button, "f") && __classPrivateFieldGet(this, _ComboboxController_buttonHasMouseDown, "f");
                 if ((root instanceof ShadowRoot || root instanceof Document)
-                    && !this.items.includes(event.relatedTarget)) {
+                    && !this.items.includes(event.relatedTarget)
+                    && !isClickOnToggleButton) {
                     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_hide).call(this);
                 }
             }
@@ -382,7 +399,7 @@ export class ComboboxController {
         this.hostUpdated();
     }
     hostUpdated() {
-        if (!__classPrivateFieldGet(this, _ComboboxController_fc, "f")) {
+        if (!__classPrivateFieldGet(this, _ComboboxController_fc, "f") && !__classPrivateFieldGet(this, _ComboboxController_initializing, "f")) {
             __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_init).call(this);
         }
         const expanded = this.options.isExpanded();
@@ -424,7 +441,7 @@ export class ComboboxController {
         }
     }
 }
-_a = ComboboxController, _ComboboxController_lb = new WeakMap(), _ComboboxController_fc = new WeakMap(), _ComboboxController_preventListboxGainingFocus = new WeakMap(), _ComboboxController_input = new WeakMap(), _ComboboxController_button = new WeakMap(), _ComboboxController_listbox = new WeakMap(), _ComboboxController_buttonInitialRole = new WeakMap(), _ComboboxController_mo = new WeakMap(), _ComboboxController_microcopy = new WeakMap(), _ComboboxController_onClickButton = new WeakMap(), _ComboboxController_onClickListbox = new WeakMap(), _ComboboxController_onKeydownInput = new WeakMap(), _ComboboxController_onKeyupInput = new WeakMap(), _ComboboxController_onKeydownButton = new WeakMap(), _ComboboxController_onKeydownListbox = new WeakMap(), _ComboboxController_onFocusoutListbox = new WeakMap(), _ComboboxController_onKeydownToggleButton = new WeakMap(), _ComboboxController_instances = new WeakSet(), _ComboboxController_hasTextInput_get = function _ComboboxController_hasTextInput_get() {
+_a = ComboboxController, _ComboboxController_lb = new WeakMap(), _ComboboxController_fc = new WeakMap(), _ComboboxController_initializing = new WeakMap(), _ComboboxController_preventListboxGainingFocus = new WeakMap(), _ComboboxController_input = new WeakMap(), _ComboboxController_button = new WeakMap(), _ComboboxController_listbox = new WeakMap(), _ComboboxController_buttonInitialRole = new WeakMap(), _ComboboxController_buttonHasMouseDown = new WeakMap(), _ComboboxController_mo = new WeakMap(), _ComboboxController_microcopy = new WeakMap(), _ComboboxController_onClickButton = new WeakMap(), _ComboboxController_onMousedownButton = new WeakMap(), _ComboboxController_onMouseupButton = new WeakMap(), _ComboboxController_onClickListbox = new WeakMap(), _ComboboxController_onKeydownInput = new WeakMap(), _ComboboxController_onKeyupInput = new WeakMap(), _ComboboxController_onKeydownButton = new WeakMap(), _ComboboxController_onKeydownListbox = new WeakMap(), _ComboboxController_onFocusoutListbox = new WeakMap(), _ComboboxController_onKeydownToggleButton = new WeakMap(), _ComboboxController_instances = new WeakSet(), _ComboboxController_hasTextInput_get = function _ComboboxController_hasTextInput_get() {
     return this.options.getComboboxInput();
 }, _ComboboxController_focusedItem_get = function _ComboboxController_focusedItem_get() {
     return __classPrivateFieldGet(this, _ComboboxController_fc, "f")?.items.at(Math.max(__classPrivateFieldGet(this, _ComboboxController_fc, "f")?.atFocusedItemIndex ?? -1, 0)) ?? null;
@@ -440,6 +457,7 @@ _a = ComboboxController, _ComboboxController_lb = new WeakMap(), _ComboboxContro
  * Order of operations is important
  */
 async function _ComboboxController_init() {
+    __classPrivateFieldSet(this, _ComboboxController_initializing, true, "f");
     await this.host.updateComplete;
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initListbox).call(this);
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initItems).call(this);
@@ -447,6 +465,7 @@ async function _ComboboxController_init() {
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initInput).call(this);
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initLabels).call(this);
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initController).call(this);
+    __classPrivateFieldSet(this, _ComboboxController_initializing, false, "f");
 }, _ComboboxController_initListbox = function _ComboboxController_initListbox() {
     var _b;
     __classPrivateFieldGet(this, _ComboboxController_mo, "f").disconnect();
@@ -465,6 +484,8 @@ async function _ComboboxController_init() {
 }, _ComboboxController_initButton = function _ComboboxController_initButton() {
     __classPrivateFieldGet(this, _ComboboxController_button, "f")?.removeEventListener('click', __classPrivateFieldGet(this, _ComboboxController_onClickButton, "f"));
     __classPrivateFieldGet(this, _ComboboxController_button, "f")?.removeEventListener('keydown', __classPrivateFieldGet(this, _ComboboxController_onKeydownButton, "f"));
+    __classPrivateFieldGet(this, _ComboboxController_button, "f")?.removeEventListener('mousedown', __classPrivateFieldGet(this, _ComboboxController_onMousedownButton, "f"));
+    __classPrivateFieldGet(this, _ComboboxController_button, "f")?.removeEventListener('mouseup', __classPrivateFieldGet(this, _ComboboxController_onMouseupButton, "f"));
     __classPrivateFieldSet(this, _ComboboxController_button, this.options.getToggleButton(), "f");
     if (!__classPrivateFieldGet(this, _ComboboxController_button, "f")) {
         throw new Error('ComboboxController getToggleButton() option must return an element');
@@ -474,6 +495,8 @@ async function _ComboboxController_init() {
     __classPrivateFieldGet(this, _ComboboxController_button, "f").setAttribute('aria-controls', __classPrivateFieldGet(this, _ComboboxController_listbox, "f")?.id ?? '');
     __classPrivateFieldGet(this, _ComboboxController_button, "f").addEventListener('click', __classPrivateFieldGet(this, _ComboboxController_onClickButton, "f"));
     __classPrivateFieldGet(this, _ComboboxController_button, "f").addEventListener('keydown', __classPrivateFieldGet(this, _ComboboxController_onKeydownButton, "f"));
+    __classPrivateFieldGet(this, _ComboboxController_button, "f").addEventListener('mousedown', __classPrivateFieldGet(this, _ComboboxController_onMousedownButton, "f"));
+    __classPrivateFieldGet(this, _ComboboxController_button, "f").addEventListener('mouseup', __classPrivateFieldGet(this, _ComboboxController_onMouseupButton, "f"));
 }, _ComboboxController_initInput = function _ComboboxController_initInput() {
     __classPrivateFieldGet(this, _ComboboxController_input, "f")?.removeEventListener('click', __classPrivateFieldGet(this, _ComboboxController_onClickButton, "f"));
     __classPrivateFieldGet(this, _ComboboxController_input, "f")?.removeEventListener('keyup', __classPrivateFieldGet(this, _ComboboxController_onKeyupInput, "f"));
@@ -535,6 +558,8 @@ async function _ComboboxController_init() {
         this.items = this.options.getItems();
     }
 }, _ComboboxController_show = async function _ComboboxController_show() {
+    // Re-read items on open so slotted/dynamically added options are included:
+    __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_initItems).call(this);
     const success = await this.options.requestShowListbox();
     __classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_filterItems).call(this);
     if (success !== false && !__classPrivateFieldGet(this, _ComboboxController_instances, "a", _ComboboxController_hasTextInput_get)) {
@@ -569,12 +594,14 @@ async function _ComboboxController_init() {
     if (__classPrivateFieldGet(this, _ComboboxController_lb, "f").isSelected(item)) {
         text += `, (${__classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_translate).call(this, 'selected', langKey)})`;
     }
-    if (item.hasAttribute('aria-setsize') && item.hasAttribute('aria-posinset')) {
+    const posInSet = InternalsController.getAriaPosInSet(item);
+    const setSize = InternalsController.getAriaSetSize(item);
+    if (posInSet != null && setSize != null) {
         if (langKey === 'ja') {
-            text += `, (${item.getAttribute('aria-setsize')}  ${item.getAttribute('aria-posinset')} )`;
+            text += `, (${setSize}  ${posInSet} )`;
         }
         else {
-            text += `, (${item.getAttribute('aria-posinset')} ${__classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_translate).call(this, 'of', langKey)} ${item.getAttribute('aria-setsize')})`;
+            text += `, (${posInSet} ${__classPrivateFieldGet(this, _ComboboxController_instances, "m", _ComboboxController_translate).call(this, 'of', langKey)} ${setSize})`;
         }
     }
     __classPrivateFieldGet(_a, _a, "f", _ComboboxController_alert).lang = lang;
diff --git a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js.map
index c55d53c..58b9bf8 100644
--- a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"combobox-controller.js","sourceRoot":"","sources":["combobox-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, nothing, type ReactiveController, type ReactiveControllerHost } from 'lit';\nimport type { ActivedescendantControllerOptions } from './activedescendant-controller.js';\nimport type { RovingTabindexControllerOptions } from './roving-tabindex-controller.js';\nimport type { ATFocusController } from './at-focus-controller';\nimport type { ListboxControllerOptions } from './listbox-controller.js';\n\nimport { ListboxController, isItem, isItemDisabled } from './listbox-controller.js';\nimport { RovingTabindexController } from './roving-tabindex-controller.js';\nimport { ActivedescendantController } from './activedescendant-controller.js';\nimport { InternalsController } from './internals-controller.js';\nimport { getRandomId } from '../functions/random.js';\nimport type { RequireProps } from '../core.js';\n\ntype AllOptions<Item extends HTMLElement> =\n    ActivedescendantControllerOptions<Item>\n  & ListboxControllerOptions<Item>\n  & RovingTabindexControllerOptions<Item>;\n\ntype Lang = typeof ComboboxController['langs'][number];\n\nfunction deepClosest(element: Element | null, selector: string) {\n  let closest = element?.closest(selector);\n  let root = element?.getRootNode();\n  let count = 0;\n  while (count < 500 && !closest && element) {\n    count++;\n    root = element.getRootNode();\n    if (root instanceof ShadowRoot) {\n      element = root.host;\n    } else if (root instanceof Document) {\n      element = document.documentElement;\n    } else {\n      return null;\n    }\n    closest = element.closest(selector);\n  }\n  return closest;\n}\n\nfunction getItemValue<Item extends HTMLElement>(item: Item): string {\n  if ('value' in item && typeof item.value === 'string') {\n    return item.value;\n  } else {\n    return '';\n  }\n}\n\nfunction isItemFiltered<Item extends HTMLElement>(item: Item, value: string): boolean {\n  return !getItemValue(item)\n      .toLowerCase()\n      .startsWith(value.toLowerCase());\n}\n\nfunction setItemHidden(item: HTMLElement, hidden: boolean) {\n  item.hidden = hidden;\n}\n\nfunction setComboboxValue(item: HTMLElement, value: string): void {\n  if (!('value' in item)) {\n    // eslint-disable-next-line no-console\n    return console.warn(`Cannot set value on combobox element ${item.localName}`);\n  } else {\n    item.value = value;\n  }\n}\n\nfunction getComboboxValue(combobox: HTMLElement): string {\n  if ('value' in combobox && typeof combobox.value === 'string') {\n    return combobox.value;\n  } else {\n    // eslint-disable-next-line no-console\n    return console.warn(`Cannot get value from combobox element ${combobox.localName}`), '';\n  }\n}\n\nexport interface ComboboxControllerOptions<Item extends HTMLElement> extends\n  Omit<AllOptions<Item>,\n    | 'getATFocusedItem'\n    | 'getControlsElements'\n    | 'getActiveDescendantContainer'\n    | 'getItemsContainer'> {\n  /**\n   * Predicate which establishes whether the listbox is expanded\n   * e.g. `isExpanded: () => this.expanded`, if the host's `expanded` property\n   * should correspond to the listbox expanded state.\n   */\n  isExpanded(): boolean;\n  /**\n   * Callback which the host must implement to change the expanded state to true.\n   * Return or resolve false to prevent the change.\n   */\n  requestShowListbox(): void | boolean | Promise<boolean> | Promise<void>;\n  /**\n   * Callback which the host must implement to change the expanded to false.\n   * Return or resolve false to prevent the default.\n   */\n  requestHideListbox(): void | boolean | Promise<boolean> | Promise<void>;\n  /**\n   * Returns the listbox container element\n   */\n  getListboxElement(): HTMLElement | null;\n  /**\n   * Returns the toggle button, if it exists\n   */\n  getToggleButton(): HTMLElement | null;\n  /**\n   * Returns the combobox input, if it exists\n   */\n  getComboboxInput(): HTMLElement | null;\n  /**\n   * Returns the label for the toggle button, combobox input, and listbox.\n   * when `ariaLabelledByElements` is supported, the label elements associated with\n   * the host element are used instead, and this value is ignored.\n   */\n  getFallbackLabel(): string;\n  /**\n   * Called on an item to retrieve it's value string. By default, returns the `value` property\n   * of the item, as if it implemented the `<option>` element's interface.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement\n   */\n  getItemValue?(item: Item): string;\n  /**\n   * Optional callback, called on the combobox input element to set its value.\n   * by default, returns the element's `value` DOM property.\n   */\n  getComboboxValue?(combobox: HTMLElement): string;\n  /**\n   * Optional callback, called on the combobox input element to set its value.\n   * by default, sets the element's `value` DOM property.\n   */\n  setComboboxValue?(item: HTMLElement, value: string): void;\n  /**\n   * Called on each item, with the combobox input, to determine if the item should be shown in the\n   * listbox or filtered out. Return false to hide the item. By default, checks whether the item's\n   * value starts with the input value (when both are lowercased).\n   */\n  isItemFiltered?(item: Item, value: string): boolean;\n  /**\n   * Called on each item when the filter changes.\n   * By default, toggles the `hidden` attribute on the item\n   */\n  setItemHidden?(item: Item, hidden: boolean): void;\n}\n\n/**\n * @summary Implements the WAI-ARIA pattern [Editable Combobox with Both List and Inline Autocomplete].\n *\n * Combobox with keyboard and pointer navigation, using the aria-activedescendant pattern.\n *\n * WARNING: Safari VoiceOver does not support aria-activedescendant, so Safari users\n * rely on the combobox input value being announced when navigating the listbox with the keyboard.\n * We have erred on the side that it may be less-broken to avoid announcing disabled items in that\n * case, rather than announcing the disabled items value without indicating that it is disabled.\n * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)\n *\n * [pattern]: https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-both/\n */\nexport class ComboboxController<\n  Item extends HTMLElement\n> implements ReactiveController {\n  public static of<T extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: ComboboxControllerOptions<T>,\n  ): ComboboxController<T> {\n    return new ComboboxController(host, options);\n  }\n\n  /**\n   * Whether the `ariaActiveDescendantElement` IDL attribute is supported for cross-root ARIA.\n   */\n  public static get supportsCrossRootActiveDescendant(): boolean {\n    return ActivedescendantController.supportsCrossRootActiveDescendant;\n  }\n\n  static #alert?: HTMLElement;\n\n  static #alertTemplate = document.createElement('template');\n\n  private static langs = [\n    'en',\n    'es',\n    'de',\n    'fr',\n    'it',\n    'ja',\n    'zh',\n  ] as const;\n\n  private static langsRE = new RegExp(ComboboxController.langs.join('|'));\n\n  private static instances = new WeakMap<ReactiveControllerHost, ComboboxController<HTMLElement>>();\n\n  private static hosts = new Set<ReactiveControllerHost>();\n\n  static {\n    // apply visually-hidden styles\n    this.#alertTemplate.innerHTML = `\n      <div role=\"alert\" style=\"\n         border: 0;\n         clip: rect(0, 0, 0, 0);\n         block-size: 1px;\n         margin: -1px;\n         overflow: hidden;\n         padding: 0;\n         position: absolute;\n         white-space: nowrap;\n         inline-size: 1px;\n        \"></div>\n      `;\n  }\n\n  // Hide listbox on focusout\n  static {\n    if (!isServer) {\n      document.addEventListener('focusout', event => {\n        const target = event.target as HTMLElement;\n        for (const host of ComboboxController.hosts) {\n          if (host instanceof Node && host.contains(target)) {\n            const instance = ComboboxController.instances.get(host);\n            instance?._onFocusoutElement();\n          }\n        }\n      });\n    }\n  }\n\n  private options: RequireProps<ComboboxControllerOptions<Item>,\n    | 'isItemDisabled'\n    | 'isItem'\n    | 'isItemFiltered'\n    | 'getItemValue'\n    | 'getOrientation'\n    | 'getComboboxValue'\n    | 'setComboboxValue'\n    | 'setItemHidden'\n  >;\n\n  #lb: ListboxController<Item>;\n  #fc?: ATFocusController<Item>;\n  #preventListboxGainingFocus = false;\n  #input: HTMLElement | null = null;\n  #button: HTMLElement | null = null;\n  #listbox: HTMLElement | null = null;\n  #buttonInitialRole: string | null = null;\n  #mo = new MutationObserver(() => this.#initItems());\n  #microcopy = new Map<string, Record<Lang, string>>(Object.entries({\n    dimmed: {\n      en: 'dimmed',\n      es: 'atenuada',\n      de: 'gedimmt',\n      it: 'oscurato',\n      fr: 'attnu',\n      ja: '',\n      zh: '',\n    },\n    selected: {\n      en: 'selected',\n      es: 'seleccionado',\n      de: 'ausgewhlt',\n      fr: 'choisie',\n      it: 'selezionato',\n      ja: '',\n      zh: '',\n    },\n    of: {\n      en: 'of',\n      es: 'de',\n      de: 'von',\n      fr: 'sur',\n      it: 'di',\n      ja: '',\n      zh: '',\n    },\n  }));\n\n  /** All items */\n  get items(): Item[] {\n    return this.#lb.items;\n  }\n\n  set items(value: Item[]) {\n    this.#lb.items = value;\n  }\n\n  /** Whether the combobox is disabled */\n  get disabled() {\n    return this.#lb.disabled;\n  }\n\n  set disabled(value: boolean) {\n    this.#lb.disabled = value;\n  }\n\n  /** Whether multiselect is enabled */\n  get multi() {\n    return this.#lb.multi;\n  }\n\n  set multi(value: boolean) {\n    this.#lb.multi = value;\n  }\n\n  /** The current selection: a list of items */\n  get selected() {\n    return this.#lb.selected;\n  }\n\n  set selected(value: Item[]) {\n    this.#lb.selected = value;\n  }\n\n  get #hasTextInput() {\n    return this.options.getComboboxInput();\n  }\n\n  get #focusedItem() {\n    return this.#fc?.items.at(Math.max(this.#fc?.atFocusedItemIndex ?? -1, 0)) ?? null;\n  }\n\n  get #element() {\n    if (this.host instanceof HTMLElement) {\n      return this.host;\n    } else if (this.options.getListboxElement() instanceof HTMLElement) {\n      return this.options.getListboxElement();\n    }\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    options: ComboboxControllerOptions<Item>,\n  ) {\n    host.addController(this);\n    this.options = {\n      isItem,\n      getItemValue,\n      isItemFiltered,\n      isItemDisabled,\n      getComboboxValue,\n      setComboboxValue,\n      setItemHidden,\n      getOrientation: () => 'vertical',\n      ...options,\n    };\n    this.#lb = ListboxController.of(host, {\n      isItem: this.options.isItem,\n      getItemsContainer: this.options.getListboxElement,\n      getControlsElements: () => [\n        this.options.getToggleButton(),\n        this.options.getComboboxInput(),\n      ].filter(x => !!x),\n      getATFocusedItem: () => this.items[this.#fc?.atFocusedItemIndex ?? -1] ?? null,\n      isItemDisabled: this.options.isItemDisabled,\n      setItemSelected: this.options.setItemSelected,\n    });\n    ComboboxController.instances.set(host, this);\n    ComboboxController.hosts.add(host);\n  }\n\n  async hostConnected(): Promise<void> {\n    await this.host.updateComplete;\n    this.hostUpdated();\n  }\n\n  hostUpdated(): void {\n    if (!this.#fc) {\n      this.#init();\n    }\n    const expanded = this.options.isExpanded();\n    this.#button?.setAttribute('aria-expanded', String(expanded));\n    this.#input?.setAttribute('aria-expanded', String(expanded));\n    this.#initLabels();\n  }\n\n  hostDisconnected(): void {\n    this.#fc?.hostDisconnected();\n  }\n\n  disconnect(): void {\n    ComboboxController.instances.delete(this.host);\n    ComboboxController.hosts.delete(this.host);\n  }\n\n  async _onFocusoutElement(): Promise<void> {\n    if (this.#hasTextInput && this.options.isExpanded()) {\n      const root = this.#element?.getRootNode();\n      await new Promise(requestAnimationFrame);\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        const { activeElement } = root;\n        if (!this.#element?.contains(activeElement)) {\n          this.#hide();\n        }\n      }\n    }\n  }\n\n  /**\n   * Order of operations is important\n   */\n  async #init() {\n    await this.host.updateComplete;\n    this.#initListbox();\n    this.#initItems();\n    this.#initButton();\n    this.#initInput();\n    this.#initLabels();\n    this.#initController();\n  }\n\n  #initListbox() {\n    this.#mo.disconnect();\n    this.#listbox?.removeEventListener('focusout', this.#onFocusoutListbox);\n    this.#listbox?.removeEventListener('keydown', this.#onKeydownListbox);\n    this.#listbox?.removeEventListener('click', this.#onClickListbox);\n    this.#listbox = this.options.getListboxElement();\n    if (!this.#listbox) {\n      throw new Error('ComboboxController getListboxElement() option must return an element');\n    }\n    this.#listbox.addEventListener('focusout', this.#onFocusoutListbox);\n    this.#listbox.addEventListener('keydown', this.#onKeydownListbox);\n    this.#listbox.addEventListener('click', this.#onClickListbox);\n    this.#listbox.id ??= getRandomId();\n    this.#mo.observe(this.#listbox, { childList: true });\n  }\n\n  #initButton() {\n    this.#button?.removeEventListener('click', this.#onClickButton);\n    this.#button?.removeEventListener('keydown', this.#onKeydownButton);\n    this.#button = this.options.getToggleButton();\n    if (!this.#button) {\n      throw new Error('ComboboxController getToggleButton() option must return an element');\n    }\n    this.#buttonInitialRole = this.#button.role;\n    this.#button.role = 'combobox';\n    this.#button.setAttribute('aria-controls', this.#listbox?.id ?? '');\n    this.#button.addEventListener('click', this.#onClickButton);\n    this.#button.addEventListener('keydown', this.#onKeydownButton);\n  }\n\n  #initInput() {\n    this.#input?.removeEventListener('click', this.#onClickButton);\n    this.#input?.removeEventListener('keyup', this.#onKeyupInput);\n    this.#input?.removeEventListener('keydown', this.#onKeydownInput);\n\n    this.#input = this.options.getComboboxInput();\n    if (this.#input && !('value' in this.#input)) {\n      throw new Error(`ComboboxController getToggleInput() option must return an element with a value property`);\n    } else if (this.#input) {\n      this.#input.role = 'combobox';\n      this.#button!.role = this.#buttonInitialRole;\n      this.#input.setAttribute('aria-autocomplete', 'both');\n      this.#input.setAttribute('aria-controls', this.#listbox?.id ?? '');\n      this.#input.addEventListener('click', this.#onClickButton);\n      this.#input.addEventListener('keyup', this.#onKeyupInput);\n      this.#input.addEventListener('keydown', this.#onKeydownInput);\n    }\n  }\n\n  #initLabels() {\n    const labels = InternalsController.getLabels(this.host)\n                ?? this.#element?.ariaLabelledByElements\n                ?? [];\n    const label = this.options.getFallbackLabel()\n                  || this.#element?.ariaLabelledByElements?.map(x => x.textContent).join('')\n                  || null;\n\n    for (const element of [this.#button, this.#listbox, this.#input].filter(x => !!x)) {\n      if ('ariaLabelledByElements' in HTMLElement.prototype && labels.filter(x => !!x).length) {\n        element.ariaLabelledByElements = [...labels ?? []];\n      } else {\n        element.ariaLabel = label;\n      }\n    }\n  }\n\n  #initController() {\n    this.#fc?.hostDisconnected();\n    const { getOrientation } = this.options;\n    const getItems = () => this.items;\n    const getItemsContainer = () => this.#listbox;\n    if (this.#hasTextInput) {\n      this.#fc = ActivedescendantController.of(this.host, {\n        getItems, getItemsContainer, getOrientation,\n        getActiveDescendantContainer: () => this.#input,\n        getControlsElements: () => [\n          this.options.getToggleButton(),\n          this.options.getComboboxInput(),\n        ].filter(x => !!x),\n        setItemActive: this.options.setItemActive,\n      });\n    } else {\n      this.#fc = RovingTabindexController.of(this.host, {\n        getItems, getItemsContainer, getOrientation,\n        getControlsElements: () => [\n          this.options.getToggleButton(),\n        ].filter(x => !!x),\n      });\n    }\n  }\n\n  #initItems() {\n    if (this.#listbox) {\n      this.items = this.options.getItems();\n    }\n  }\n\n  async #show(): Promise<void> {\n    const success = await this.options.requestShowListbox();\n    this.#filterItems();\n    if (success !== false && !this.#hasTextInput) {\n      if (!this.#preventListboxGainingFocus) {\n        (this.#focusedItem ?? this.#fc?.items.at(0))?.focus();\n        this.#preventListboxGainingFocus = false;\n      }\n    }\n  }\n\n  async #hide(): Promise<void> {\n    await this.options.requestHideListbox();\n  }\n\n  async #toggle() {\n    if (this.options.isExpanded()) {\n      return this.#hide();\n    } else {\n      return this.#show();\n    }\n  }\n\n  #translate(key: string, lang: Lang) {\n    const strings = this.#microcopy.get(key);\n    return strings?.[lang] ?? key;\n  }\n\n  // TODO(bennypowers): perhaps move this to ActivedescendantController\n  #announce(item: Item) {\n    const value = this.options.getItemValue(item);\n    ComboboxController.#alert?.remove();\n    const fragment = ComboboxController.#alertTemplate.content.cloneNode(true) as DocumentFragment;\n    ComboboxController.#alert = fragment.firstElementChild as HTMLElement;\n    let text = value;\n    const lang = deepClosest(this.#listbox, '[lang]')?.getAttribute('lang') ?? 'en';\n    const langKey = lang?.match(ComboboxController.langsRE)?.at(0) as Lang ?? 'en';\n    if (this.options.isItemDisabled(item)) {\n      text += ` (${this.#translate('dimmed', langKey)})`;\n    }\n    if (this.#lb.isSelected(item)) {\n      text += `, (${this.#translate('selected', langKey)})`;\n    }\n    if (item.hasAttribute('aria-setsize') && item.hasAttribute('aria-posinset')) {\n      if (langKey === 'ja') {\n        text += `, (${item.getAttribute('aria-setsize')}  ${item.getAttribute('aria-posinset')} )`;\n      } else {\n        text += `, (${item.getAttribute('aria-posinset')} ${this.#translate('of', langKey)} ${item.getAttribute('aria-setsize')})`;\n      }\n    }\n    ComboboxController.#alert.lang = lang;\n    ComboboxController.#alert.innerText = text;\n    document.body.append(ComboboxController.#alert);\n  }\n\n  #filterItems() {\n    if (this.#input) {\n      let value: string;\n      for (const item of this.items) {\n        const hidden =\n          !!this.options.isExpanded()\n            && !!(value = this.options.getComboboxValue(this.#input))\n            && this.options.isItemFiltered?.(item, value)\n            || false;\n        this.options.setItemHidden(item, hidden);\n      }\n    }\n  }\n\n  #onClickButton = () => {\n    if (!this.options.isExpanded()) {\n      this.#show();\n    } else {\n      this.#hide();\n    }\n  };\n\n  #onClickListbox = (event: MouseEvent) => {\n    if (!this.multi && event.composedPath().some(this.options.isItem)) {\n      this.#hide();\n    }\n  };\n\n  /**\n   * Handle keypresses on the input\n   * ## `Down Arrow`\n   * - If the textbox is not empty and the listbox is displayed,\n   *   moves visual focus to the first suggested value.\n   * - If the textbox is empty and the listbox is not displayed,\n   *   opens the listbox and moves visual focus to the first option.\n   * - In both cases DOM focus remains on the textbox.\n   *\n   * ## `Alt + Down Arrow`\n   * Opens the listbox without moving focus or changing selection.\n   *\n   * ## `Up Arrow`\n   * - If the textbox is not empty and the listbox is displayed,\n   *   moves visual focus to the last suggested value.\n   * - If the textbox is empty, first opens the listbox if it is not already displayed\n   *   and then moves visual focus to the last option.\n   * - In both cases DOM focus remains on the textbox.\n   *\n   * ## `Enter`\n   * Closes the listbox if it is displayed.\n   *\n   * ## `Escape`\n   * - If the listbox is displayed, closes it.\n   * - If the listbox is not displayed, clears the textbox.\n   *\n   * ## Standard single line text editing keys\n   * - Keys used for cursor movement and text manipulation,\n   *   such as `Delete` and `Shift + Right Arrow`.\n   * - An HTML `input` with `type=\"text\"` is used for the textbox so the browser will provide\n   *   platform-specific editing keys.\n   *\n   * @see https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list\n   * @param event keydown event\n   */\n  #onKeydownInput = (event: KeyboardEvent) => {\n    if (event.ctrlKey || event.shiftKey || !this.#input) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n        if (!this.options.isExpanded()) {\n          this.#preventListboxGainingFocus = event.altKey;\n          this.#show();\n        }\n        break;\n      case 'Enter':\n        if (!this.multi) {\n          this.#hide();\n        }\n        break;\n      case 'Escape':\n        if (!this.options.isExpanded()) {\n          this.options.setComboboxValue(this.#input, '');\n          this.host.requestUpdate();\n        }\n        this.#hide();\n        break;\n      case 'Alt':\n      case 'AltGraph':\n      case 'Shift':\n      case 'Control':\n      case 'Fn':\n      case 'Symbol':\n      case 'Hyper':\n      case 'Super':\n      case 'Meta':\n      case 'CapsLock':\n      case 'FnLock':\n      case 'NumLock':\n      case 'Tab':\n      case 'ScrollLock':\n      case 'SymbolLock':\n      case ' ':\n        break;\n      default:\n        if (!this.options.isExpanded()) {\n          this.#show();\n        }\n    }\n  };\n\n  /**\n   * Populates the combobox input with the focused value when navigating the listbox,\n   * and filters the items when typing.\n   * @param event keyup event\n   */\n  #onKeyupInput = (event: KeyboardEvent) => {\n    if (!this.#input) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n        /**\n         * Safari VoiceOver does not support aria-activedescendant, so we must.\n         * approximate the correct behaviour by constructing a visually-hidden alert role\n         * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)\n         */\n        if (this.#focusedItem\n            && this.options.getComboboxInput()\n            && InternalsController.isSafari) {\n          this.#announce(this.#focusedItem);\n        }\n        break;\n      default:\n        this.#filterItems();\n    }\n  };\n\n  #onKeydownButton = (event: KeyboardEvent) => {\n    if (this.#hasTextInput) {\n      return this.#onKeydownInput(event);\n    } else {\n      return this.#onKeydownToggleButton(event);\n    }\n  };\n\n  #onKeydownListbox = (event: KeyboardEvent) => {\n    if (!this.#hasTextInput) {\n      switch (event.key) {\n        case 'Home':\n        case 'End':\n          this.#onKeydownToggleButton(event);\n          break;\n        case 'Escape':\n          this.#hide();\n          this.#button?.focus();\n          break;\n        case 'Enter':\n        case ' ': {\n          const eventItem = event.composedPath().find(this.options.isItem);\n          if (eventItem\n              && !this.multi\n              && this.options.isExpanded()\n              && !this.options.isItemDisabled(eventItem)\n          ) {\n            this.#hide();\n            this.#button?.focus();\n          }\n        }\n      }\n    }\n  };\n\n  #onFocusoutListbox = (event: FocusEvent) => {\n    if (!this.#hasTextInput && this.options.isExpanded()) {\n      const root = this.#element?.getRootNode();\n      if ((root instanceof ShadowRoot || root instanceof Document)\n          && !this.items.includes(event.relatedTarget as Item)\n      ) {\n        this.#hide();\n      }\n    }\n  };\n\n  #onKeydownToggleButton = async (event: KeyboardEvent) => {\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n        if (!this.options.isExpanded()) {\n          this.#show();\n        }\n        break;\n      case 'Home':\n        if (!this.options.isExpanded()) {\n          await this.#show();\n        }\n        if (this.#fc) {\n          this.#fc.atFocusedItemIndex = 0;\n        }\n        break;\n      case 'End':\n        if (!this.options.isExpanded()) {\n          await this.#show();\n        }\n        if (this.#fc) {\n          this.#fc.atFocusedItemIndex = this.items.length - 1;\n        }\n        break;\n      case ' ':\n      case 'Enter':\n        // prevent scroll\n        event.preventDefault();\n        await this.#toggle();\n        await this.host.updateComplete;\n        if (!this.options.isExpanded()) {\n          this.#button?.focus();\n        }\n        break;\n    }\n  };\n\n  /**\n   * For Browsers which do not support `ariaActiveDescendantElement`, we must clone\n   * the listbox items into the same root as the combobox input\n   * Call this method to return either an array of (cloned) list box items, to be placed in your\n   * shadow template, or nothing in the case the browser supports cross-root aria.\n   */\n  public renderItemsToShadowRoot(): Node[] | typeof nothing {\n    if (this.#fc instanceof ActivedescendantController) {\n      return this.#fc.renderItemsToShadowRoot();\n    } else {\n      return nothing;\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"combobox-controller.js","sourceRoot":"","sources":["combobox-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, nothing, type ReactiveController, type ReactiveControllerHost } from 'lit';\nimport type { ActivedescendantControllerOptions } from './activedescendant-controller.js';\nimport type { RovingTabindexControllerOptions } from './roving-tabindex-controller.js';\nimport type { ATFocusController } from './at-focus-controller.js';\nimport type { ListboxControllerOptions } from './listbox-controller.js';\n\nimport { ListboxController, isItem, isItemDisabled } from './listbox-controller.js';\nimport { RovingTabindexController } from './roving-tabindex-controller.js';\nimport { ActivedescendantController } from './activedescendant-controller.js';\nimport { InternalsController } from './internals-controller.js';\nimport { getRandomId } from '../functions/random.js';\nimport type { RequireProps } from '../core.js';\n\ntype AllOptions<Item extends HTMLElement> =\n    ActivedescendantControllerOptions<Item>\n  & ListboxControllerOptions<Item>\n  & RovingTabindexControllerOptions<Item>;\n\ntype Lang = typeof ComboboxController['langs'][number];\n\nfunction deepClosest(element: Element | null, selector: string) {\n  let closest = element?.closest(selector);\n  let root = element?.getRootNode();\n  let count = 0;\n  while (count < 500 && !closest && element) {\n    count++;\n    root = element.getRootNode();\n    if (root instanceof ShadowRoot) {\n      element = root.host;\n    } else if (root instanceof Document) {\n      element = document.documentElement;\n    } else {\n      return null;\n    }\n    closest = element.closest(selector);\n  }\n  return closest;\n}\n\nfunction getItemValue<Item extends HTMLElement>(item: Item): string {\n  if ('value' in item && typeof item.value === 'string') {\n    return item.value;\n  } else {\n    return '';\n  }\n}\n\nfunction isItemFiltered<Item extends HTMLElement>(item: Item, value: string): boolean {\n  return !getItemValue(item)\n      .toLowerCase()\n      .startsWith(value.toLowerCase());\n}\n\nfunction setItemHidden(item: HTMLElement, hidden: boolean) {\n  item.hidden = hidden;\n}\n\nfunction setComboboxValue(item: HTMLElement, value: string): void {\n  if (!('value' in item)) {\n    // eslint-disable-next-line no-console\n    return console.warn(`Cannot set value on combobox element ${item.localName}`);\n  } else {\n    item.value = value;\n  }\n}\n\nfunction getComboboxValue(combobox: HTMLElement): string {\n  if ('value' in combobox && typeof combobox.value === 'string') {\n    return combobox.value;\n  } else {\n    // eslint-disable-next-line no-console\n    return console.warn(`Cannot get value from combobox element ${combobox.localName}`), '';\n  }\n}\n\nexport interface ComboboxControllerOptions<Item extends HTMLElement> extends\n  Omit<AllOptions<Item>,\n    | 'getATFocusedItem'\n    | 'getControlsElements'\n    | 'getActiveDescendantContainer'\n    | 'getItemsContainer'> {\n  /**\n   * Predicate which establishes whether the listbox is expanded\n   * e.g. `isExpanded: () => this.expanded`, if the host's `expanded` property\n   * should correspond to the listbox expanded state.\n   */\n  isExpanded(): boolean;\n  /**\n   * Callback which the host must implement to change the expanded state to true.\n   * Return or resolve false to prevent the change.\n   */\n  requestShowListbox(): void | boolean | Promise<boolean> | Promise<void>;\n  /**\n   * Callback which the host must implement to change the expanded to false.\n   * Return or resolve false to prevent the default.\n   */\n  requestHideListbox(): void | boolean | Promise<boolean> | Promise<void>;\n  /**\n   * Returns the listbox container element\n   */\n  getListboxElement(): HTMLElement | null;\n  /**\n   * Returns the toggle button, if it exists\n   */\n  getToggleButton(): HTMLElement | null;\n  /**\n   * Returns the combobox input, if it exists\n   */\n  getComboboxInput(): HTMLElement | null;\n  /**\n   * Returns the label for the toggle button, combobox input, and listbox.\n   * when `ariaLabelledByElements` is supported, the label elements associated with\n   * the host element are used instead, and this value is ignored.\n   */\n  getFallbackLabel(): string;\n  /**\n   * Called on an item to retrieve it's value string. By default, returns the `value` property\n   * of the item, as if it implemented the `<option>` element's interface.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement\n   */\n  getItemValue?(item: Item): string;\n  /**\n   * Optional callback, called on the combobox input element to set its value.\n   * by default, returns the element's `value` DOM property.\n   */\n  getComboboxValue?(combobox: HTMLElement): string;\n  /**\n   * Optional callback, called on the combobox input element to set its value.\n   * by default, sets the element's `value` DOM property.\n   */\n  setComboboxValue?(item: HTMLElement, value: string): void;\n  /**\n   * Called on each item, with the combobox input, to determine if the item should be shown in the\n   * listbox or filtered out. Return false to hide the item. By default, checks whether the item's\n   * value starts with the input value (when both are lowercased).\n   */\n  isItemFiltered?(item: Item, value: string): boolean;\n  /**\n   * Called on each item when the filter changes.\n   * By default, toggles the `hidden` attribute on the item\n   */\n  setItemHidden?(item: Item, hidden: boolean): void;\n}\n\n/**\n * @summary Implements the WAI-ARIA pattern [Editable Combobox with Both List and Inline Autocomplete].\n *\n * Combobox with keyboard and pointer navigation, using the aria-activedescendant pattern.\n *\n * WARNING: Safari VoiceOver does not support aria-activedescendant, so Safari users\n * rely on the combobox input value being announced when navigating the listbox with the keyboard.\n * We have erred on the side that it may be less-broken to avoid announcing disabled items in that\n * case, rather than announcing the disabled items value without indicating that it is disabled.\n * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)\n *\n * [pattern]: https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-both/\n */\nexport class ComboboxController<\n  Item extends HTMLElement\n> implements ReactiveController {\n  public static of<T extends HTMLElement>(\n    host: ReactiveControllerHost & HTMLElement,\n    options: ComboboxControllerOptions<T>,\n  ): ComboboxController<T> {\n    return new ComboboxController(host, options);\n  }\n\n  /**\n   * Whether the `ariaActiveDescendantElement` IDL attribute is supported for cross-root ARIA.\n   */\n  public static get supportsCrossRootActiveDescendant(): boolean {\n    return ActivedescendantController.supportsCrossRootActiveDescendant;\n  }\n\n  static #alert?: HTMLElement;\n\n  static #alertTemplate = document.createElement('template');\n\n  private static langs = [\n    'en',\n    'es',\n    'de',\n    'fr',\n    'it',\n    'ja',\n    'zh',\n  ] as const;\n\n  private static langsRE = new RegExp(ComboboxController.langs.join('|'));\n\n  private static instances = new WeakMap<ReactiveControllerHost, ComboboxController<HTMLElement>>();\n\n  private static hosts = new Set<ReactiveControllerHost>();\n\n  static {\n    // apply visually-hidden styles\n    this.#alertTemplate.innerHTML = `\n      <div role=\"alert\" style=\"\n         border: 0;\n         clip: rect(0, 0, 0, 0);\n         block-size: 1px;\n         margin: -1px;\n         overflow: hidden;\n         padding: 0;\n         position: absolute;\n         white-space: nowrap;\n         inline-size: 1px;\n        \"></div>\n      `;\n  }\n\n  // Hide listbox on focusout\n  static {\n    if (!isServer) {\n      document.addEventListener('focusout', event => {\n        const target = event.target as HTMLElement;\n        for (const host of ComboboxController.hosts) {\n          if (host instanceof Node && host.contains(target)) {\n            const instance = ComboboxController.instances.get(host);\n            instance?._onFocusoutElement();\n          }\n        }\n      });\n    }\n  }\n\n  private options: RequireProps<ComboboxControllerOptions<Item>,\n    | 'isItemDisabled'\n    | 'isItem'\n    | 'isItemFiltered'\n    | 'getItemValue'\n    | 'getOrientation'\n    | 'getComboboxValue'\n    | 'setComboboxValue'\n    | 'setItemHidden'\n  >;\n\n  #lb: ListboxController<Item>;\n  #fc?: ATFocusController<Item>;\n  #initializing = false;\n  #preventListboxGainingFocus = false;\n  #input: HTMLElement | null = null;\n  #button: HTMLElement | null = null;\n  #listbox: HTMLElement | null = null;\n  #buttonInitialRole: string | null = null;\n  #buttonHasMouseDown = false;\n  #mo = new MutationObserver(() => this.#initItems());\n  #microcopy = new Map<string, Record<Lang, string>>(Object.entries({\n    dimmed: {\n      en: 'dimmed',\n      es: 'atenuada',\n      de: 'gedimmt',\n      it: 'oscurato',\n      fr: 'attnu',\n      ja: '',\n      zh: '',\n    },\n    selected: {\n      en: 'selected',\n      es: 'seleccionado',\n      de: 'ausgewhlt',\n      fr: 'choisie',\n      it: 'selezionato',\n      ja: '',\n      zh: '',\n    },\n    of: {\n      en: 'of',\n      es: 'de',\n      de: 'von',\n      fr: 'sur',\n      it: 'di',\n      ja: '',\n      zh: '',\n    },\n  }));\n\n  /** All items */\n  get items(): Item[] {\n    return this.#lb.items;\n  }\n\n  set items(value: Item[]) {\n    this.#lb.items = value;\n    this.#fc?.initItems();\n  }\n\n  /** Whether the combobox is disabled */\n  get disabled() {\n    return this.#lb.disabled;\n  }\n\n  set disabled(value: boolean) {\n    this.#lb.disabled = value;\n  }\n\n  /** Whether multiselect is enabled */\n  get multi() {\n    return this.#lb.multi;\n  }\n\n  set multi(value: boolean) {\n    this.#lb.multi = value;\n  }\n\n  /** The current selection: a list of items */\n  get selected() {\n    return this.#lb.selected;\n  }\n\n  set selected(value: Item[]) {\n    this.#lb.selected = value;\n  }\n\n  get #hasTextInput() {\n    return this.options.getComboboxInput();\n  }\n\n  get #focusedItem() {\n    return this.#fc?.items.at(Math.max(this.#fc?.atFocusedItemIndex ?? -1, 0)) ?? null;\n  }\n\n  get #element() {\n    if (this.host instanceof HTMLElement) {\n      return this.host;\n    } else if (this.options.getListboxElement() instanceof HTMLElement) {\n      return this.options.getListboxElement();\n    }\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost & HTMLElement,\n    options: ComboboxControllerOptions<Item>,\n  ) {\n    host.addController(this);\n    this.options = {\n      isItem,\n      getItemValue,\n      isItemFiltered,\n      isItemDisabled,\n      getComboboxValue,\n      setComboboxValue,\n      setItemHidden,\n      getOrientation: () => 'vertical',\n      ...options,\n    };\n    this.#lb = ListboxController.of(host, {\n      isItem: this.options.isItem,\n      getItemsContainer: this.options.getListboxElement,\n      getControlsElements: () => [\n        this.options.getToggleButton(),\n        this.options.getComboboxInput(),\n      ].filter(x => !!x),\n      getATFocusedItem: () => this.items[this.#fc?.atFocusedItemIndex ?? -1] ?? null,\n      isItemDisabled: this.options.isItemDisabled,\n      setItemSelected: this.options.setItemSelected,\n    });\n    ComboboxController.instances.set(host, this);\n    ComboboxController.hosts.add(host);\n  }\n\n  async hostConnected(): Promise<void> {\n    await this.host.updateComplete;\n    this.hostUpdated();\n  }\n\n  hostUpdated(): void {\n    if (!this.#fc && !this.#initializing) {\n      this.#init();\n    }\n    const expanded = this.options.isExpanded();\n    this.#button?.setAttribute('aria-expanded', String(expanded));\n    this.#input?.setAttribute('aria-expanded', String(expanded));\n    this.#initLabels();\n  }\n\n  hostDisconnected(): void {\n    this.#fc?.hostDisconnected();\n  }\n\n  disconnect(): void {\n    ComboboxController.instances.delete(this.host);\n    ComboboxController.hosts.delete(this.host);\n  }\n\n  private async _onFocusoutElement(): Promise<void> {\n    if (this.#hasTextInput && this.options.isExpanded()) {\n      const root = this.#element?.getRootNode();\n      await new Promise(requestAnimationFrame);\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        const { activeElement } = root;\n        if (!this.#element?.contains(activeElement)) {\n          this.#hide();\n        }\n      }\n    }\n  }\n\n  /**\n   * Order of operations is important\n   */\n  async #init() {\n    this.#initializing = true;\n    await this.host.updateComplete;\n    this.#initListbox();\n    this.#initItems();\n    this.#initButton();\n    this.#initInput();\n    this.#initLabels();\n    this.#initController();\n    this.#initializing = false;\n  }\n\n  #initListbox() {\n    this.#mo.disconnect();\n    this.#listbox?.removeEventListener('focusout', this.#onFocusoutListbox);\n    this.#listbox?.removeEventListener('keydown', this.#onKeydownListbox);\n    this.#listbox?.removeEventListener('click', this.#onClickListbox);\n    this.#listbox = this.options.getListboxElement();\n    if (!this.#listbox) {\n      throw new Error('ComboboxController getListboxElement() option must return an element');\n    }\n    this.#listbox.addEventListener('focusout', this.#onFocusoutListbox);\n    this.#listbox.addEventListener('keydown', this.#onKeydownListbox);\n    this.#listbox.addEventListener('click', this.#onClickListbox);\n    this.#listbox.id ??= getRandomId();\n    this.#mo.observe(this.#listbox, { childList: true });\n  }\n\n  #initButton() {\n    this.#button?.removeEventListener('click', this.#onClickButton);\n    this.#button?.removeEventListener('keydown', this.#onKeydownButton);\n    this.#button?.removeEventListener('mousedown', this.#onMousedownButton);\n    this.#button?.removeEventListener('mouseup', this.#onMouseupButton);\n    this.#button = this.options.getToggleButton();\n    if (!this.#button) {\n      throw new Error('ComboboxController getToggleButton() option must return an element');\n    }\n    this.#buttonInitialRole = this.#button.role;\n    this.#button.role = 'combobox';\n    this.#button.setAttribute('aria-controls', this.#listbox?.id ?? '');\n    this.#button.addEventListener('click', this.#onClickButton);\n    this.#button.addEventListener('keydown', this.#onKeydownButton);\n    this.#button.addEventListener('mousedown', this.#onMousedownButton);\n    this.#button.addEventListener('mouseup', this.#onMouseupButton);\n  }\n\n  #initInput() {\n    this.#input?.removeEventListener('click', this.#onClickButton);\n    this.#input?.removeEventListener('keyup', this.#onKeyupInput);\n    this.#input?.removeEventListener('keydown', this.#onKeydownInput);\n\n    this.#input = this.options.getComboboxInput();\n    if (this.#input && !('value' in this.#input)) {\n      throw new Error(`ComboboxController getToggleInput() option must return an element with a value property`);\n    } else if (this.#input) {\n      this.#input.role = 'combobox';\n      this.#button!.role = this.#buttonInitialRole;\n      this.#input.setAttribute('aria-autocomplete', 'both');\n      this.#input.setAttribute('aria-controls', this.#listbox?.id ?? '');\n      this.#input.addEventListener('click', this.#onClickButton);\n      this.#input.addEventListener('keyup', this.#onKeyupInput);\n      this.#input.addEventListener('keydown', this.#onKeydownInput);\n    }\n  }\n\n  #initLabels() {\n    const labels = InternalsController.getLabels(this.host)\n                ?? this.#element?.ariaLabelledByElements\n                ?? [];\n    const label = this.options.getFallbackLabel()\n                  || this.#element?.ariaLabelledByElements?.map(x => x.textContent).join('')\n                  || null;\n\n    for (const element of [this.#button, this.#listbox, this.#input].filter(x => !!x)) {\n      if ('ariaLabelledByElements' in HTMLElement.prototype && labels.filter(x => !!x).length) {\n        element.ariaLabelledByElements = [...labels ?? []];\n      } else {\n        element.ariaLabel = label;\n      }\n    }\n  }\n\n  #initController() {\n    this.#fc?.hostDisconnected();\n    const { getOrientation } = this.options;\n    const getItems = () => this.items;\n    const getItemsContainer = () => this.#listbox;\n    if (this.#hasTextInput) {\n      this.#fc = ActivedescendantController.of(this.host, {\n        getItems, getItemsContainer, getOrientation,\n        getActiveDescendantContainer: () => this.#input,\n        getControlsElements: () => [\n          this.options.getToggleButton(),\n          this.options.getComboboxInput(),\n        ].filter(x => !!x),\n        setItemActive: this.options.setItemActive,\n      });\n    } else {\n      this.#fc = RovingTabindexController.of(this.host, {\n        getItems, getItemsContainer, getOrientation,\n        getControlsElements: () => [\n          this.options.getToggleButton(),\n        ].filter(x => !!x),\n      });\n    }\n  }\n\n  #initItems() {\n    if (this.#listbox) {\n      this.items = this.options.getItems();\n    }\n  }\n\n  async #show(): Promise<void> {\n    // Re-read items on open so slotted/dynamically added options are included:\n    this.#initItems();\n    const success = await this.options.requestShowListbox();\n    this.#filterItems();\n    if (success !== false && !this.#hasTextInput) {\n      if (!this.#preventListboxGainingFocus) {\n        (this.#focusedItem ?? this.#fc?.items.at(0))?.focus();\n        this.#preventListboxGainingFocus = false;\n      }\n    }\n  }\n\n  async #hide(): Promise<void> {\n    await this.options.requestHideListbox();\n  }\n\n  async #toggle() {\n    if (this.options.isExpanded()) {\n      return this.#hide();\n    } else {\n      return this.#show();\n    }\n  }\n\n  #translate(key: string, lang: Lang) {\n    const strings = this.#microcopy.get(key);\n    return strings?.[lang] ?? key;\n  }\n\n  /**\n   * Announces the focused item to a live region (e.g. for Safari VoiceOver).\n   * @param item - The listbox option item to announce.\n   * TODO(bennypowers): perhaps move this to ActivedescendantController\n */\n  #announce(item: Item): void {\n    const value = this.options.getItemValue(item);\n    ComboboxController.#alert?.remove();\n    const fragment = ComboboxController.#alertTemplate.content.cloneNode(true) as DocumentFragment;\n    ComboboxController.#alert = fragment.firstElementChild as HTMLElement;\n    let text = value;\n    const lang = deepClosest(this.#listbox, '[lang]')?.getAttribute('lang') ?? 'en';\n    const langKey = (lang?.match(ComboboxController.langsRE)?.at(0) as Lang) ?? 'en';\n    if (this.options.isItemDisabled(item)) {\n      text += ` (${this.#translate('dimmed', langKey)})`;\n    }\n    if (this.#lb.isSelected(item)) {\n      text += `, (${this.#translate('selected', langKey)})`;\n    }\n    const posInSet = InternalsController.getAriaPosInSet(item);\n    const setSize = InternalsController.getAriaSetSize(item);\n    if (posInSet != null && setSize != null) {\n      if (langKey === 'ja') {\n        text += `, (${setSize}  ${posInSet} )`;\n      } else {\n        text += `, (${posInSet} ${this.#translate('of', langKey)} ${setSize})`;\n      }\n    }\n    ComboboxController.#alert.lang = lang;\n    ComboboxController.#alert.innerText = text;\n    document.body.append(ComboboxController.#alert);\n  }\n\n  #filterItems() {\n    if (this.#input) {\n      let value: string;\n      for (const item of this.items) {\n        const hidden =\n          !!this.options.isExpanded()\n            && !!(value = this.options.getComboboxValue(this.#input))\n            && this.options.isItemFiltered?.(item, value)\n            || false;\n        this.options.setItemHidden(item, hidden);\n      }\n    }\n  }\n\n  #onClickButton = () => {\n    if (!this.options.isExpanded()) {\n      this.#show();\n    } else {\n      this.#hide();\n    }\n  };\n\n  /**\n   * Distinguish click-to-toggle vs Tab/Shift+Tab\n  */\n  #onMousedownButton = () => {\n    this.#buttonHasMouseDown = true;\n  };\n\n  #onMouseupButton = () => {\n    this.#buttonHasMouseDown = false;\n  };\n\n  #onClickListbox = (event: MouseEvent) => {\n    if (!this.multi && event.composedPath().some(this.options.isItem)) {\n      this.#hide();\n    }\n  };\n\n  /**\n   * Handle keypresses on the input\n   * ## `Down Arrow`\n   * - If the textbox is not empty and the listbox is displayed,\n   *   moves visual focus to the first suggested value.\n   * - If the textbox is empty and the listbox is not displayed,\n   *   opens the listbox and moves visual focus to the first option.\n   * - In both cases DOM focus remains on the textbox.\n   *\n   * ## `Alt + Down Arrow`\n   * Opens the listbox without moving focus or changing selection.\n   *\n   * ## `Up Arrow`\n   * - If the textbox is not empty and the listbox is displayed,\n   *   moves visual focus to the last suggested value.\n   * - If the textbox is empty, first opens the listbox if it is not already displayed\n   *   and then moves visual focus to the last option.\n   * - In both cases DOM focus remains on the textbox.\n   *\n   * ## `Enter`\n   * Closes the listbox if it is displayed.\n   *\n   * ## `Escape`\n   * - If the listbox is displayed, closes it.\n   * - If the listbox is not displayed, clears the textbox.\n   *\n   * ## Standard single line text editing keys\n   * - Keys used for cursor movement and text manipulation,\n   *   such as `Delete` and `Shift + Right Arrow`.\n   * - An HTML `input` with `type=\"text\"` is used for the textbox so the browser will provide\n   *   platform-specific editing keys.\n   *\n   * @see https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list\n   * @param event keydown event\n   */\n  #onKeydownInput = (event: KeyboardEvent) => {\n    if (event.ctrlKey || event.shiftKey || !this.#input) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n        if (!this.options.isExpanded()) {\n          this.#preventListboxGainingFocus = event.altKey;\n          this.#show();\n        }\n        break;\n      case 'Enter':\n        if (!this.multi) {\n          this.#hide();\n        }\n        break;\n      case 'Escape':\n        if (!this.options.isExpanded()) {\n          this.options.setComboboxValue(this.#input, '');\n          this.host.requestUpdate();\n        }\n        this.#hide();\n        break;\n      case 'Alt':\n      case 'AltGraph':\n      case 'Shift':\n      case 'Control':\n      case 'Fn':\n      case 'Symbol':\n      case 'Hyper':\n      case 'Super':\n      case 'Meta':\n      case 'CapsLock':\n      case 'FnLock':\n      case 'NumLock':\n      case 'Tab':\n      case 'ScrollLock':\n      case 'SymbolLock':\n      case ' ':\n        break;\n      default:\n        if (!this.options.isExpanded()) {\n          this.#show();\n        }\n    }\n  };\n\n  /**\n   * Populates the combobox input with the focused value when navigating the listbox,\n   * and filters the items when typing.\n   * @param event keyup event\n   */\n  #onKeyupInput = (event: KeyboardEvent) => {\n    if (!this.#input) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n        /**\n         * Safari VoiceOver does not support aria-activedescendant, so we must.\n         * approximate the correct behaviour by constructing a visually-hidden alert role\n         * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)\n         */\n        if (this.#focusedItem\n            && this.options.getComboboxInput()\n            && InternalsController.isSafari) {\n          this.#announce(this.#focusedItem);\n        }\n        break;\n      default:\n        this.#filterItems();\n    }\n  };\n\n  #onKeydownButton = (event: KeyboardEvent) => {\n    if (this.#hasTextInput) {\n      return this.#onKeydownInput(event);\n    } else {\n      return this.#onKeydownToggleButton(event);\n    }\n  };\n\n  #onKeydownListbox = (event: KeyboardEvent) => {\n    if (!this.#hasTextInput) {\n      switch (event.key) {\n        case 'Home':\n        case 'End':\n          this.#onKeydownToggleButton(event);\n          break;\n        case 'Escape':\n          this.#hide();\n          this.#button?.focus();\n          break;\n        case 'Enter':\n        case ' ': {\n          const eventItem = event.composedPath().find(this.options.isItem);\n          if (eventItem\n              && !this.multi\n              && this.options.isExpanded()\n              && !this.options.isItemDisabled(eventItem)\n          ) {\n            this.#hide();\n            this.#button?.focus();\n          }\n        }\n      }\n    }\n  };\n\n  #onFocusoutListbox = (event: FocusEvent) => {\n    if (!this.#hasTextInput && this.options.isExpanded()) {\n      const root = this.#element?.getRootNode();\n      // Check if focus moved to the toggle button via mouse click\n      // If so, let the click handler manage toggle (prevents double-toggle)\n      // But if focus moved via Shift+Tab (no mousedown), we should still hide\n      const isClickOnToggleButton =\n          event.relatedTarget === this.#button && this.#buttonHasMouseDown;\n      if ((root instanceof ShadowRoot || root instanceof Document)\n          && !this.items.includes(event.relatedTarget as Item)\n          && !isClickOnToggleButton) {\n        this.#hide();\n      }\n    }\n  };\n\n  #onKeydownToggleButton = async (event: KeyboardEvent) => {\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n        if (!this.options.isExpanded()) {\n          this.#show();\n        }\n        break;\n      case 'Home':\n        if (!this.options.isExpanded()) {\n          await this.#show();\n        }\n        if (this.#fc) {\n          this.#fc.atFocusedItemIndex = 0;\n        }\n        break;\n      case 'End':\n        if (!this.options.isExpanded()) {\n          await this.#show();\n        }\n        if (this.#fc) {\n          this.#fc.atFocusedItemIndex = this.items.length - 1;\n        }\n        break;\n      case ' ':\n      case 'Enter':\n        // prevent scroll\n        event.preventDefault();\n        await this.#toggle();\n        await this.host.updateComplete;\n        if (!this.options.isExpanded()) {\n          this.#button?.focus();\n        }\n        break;\n    }\n  };\n\n  /**\n   * For Browsers which do not support `ariaActiveDescendantElement`, we must clone\n   * the listbox items into the same root as the combobox input\n   * Call this method to return either an array of (cloned) list box items, to be placed in your\n   * shadow template, or nothing in the case the browser supports cross-root aria.\n   */\n  public renderItemsToShadowRoot(): Node[] | typeof nothing {\n    if (this.#fc instanceof ActivedescendantController) {\n      return this.#fc.renderItemsToShadowRoot();\n    } else {\n      return nothing;\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/combobox-controller.ts b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.ts
new file mode 100644
index 0000000..12cb5a8
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/combobox-controller.ts
@@ -0,0 +1,829 @@
+import { isServer, nothing, type ReactiveController, type ReactiveControllerHost } from 'lit';
+import type { ActivedescendantControllerOptions } from './activedescendant-controller.js';
+import type { RovingTabindexControllerOptions } from './roving-tabindex-controller.js';
+import type { ATFocusController } from './at-focus-controller.js';
+import type { ListboxControllerOptions } from './listbox-controller.js';
+
+import { ListboxController, isItem, isItemDisabled } from './listbox-controller.js';
+import { RovingTabindexController } from './roving-tabindex-controller.js';
+import { ActivedescendantController } from './activedescendant-controller.js';
+import { InternalsController } from './internals-controller.js';
+import { getRandomId } from '../functions/random.js';
+import type { RequireProps } from '../core.js';
+
+type AllOptions<Item extends HTMLElement> =
+    ActivedescendantControllerOptions<Item>
+  & ListboxControllerOptions<Item>
+  & RovingTabindexControllerOptions<Item>;
+
+type Lang = typeof ComboboxController['langs'][number];
+
+function deepClosest(element: Element | null, selector: string) {
+  let closest = element?.closest(selector);
+  let root = element?.getRootNode();
+  let count = 0;
+  while (count < 500 && !closest && element) {
+    count++;
+    root = element.getRootNode();
+    if (root instanceof ShadowRoot) {
+      element = root.host;
+    } else if (root instanceof Document) {
+      element = document.documentElement;
+    } else {
+      return null;
+    }
+    closest = element.closest(selector);
+  }
+  return closest;
+}
+
+function getItemValue<Item extends HTMLElement>(item: Item): string {
+  if ('value' in item && typeof item.value === 'string') {
+    return item.value;
+  } else {
+    return '';
+  }
+}
+
+function isItemFiltered<Item extends HTMLElement>(item: Item, value: string): boolean {
+  return !getItemValue(item)
+      .toLowerCase()
+      .startsWith(value.toLowerCase());
+}
+
+function setItemHidden(item: HTMLElement, hidden: boolean) {
+  item.hidden = hidden;
+}
+
+function setComboboxValue(item: HTMLElement, value: string): void {
+  if (!('value' in item)) {
+    // eslint-disable-next-line no-console
+    return console.warn(`Cannot set value on combobox element ${item.localName}`);
+  } else {
+    item.value = value;
+  }
+}
+
+function getComboboxValue(combobox: HTMLElement): string {
+  if ('value' in combobox && typeof combobox.value === 'string') {
+    return combobox.value;
+  } else {
+    // eslint-disable-next-line no-console
+    return console.warn(`Cannot get value from combobox element ${combobox.localName}`), '';
+  }
+}
+
+export interface ComboboxControllerOptions<Item extends HTMLElement> extends
+  Omit<AllOptions<Item>,
+    | 'getATFocusedItem'
+    | 'getControlsElements'
+    | 'getActiveDescendantContainer'
+    | 'getItemsContainer'> {
+  /**
+   * Predicate which establishes whether the listbox is expanded
+   * e.g. `isExpanded: () => this.expanded`, if the host's `expanded` property
+   * should correspond to the listbox expanded state.
+   */
+  isExpanded(): boolean;
+  /**
+   * Callback which the host must implement to change the expanded state to true.
+   * Return or resolve false to prevent the change.
+   */
+  requestShowListbox(): void | boolean | Promise<boolean> | Promise<void>;
+  /**
+   * Callback which the host must implement to change the expanded to false.
+   * Return or resolve false to prevent the default.
+   */
+  requestHideListbox(): void | boolean | Promise<boolean> | Promise<void>;
+  /**
+   * Returns the listbox container element
+   */
+  getListboxElement(): HTMLElement | null;
+  /**
+   * Returns the toggle button, if it exists
+   */
+  getToggleButton(): HTMLElement | null;
+  /**
+   * Returns the combobox input, if it exists
+   */
+  getComboboxInput(): HTMLElement | null;
+  /**
+   * Returns the label for the toggle button, combobox input, and listbox.
+   * when `ariaLabelledByElements` is supported, the label elements associated with
+   * the host element are used instead, and this value is ignored.
+   */
+  getFallbackLabel(): string;
+  /**
+   * Called on an item to retrieve it's value string. By default, returns the `value` property
+   * of the item, as if it implemented the `<option>` element's interface.
+   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement
+   */
+  getItemValue?(item: Item): string;
+  /**
+   * Optional callback, called on the combobox input element to set its value.
+   * by default, returns the element's `value` DOM property.
+   */
+  getComboboxValue?(combobox: HTMLElement): string;
+  /**
+   * Optional callback, called on the combobox input element to set its value.
+   * by default, sets the element's `value` DOM property.
+   */
+  setComboboxValue?(item: HTMLElement, value: string): void;
+  /**
+   * Called on each item, with the combobox input, to determine if the item should be shown in the
+   * listbox or filtered out. Return false to hide the item. By default, checks whether the item's
+   * value starts with the input value (when both are lowercased).
+   */
+  isItemFiltered?(item: Item, value: string): boolean;
+  /**
+   * Called on each item when the filter changes.
+   * By default, toggles the `hidden` attribute on the item
+   */
+  setItemHidden?(item: Item, hidden: boolean): void;
+}
+
+/**
+ * @summary Implements the WAI-ARIA pattern [Editable Combobox with Both List and Inline Autocomplete].
+ *
+ * Combobox with keyboard and pointer navigation, using the aria-activedescendant pattern.
+ *
+ * WARNING: Safari VoiceOver does not support aria-activedescendant, so Safari users
+ * rely on the combobox input value being announced when navigating the listbox with the keyboard.
+ * We have erred on the side that it may be less-broken to avoid announcing disabled items in that
+ * case, rather than announcing the disabled items value without indicating that it is disabled.
+ * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)
+ *
+ * [pattern]: https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-both/
+ */
+export class ComboboxController<
+  Item extends HTMLElement
+> implements ReactiveController {
+  public static of<T extends HTMLElement>(
+    host: ReactiveControllerHost & HTMLElement,
+    options: ComboboxControllerOptions<T>,
+  ): ComboboxController<T> {
+    return new ComboboxController(host, options);
+  }
+
+  /**
+   * Whether the `ariaActiveDescendantElement` IDL attribute is supported for cross-root ARIA.
+   */
+  public static get supportsCrossRootActiveDescendant(): boolean {
+    return ActivedescendantController.supportsCrossRootActiveDescendant;
+  }
+
+  static #alert?: HTMLElement;
+
+  static #alertTemplate = document.createElement('template');
+
+  private static langs = [
+    'en',
+    'es',
+    'de',
+    'fr',
+    'it',
+    'ja',
+    'zh',
+  ] as const;
+
+  private static langsRE = new RegExp(ComboboxController.langs.join('|'));
+
+  private static instances = new WeakMap<ReactiveControllerHost, ComboboxController<HTMLElement>>();
+
+  private static hosts = new Set<ReactiveControllerHost>();
+
+  static {
+    // apply visually-hidden styles
+    this.#alertTemplate.innerHTML = `
+      <div role="alert" style="
+         border: 0;
+         clip: rect(0, 0, 0, 0);
+         block-size: 1px;
+         margin: -1px;
+         overflow: hidden;
+         padding: 0;
+         position: absolute;
+         white-space: nowrap;
+         inline-size: 1px;
+        "></div>
+      `;
+  }
+
+  // Hide listbox on focusout
+  static {
+    if (!isServer) {
+      document.addEventListener('focusout', event => {
+        const target = event.target as HTMLElement;
+        for (const host of ComboboxController.hosts) {
+          if (host instanceof Node && host.contains(target)) {
+            const instance = ComboboxController.instances.get(host);
+            instance?._onFocusoutElement();
+          }
+        }
+      });
+    }
+  }
+
+  private options: RequireProps<ComboboxControllerOptions<Item>,
+    | 'isItemDisabled'
+    | 'isItem'
+    | 'isItemFiltered'
+    | 'getItemValue'
+    | 'getOrientation'
+    | 'getComboboxValue'
+    | 'setComboboxValue'
+    | 'setItemHidden'
+  >;
+
+  #lb: ListboxController<Item>;
+  #fc?: ATFocusController<Item>;
+  #initializing = false;
+  #preventListboxGainingFocus = false;
+  #input: HTMLElement | null = null;
+  #button: HTMLElement | null = null;
+  #listbox: HTMLElement | null = null;
+  #buttonInitialRole: string | null = null;
+  #buttonHasMouseDown = false;
+  #mo = new MutationObserver(() => this.#initItems());
+  #microcopy = new Map<string, Record<Lang, string>>(Object.entries({
+    dimmed: {
+      en: 'dimmed',
+      es: 'atenuada',
+      de: 'gedimmt',
+      it: 'oscurato',
+      fr: 'attnu',
+      ja: '',
+      zh: '',
+    },
+    selected: {
+      en: 'selected',
+      es: 'seleccionado',
+      de: 'ausgewhlt',
+      fr: 'choisie',
+      it: 'selezionato',
+      ja: '',
+      zh: '',
+    },
+    of: {
+      en: 'of',
+      es: 'de',
+      de: 'von',
+      fr: 'sur',
+      it: 'di',
+      ja: '',
+      zh: '',
+    },
+  }));
+
+  /** All items */
+  get items(): Item[] {
+    return this.#lb.items;
+  }
+
+  set items(value: Item[]) {
+    this.#lb.items = value;
+    this.#fc?.initItems();
+  }
+
+  /** Whether the combobox is disabled */
+  get disabled() {
+    return this.#lb.disabled;
+  }
+
+  set disabled(value: boolean) {
+    this.#lb.disabled = value;
+  }
+
+  /** Whether multiselect is enabled */
+  get multi() {
+    return this.#lb.multi;
+  }
+
+  set multi(value: boolean) {
+    this.#lb.multi = value;
+  }
+
+  /** The current selection: a list of items */
+  get selected() {
+    return this.#lb.selected;
+  }
+
+  set selected(value: Item[]) {
+    this.#lb.selected = value;
+  }
+
+  get #hasTextInput() {
+    return this.options.getComboboxInput();
+  }
+
+  get #focusedItem() {
+    return this.#fc?.items.at(Math.max(this.#fc?.atFocusedItemIndex ?? -1, 0)) ?? null;
+  }
+
+  get #element() {
+    if (this.host instanceof HTMLElement) {
+      return this.host;
+    } else if (this.options.getListboxElement() instanceof HTMLElement) {
+      return this.options.getListboxElement();
+    }
+  }
+
+  private constructor(
+    public host: ReactiveControllerHost & HTMLElement,
+    options: ComboboxControllerOptions<Item>,
+  ) {
+    host.addController(this);
+    this.options = {
+      isItem,
+      getItemValue,
+      isItemFiltered,
+      isItemDisabled,
+      getComboboxValue,
+      setComboboxValue,
+      setItemHidden,
+      getOrientation: () => 'vertical',
+      ...options,
+    };
+    this.#lb = ListboxController.of(host, {
+      isItem: this.options.isItem,
+      getItemsContainer: this.options.getListboxElement,
+      getControlsElements: () => [
+        this.options.getToggleButton(),
+        this.options.getComboboxInput(),
+      ].filter(x => !!x),
+      getATFocusedItem: () => this.items[this.#fc?.atFocusedItemIndex ?? -1] ?? null,
+      isItemDisabled: this.options.isItemDisabled,
+      setItemSelected: this.options.setItemSelected,
+    });
+    ComboboxController.instances.set(host, this);
+    ComboboxController.hosts.add(host);
+  }
+
+  async hostConnected(): Promise<void> {
+    await this.host.updateComplete;
+    this.hostUpdated();
+  }
+
+  hostUpdated(): void {
+    if (!this.#fc && !this.#initializing) {
+      this.#init();
+    }
+    const expanded = this.options.isExpanded();
+    this.#button?.setAttribute('aria-expanded', String(expanded));
+    this.#input?.setAttribute('aria-expanded', String(expanded));
+    this.#initLabels();
+  }
+
+  hostDisconnected(): void {
+    this.#fc?.hostDisconnected();
+  }
+
+  disconnect(): void {
+    ComboboxController.instances.delete(this.host);
+    ComboboxController.hosts.delete(this.host);
+  }
+
+  private async _onFocusoutElement(): Promise<void> {
+    if (this.#hasTextInput && this.options.isExpanded()) {
+      const root = this.#element?.getRootNode();
+      await new Promise(requestAnimationFrame);
+      if (root instanceof ShadowRoot || root instanceof Document) {
+        const { activeElement } = root;
+        if (!this.#element?.contains(activeElement)) {
+          this.#hide();
+        }
+      }
+    }
+  }
+
+  /**
+   * Order of operations is important
+   */
+  async #init() {
+    this.#initializing = true;
+    await this.host.updateComplete;
+    this.#initListbox();
+    this.#initItems();
+    this.#initButton();
+    this.#initInput();
+    this.#initLabels();
+    this.#initController();
+    this.#initializing = false;
+  }
+
+  #initListbox() {
+    this.#mo.disconnect();
+    this.#listbox?.removeEventListener('focusout', this.#onFocusoutListbox);
+    this.#listbox?.removeEventListener('keydown', this.#onKeydownListbox);
+    this.#listbox?.removeEventListener('click', this.#onClickListbox);
+    this.#listbox = this.options.getListboxElement();
+    if (!this.#listbox) {
+      throw new Error('ComboboxController getListboxElement() option must return an element');
+    }
+    this.#listbox.addEventListener('focusout', this.#onFocusoutListbox);
+    this.#listbox.addEventListener('keydown', this.#onKeydownListbox);
+    this.#listbox.addEventListener('click', this.#onClickListbox);
+    this.#listbox.id ??= getRandomId();
+    this.#mo.observe(this.#listbox, { childList: true });
+  }
+
+  #initButton() {
+    this.#button?.removeEventListener('click', this.#onClickButton);
+    this.#button?.removeEventListener('keydown', this.#onKeydownButton);
+    this.#button?.removeEventListener('mousedown', this.#onMousedownButton);
+    this.#button?.removeEventListener('mouseup', this.#onMouseupButton);
+    this.#button = this.options.getToggleButton();
+    if (!this.#button) {
+      throw new Error('ComboboxController getToggleButton() option must return an element');
+    }
+    this.#buttonInitialRole = this.#button.role;
+    this.#button.role = 'combobox';
+    this.#button.setAttribute('aria-controls', this.#listbox?.id ?? '');
+    this.#button.addEventListener('click', this.#onClickButton);
+    this.#button.addEventListener('keydown', this.#onKeydownButton);
+    this.#button.addEventListener('mousedown', this.#onMousedownButton);
+    this.#button.addEventListener('mouseup', this.#onMouseupButton);
+  }
+
+  #initInput() {
+    this.#input?.removeEventListener('click', this.#onClickButton);
+    this.#input?.removeEventListener('keyup', this.#onKeyupInput);
+    this.#input?.removeEventListener('keydown', this.#onKeydownInput);
+
+    this.#input = this.options.getComboboxInput();
+    if (this.#input && !('value' in this.#input)) {
+      throw new Error(`ComboboxController getToggleInput() option must return an element with a value property`);
+    } else if (this.#input) {
+      this.#input.role = 'combobox';
+      this.#button!.role = this.#buttonInitialRole;
+      this.#input.setAttribute('aria-autocomplete', 'both');
+      this.#input.setAttribute('aria-controls', this.#listbox?.id ?? '');
+      this.#input.addEventListener('click', this.#onClickButton);
+      this.#input.addEventListener('keyup', this.#onKeyupInput);
+      this.#input.addEventListener('keydown', this.#onKeydownInput);
+    }
+  }
+
+  #initLabels() {
+    const labels = InternalsController.getLabels(this.host)
+                ?? this.#element?.ariaLabelledByElements
+                ?? [];
+    const label = this.options.getFallbackLabel()
+                  || this.#element?.ariaLabelledByElements?.map(x => x.textContent).join('')
+                  || null;
+
+    for (const element of [this.#button, this.#listbox, this.#input].filter(x => !!x)) {
+      if ('ariaLabelledByElements' in HTMLElement.prototype && labels.filter(x => !!x).length) {
+        element.ariaLabelledByElements = [...labels ?? []];
+      } else {
+        element.ariaLabel = label;
+      }
+    }
+  }
+
+  #initController() {
+    this.#fc?.hostDisconnected();
+    const { getOrientation } = this.options;
+    const getItems = () => this.items;
+    const getItemsContainer = () => this.#listbox;
+    if (this.#hasTextInput) {
+      this.#fc = ActivedescendantController.of(this.host, {
+        getItems, getItemsContainer, getOrientation,
+        getActiveDescendantContainer: () => this.#input,
+        getControlsElements: () => [
+          this.options.getToggleButton(),
+          this.options.getComboboxInput(),
+        ].filter(x => !!x),
+        setItemActive: this.options.setItemActive,
+      });
+    } else {
+      this.#fc = RovingTabindexController.of(this.host, {
+        getItems, getItemsContainer, getOrientation,
+        getControlsElements: () => [
+          this.options.getToggleButton(),
+        ].filter(x => !!x),
+      });
+    }
+  }
+
+  #initItems() {
+    if (this.#listbox) {
+      this.items = this.options.getItems();
+    }
+  }
+
+  async #show(): Promise<void> {
+    // Re-read items on open so slotted/dynamically added options are included:
+    this.#initItems();
+    const success = await this.options.requestShowListbox();
+    this.#filterItems();
+    if (success !== false && !this.#hasTextInput) {
+      if (!this.#preventListboxGainingFocus) {
+        (this.#focusedItem ?? this.#fc?.items.at(0))?.focus();
+        this.#preventListboxGainingFocus = false;
+      }
+    }
+  }
+
+  async #hide(): Promise<void> {
+    await this.options.requestHideListbox();
+  }
+
+  async #toggle() {
+    if (this.options.isExpanded()) {
+      return this.#hide();
+    } else {
+      return this.#show();
+    }
+  }
+
+  #translate(key: string, lang: Lang) {
+    const strings = this.#microcopy.get(key);
+    return strings?.[lang] ?? key;
+  }
+
+  /**
+   * Announces the focused item to a live region (e.g. for Safari VoiceOver).
+   * @param item - The listbox option item to announce.
+   * TODO(bennypowers): perhaps move this to ActivedescendantController
+ */
+  #announce(item: Item): void {
+    const value = this.options.getItemValue(item);
+    ComboboxController.#alert?.remove();
+    const fragment = ComboboxController.#alertTemplate.content.cloneNode(true) as DocumentFragment;
+    ComboboxController.#alert = fragment.firstElementChild as HTMLElement;
+    let text = value;
+    const lang = deepClosest(this.#listbox, '[lang]')?.getAttribute('lang') ?? 'en';
+    const langKey = (lang?.match(ComboboxController.langsRE)?.at(0) as Lang) ?? 'en';
+    if (this.options.isItemDisabled(item)) {
+      text += ` (${this.#translate('dimmed', langKey)})`;
+    }
+    if (this.#lb.isSelected(item)) {
+      text += `, (${this.#translate('selected', langKey)})`;
+    }
+    const posInSet = InternalsController.getAriaPosInSet(item);
+    const setSize = InternalsController.getAriaSetSize(item);
+    if (posInSet != null && setSize != null) {
+      if (langKey === 'ja') {
+        text += `, (${setSize}  ${posInSet} )`;
+      } else {
+        text += `, (${posInSet} ${this.#translate('of', langKey)} ${setSize})`;
+      }
+    }
+    ComboboxController.#alert.lang = lang;
+    ComboboxController.#alert.innerText = text;
+    document.body.append(ComboboxController.#alert);
+  }
+
+  #filterItems() {
+    if (this.#input) {
+      let value: string;
+      for (const item of this.items) {
+        const hidden =
+          !!this.options.isExpanded()
+            && !!(value = this.options.getComboboxValue(this.#input))
+            && this.options.isItemFiltered?.(item, value)
+            || false;
+        this.options.setItemHidden(item, hidden);
+      }
+    }
+  }
+
+  #onClickButton = () => {
+    if (!this.options.isExpanded()) {
+      this.#show();
+    } else {
+      this.#hide();
+    }
+  };
+
+  /**
+   * Distinguish click-to-toggle vs Tab/Shift+Tab
+  */
+  #onMousedownButton = () => {
+    this.#buttonHasMouseDown = true;
+  };
+
+  #onMouseupButton = () => {
+    this.#buttonHasMouseDown = false;
+  };
+
+  #onClickListbox = (event: MouseEvent) => {
+    if (!this.multi && event.composedPath().some(this.options.isItem)) {
+      this.#hide();
+    }
+  };
+
+  /**
+   * Handle keypresses on the input
+   * ## `Down Arrow`
+   * - If the textbox is not empty and the listbox is displayed,
+   *   moves visual focus to the first suggested value.
+   * - If the textbox is empty and the listbox is not displayed,
+   *   opens the listbox and moves visual focus to the first option.
+   * - In both cases DOM focus remains on the textbox.
+   *
+   * ## `Alt + Down Arrow`
+   * Opens the listbox without moving focus or changing selection.
+   *
+   * ## `Up Arrow`
+   * - If the textbox is not empty and the listbox is displayed,
+   *   moves visual focus to the last suggested value.
+   * - If the textbox is empty, first opens the listbox if it is not already displayed
+   *   and then moves visual focus to the last option.
+   * - In both cases DOM focus remains on the textbox.
+   *
+   * ## `Enter`
+   * Closes the listbox if it is displayed.
+   *
+   * ## `Escape`
+   * - If the listbox is displayed, closes it.
+   * - If the listbox is not displayed, clears the textbox.
+   *
+   * ## Standard single line text editing keys
+   * - Keys used for cursor movement and text manipulation,
+   *   such as `Delete` and `Shift + Right Arrow`.
+   * - An HTML `input` with `type="text"` is used for the textbox so the browser will provide
+   *   platform-specific editing keys.
+   *
+   * @see https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list
+   * @param event keydown event
+   */
+  #onKeydownInput = (event: KeyboardEvent) => {
+    if (event.ctrlKey || event.shiftKey || !this.#input) {
+      return;
+    }
+    switch (event.key) {
+      case 'ArrowDown':
+      case 'ArrowUp':
+        if (!this.options.isExpanded()) {
+          this.#preventListboxGainingFocus = event.altKey;
+          this.#show();
+        }
+        break;
+      case 'Enter':
+        if (!this.multi) {
+          this.#hide();
+        }
+        break;
+      case 'Escape':
+        if (!this.options.isExpanded()) {
+          this.options.setComboboxValue(this.#input, '');
+          this.host.requestUpdate();
+        }
+        this.#hide();
+        break;
+      case 'Alt':
+      case 'AltGraph':
+      case 'Shift':
+      case 'Control':
+      case 'Fn':
+      case 'Symbol':
+      case 'Hyper':
+      case 'Super':
+      case 'Meta':
+      case 'CapsLock':
+      case 'FnLock':
+      case 'NumLock':
+      case 'Tab':
+      case 'ScrollLock':
+      case 'SymbolLock':
+      case ' ':
+        break;
+      default:
+        if (!this.options.isExpanded()) {
+          this.#show();
+        }
+    }
+  };
+
+  /**
+   * Populates the combobox input with the focused value when navigating the listbox,
+   * and filters the items when typing.
+   * @param event keyup event
+   */
+  #onKeyupInput = (event: KeyboardEvent) => {
+    if (!this.#input) {
+      return;
+    }
+    switch (event.key) {
+      case 'ArrowUp':
+      case 'ArrowDown':
+        /**
+         * Safari VoiceOver does not support aria-activedescendant, so we must.
+         * approximate the correct behaviour by constructing a visually-hidden alert role
+         * @see (https://bugs.webkit.org/show_bug.cgi?id=269026)
+         */
+        if (this.#focusedItem
+            && this.options.getComboboxInput()
+            && InternalsController.isSafari) {
+          this.#announce(this.#focusedItem);
+        }
+        break;
+      default:
+        this.#filterItems();
+    }
+  };
+
+  #onKeydownButton = (event: KeyboardEvent) => {
+    if (this.#hasTextInput) {
+      return this.#onKeydownInput(event);
+    } else {
+      return this.#onKeydownToggleButton(event);
+    }
+  };
+
+  #onKeydownListbox = (event: KeyboardEvent) => {
+    if (!this.#hasTextInput) {
+      switch (event.key) {
+        case 'Home':
+        case 'End':
+          this.#onKeydownToggleButton(event);
+          break;
+        case 'Escape':
+          this.#hide();
+          this.#button?.focus();
+          break;
+        case 'Enter':
+        case ' ': {
+          const eventItem = event.composedPath().find(this.options.isItem);
+          if (eventItem
+              && !this.multi
+              && this.options.isExpanded()
+              && !this.options.isItemDisabled(eventItem)
+          ) {
+            this.#hide();
+            this.#button?.focus();
+          }
+        }
+      }
+    }
+  };
+
+  #onFocusoutListbox = (event: FocusEvent) => {
+    if (!this.#hasTextInput && this.options.isExpanded()) {
+      const root = this.#element?.getRootNode();
+      // Check if focus moved to the toggle button via mouse click
+      // If so, let the click handler manage toggle (prevents double-toggle)
+      // But if focus moved via Shift+Tab (no mousedown), we should still hide
+      const isClickOnToggleButton =
+          event.relatedTarget === this.#button && this.#buttonHasMouseDown;
+      if ((root instanceof ShadowRoot || root instanceof Document)
+          && !this.items.includes(event.relatedTarget as Item)
+          && !isClickOnToggleButton) {
+        this.#hide();
+      }
+    }
+  };
+
+  #onKeydownToggleButton = async (event: KeyboardEvent) => {
+    switch (event.key) {
+      case 'ArrowDown':
+      case 'ArrowUp':
+        if (!this.options.isExpanded()) {
+          this.#show();
+        }
+        break;
+      case 'Home':
+        if (!this.options.isExpanded()) {
+          await this.#show();
+        }
+        if (this.#fc) {
+          this.#fc.atFocusedItemIndex = 0;
+        }
+        break;
+      case 'End':
+        if (!this.options.isExpanded()) {
+          await this.#show();
+        }
+        if (this.#fc) {
+          this.#fc.atFocusedItemIndex = this.items.length - 1;
+        }
+        break;
+      case ' ':
+      case 'Enter':
+        // prevent scroll
+        event.preventDefault();
+        await this.#toggle();
+        await this.host.updateComplete;
+        if (!this.options.isExpanded()) {
+          this.#button?.focus();
+        }
+        break;
+    }
+  };
+
+  /**
+   * For Browsers which do not support `ariaActiveDescendantElement`, we must clone
+   * the listbox items into the same root as the combobox input
+   * Call this method to return either an array of (cloned) list box items, to be placed in your
+   * shadow template, or nothing in the case the browser supports cross-root aria.
+   */
+  public renderItemsToShadowRoot(): Node[] | typeof nothing {
+    if (this.#fc instanceof ActivedescendantController) {
+      return this.#fc.renderItemsToShadowRoot();
+    } else {
+      return nothing;
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/css-variable-controller.ts b/node_modules/@patternfly/pfe-core/controllers/css-variable-controller.ts
new file mode 100644
index 0000000..acb5ae3
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/css-variable-controller.ts
@@ -0,0 +1,23 @@
+import type { ReactiveElement, ReactiveController } from 'lit';
+
+export class CssVariableController implements ReactiveController {
+  style?: CSSStyleDeclaration;
+
+  constructor(public host: ReactiveElement) {
+    if (this.host.isConnected) {
+      this.hostConnected();
+    }
+  }
+
+  private parseProperty(name: string) {
+    return name.substring(0, 2) !== '--' ? `--${name}` : name;
+  }
+
+  getVariable(name: string): string | null {
+    return this.style?.getPropertyValue(this.parseProperty(name)).trim() || null;
+  }
+
+  hostConnected(): void {
+    this.style = window.getComputedStyle(this.host);
+  };
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/floating-dom-controller.ts b/node_modules/@patternfly/pfe-core/controllers/floating-dom-controller.ts
new file mode 100644
index 0000000..024daf9
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/floating-dom-controller.ts
@@ -0,0 +1,2014 @@
+import { isServer } from 'lit';
+import type { LitElement, ReactiveController, ReactiveControllerHost } from 'lit';
+import type { StyleInfo } from 'lit/directives/style-map.js';
+
+type Lazy<T> = T | (() => T | null | undefined);
+
+interface FloatingDOMControllerOptions {
+  content: Lazy<HTMLElement>;
+  invoker?: Lazy<HTMLElement>;
+  arrow?: Lazy<HTMLElement>;
+  shift?: boolean;
+  padding?: number;
+  fallbackPlacements?: Placement[];
+}
+
+interface ShowOptions {
+  offset?: OffsetValue;
+  placement?: Placement;
+  flip?: boolean;
+  fallbackPlacements?: Placement[];
+}
+
+export type Anchor = '' | 'top' | 'left' | 'bottom' | 'right';
+export type Alignment = 'center' | 'start' | 'end';
+
+/**
+ * Controls floating DOM within a web component, e.g. tooltips and popovers
+ */
+export class FloatingDOMController implements ReactiveController {
+  #open = false;
+  #opening = false;
+  #cleanup?: () => void;
+  #anchor?: Anchor;
+  #alignment?: Alignment;
+  #styles?: StyleInfo;
+  #placement?: Placement;
+  #options: FloatingDOMControllerOptions;
+
+  get #invoker() {
+    const { invoker } = this.#options;
+    return typeof invoker === 'function' ? invoker() : invoker;
+  }
+
+  get #content() {
+    const { content } = this.#options;
+    return typeof content === 'function' ? content() : content;
+  }
+
+  get #arrow() {
+    const { arrow } = this.#options;
+    return typeof arrow === 'function' ? arrow() : arrow;
+  }
+
+  /** The crosswise alignment of the invoker on which to display the floating DOM */
+  get alignment(): Alignment {
+    return this.#alignment ?? 'center';
+  }
+
+  /** The side of the invoker on which to display the floating DOM */
+  get anchor(): Anchor {
+    return this.#anchor ?? '';
+  }
+
+  /**
+   * When true, the floating DOM is visible
+   */
+  get open(): boolean {
+    return this.#open;
+  }
+
+  /** The computed placement of the floating DOM */
+  get placement(): Placement {
+    return this.#placement ?? 'top';
+  }
+
+  /**
+   * Styles to apply to your element's container
+   *
+   * - `--_floating-content-translate`: translate to apply to floating content.
+   */
+  get styles(): StyleInfo {
+    return this.#styles ?? {};
+  }
+
+  constructor(
+    private host: ReactiveControllerHost,
+    options: FloatingDOMControllerOptions
+  ) {
+    host.addController(this);
+    this.#options = {
+      invoker: (() => host as LitElement),
+      shift: true,
+      ...options,
+    };
+  }
+
+  hostDisconnected(): void {
+    this.#cleanup?.();
+  }
+
+  async #update(
+    placement: Placement = 'top',
+    offset?: OffsetValue,
+    flip = true,
+    fallbackPlacements?: Placement[],
+  ) {
+    const { padding, shift } = this.#options;
+
+    const invoker = this.#invoker;
+    const content = this.#content;
+    const arrow = this.#arrow;
+    if (!invoker || !content) {
+      return;
+    }
+    const cache = new Map<Element, Element[]>();
+    const {
+      x,
+      y,
+      placement: _placement,
+      arrow: arrowData,
+    } = calculatePosition(invoker, content, {
+      strategy: 'absolute',
+      placement,
+      offset,
+      enableShift: shift,
+      shiftPadding: padding,
+      enableFlip: flip,
+      flipPadding: padding,
+      fallbackPlacements,
+      arrow: arrow ?? undefined,
+      arrowPadding: arrow ? arrow.offsetHeight / 2 : undefined,
+    }, cache);
+
+    if (arrow) {
+      const { x: arrowX, y: arrowY } = arrowData || {};
+
+      const staticSide = {
+        top: 'bottom',
+        right: 'left',
+        bottom: 'top',
+        left: 'right',
+      }[_placement.split('-')[0]] || '';
+
+      Object.assign(arrow.style, {
+        left: arrowX != null ? `${arrowX}px` : '',
+        top: arrowY != null && !['top'].includes(_placement) ? `${arrowY}px` : '',
+        right: '',
+        bottom: '',
+        [staticSide]: `-${arrow.offsetHeight / 2}px`,
+      });
+    }
+
+    this.#placement = _placement;
+    [this.#anchor, this.#alignment] = (this.#placement.split('-') ?? []) as [Anchor, Alignment];
+    this.#styles = {
+      '--_floating-content-translate': `${x}px ${y}px`,
+    };
+    this.host.requestUpdate();
+  }
+
+  /**
+   * Show the floating DOM
+   * @param [options={}]
+   * @param options.offset
+   * @param options.placement
+   * @param options.flip
+   * @param options.fallbackPlacements
+   * */
+  async show({ offset, placement, flip, fallbackPlacements }: ShowOptions = {}): Promise<void> {
+    const invoker = this.#invoker;
+    const content = this.#content;
+    if (!invoker || !content) {
+      return;
+    }
+    if (!this.#opening) {
+      this.#opening = true;
+      const p = this.#update(placement, offset, flip, fallbackPlacements);
+      this.#cleanup ??= autoUpdate(invoker, content, () =>
+        this.#update(placement, offset, flip, fallbackPlacements));
+      await p;
+      this.#opening = false;
+    }
+    this.#open = true;
+    this.host.requestUpdate();
+  }
+
+  /** Hide the floating DOM */
+  async hide(): Promise<void> {
+    await this.host.updateComplete;
+    while (this.#opening && !this.open) {
+      await new Promise(requestAnimationFrame);
+    }
+    this.#open = false;
+    this.#cleanup?.();
+    this.host.requestUpdate();
+    await this.host.updateComplete;
+  }
+}
+
+/*
+ * The below is a recreation of the @floating-ui/dom package.
+ * Published under the MIT license.
+ * @see https://github.com/floating-ui/floating-ui/blob/master/LICENSE
+ *
+ * This file combines all floating-ui functionality into a single module
+ * to reduce import waterfall and simplify maintenance. When CSS anchor
+ * positioning reaches GA, this entire file can be deleted.
+ */
+
+// =============================================================================
+// TYPE DEFINITIONS
+// =============================================================================
+
+// Basic type definitions
+type Axis = 'x' | 'y';
+type Side = 'top' | 'right' | 'bottom' | 'left';
+type Length = 'width' | 'height';
+type Strategy = 'absolute' | 'fixed';
+
+// Derived types
+type AlignedPlacement = `${Side}-${'start' | 'end'}`;
+
+export type Placement = Side | AlignedPlacement;
+
+type Coords = Record<Axis, number>;
+
+type Dimensions = Record<Length, number>;
+
+type Rect = Coords & Dimensions;
+
+type SideObject = Record<Side, number>;
+
+type ClientRectObject = Rect & SideObject;
+
+type Padding = number | Partial<SideObject>;
+
+// Core floating UI types (browser-specific)
+type Boundary = Element | 'clippingAncestors';
+type ElementContext = 'reference' | 'floating';
+type FloatingElement = HTMLElement;
+type ReferenceElement = Element;
+type RootBoundary = 'viewport' | 'document' | Rect;
+
+type OffsetValue = number | {
+  /**
+   * The axis that runs along the side of the floating element. Represents
+   * the distance (gutter or margin) between the reference and floating
+   * element.
+   * @default 0
+   */
+  mainAxis?: number;
+  /**
+   * The axis that runs along the alignment of the floating element.
+   * Represents the skidding between the reference and floating element.
+   * @default 0
+   */
+  crossAxis?: number;
+  /**
+   * The same axis as `crossAxis` but applies only to aligned placements
+   * and inverts the `end` alignment. When set to a number, it overrides the
+   * `crossAxis` value.
+   *
+   * A positive number will move the floating element in the direction of
+   * the opposite edge to the one that is aligned, while a negative number
+   * the reverse.
+   * @default null
+   */
+  alignmentAxis?: number | null;
+};
+
+// Helper objects
+type OverflowAncestors = (Element | Window | VisualViewport)[];
+
+interface ElementRects {
+  reference: Rect;
+  floating: Rect;
+}
+
+interface Elements {
+  reference: ReferenceElement;
+  floating: FloatingElement;
+}
+
+interface PositionState {
+  placement: Placement;
+  elements: Elements;
+  rects: ElementRects;
+  x: number;
+  y: number;
+  strategy: Strategy;
+  initialPlacement: Placement;
+}
+
+interface ComputePositionReturn extends Coords {
+  /**
+   * The final chosen placement of the floating element.
+   */
+  placement: Placement;
+  /**
+   * The strategy used to position the floating element.
+   */
+  strategy: Strategy;
+  /**
+   * Arrow positioning data (if arrow was provided).
+   */
+  arrow?: Partial<Coords> & {
+    centerOffset: number;
+  };
+}
+
+interface DetectOverflowOptions {
+  /**
+   * The clipping element(s) or area in which overflow will be checked.
+   * @default 'clippingAncestors'
+   */
+  boundary?: Boundary;
+  /**
+   * The root clipping area in which overflow will be checked.
+   * @default 'viewport'
+   */
+  rootBoundary?: RootBoundary;
+  /**
+   * The element in which overflow is being checked relative to a boundary.
+   * @default 'floating'
+   */
+  elementContext?: ElementContext;
+  /**
+   * Whether to check for overflow using the alternate element's boundary
+   * (`clippingAncestors` boundary only).
+   * @default false
+   */
+  altBoundary?: boolean;
+  /**
+   * Virtual padding for the resolved overflow detection offsets.
+   * @default 0
+   */
+  padding?: Padding;
+}
+
+/** calculatePosition args */
+interface PositionConfig {
+  placement?: Placement;
+  strategy?: 'absolute' | 'fixed';
+  offset?: OffsetValue;
+  enableShift?: boolean;
+  shiftPadding?: number;
+  enableFlip?: boolean;
+  flipPadding?: number;
+  fallbackPlacements?: Placement[];
+  arrow?: HTMLElement;
+  arrowPadding?: number;
+}
+
+/** getCssDimensions return type */
+interface CssDimensions {
+  width: number;
+  height: number;
+  $: boolean;
+}
+
+/** getClippingRect args */
+interface ClippingRectArgs {
+  element: Element;
+  boundary: Boundary;
+  rootBoundary: RootBoundary;
+  strategy: Strategy;
+  cache: Map<Element, Element[]>;
+}
+
+/** autoUpdate args */
+interface AutoUpdateOptions {
+  /**
+   * Whether to update the position when an overflow ancestor scrolls.
+   * @default true
+   */
+  ancestorScroll?: boolean;
+  /**
+   * Whether to update the position when an overflow ancestor is resized.
+   * @default true
+   */
+  ancestorResize?: boolean;
+  /**
+   * Whether to update the position when either the reference or floating
+   * elements resized.
+   * @default true
+   */
+  elementResize?: boolean;
+  /**
+   * Whether to update the position when the reference element moved on the
+   * screen (covered by another element, clipped by an ancestor, or scrolled
+   * out of view).
+   * @default true
+   */
+  layoutShift?: boolean;
+  /**
+   * Whether to update on every animation frame if required.
+   * @default false
+   */
+  animationFrame?: boolean;
+}
+
+const absoluteOrFixed = new Set(['absolute', 'fixed']);
+
+const noOffsets = createCoords(0);
+
+const originSides = new Set(['left', 'top']);
+
+const lastTraversableNodeNames = new Set(['html', 'body', '#document']);
+
+const transformProperties = [
+  'transform',
+  'translate',
+  'scale',
+  'rotate',
+  'perspective',
+];
+
+const willChangeValues = [
+  'transform',
+  'translate',
+  'scale',
+  'rotate',
+  'perspective',
+  'filter',
+];
+
+const containValues = ['paint', 'layout', 'strict', 'content'];
+
+const invalidOverflowDisplayValues = new Set(['inline', 'contents']);
+
+const tableElements = new Set(['table', 'td', 'th']);
+
+const topLayerSelectors = [':popover-open', ':modal'];
+
+const oppositeSideMap: Record<Side, Side> = {
+  left: 'right',
+  right: 'left',
+  bottom: 'top',
+  top: 'bottom',
+};
+
+const oppositeAlignmentMap: Record<Exclude<Alignment, 'center'>, Exclude<Alignment, 'center'>> = {
+  start: 'end',
+  end: 'start',
+};
+
+const yAxisSides = new Set<Side>(['top', 'bottom']);
+
+// Utility functions
+
+/**
+ * Creates a coordinate object with the same value for both x and y.
+ * @param v - The value to use for both coordinates
+ * @returns Coordinate object with x and y set to the same value
+ */
+function createCoords(v: number): Coords {
+  return { x: v, y: v };
+};
+
+/**
+ * Clamps a value between a minimum and maximum range.
+ * @param start - The minimum value
+ * @param value - The value to clamp
+ * @param end - The maximum value
+ * @returns The clamped value
+ */
+function clamp(start: number, value: number, end: number): number {
+  return Math.max(start, Math.min(value, end));
+}
+
+/**
+ * Extracts the side from a placement string.
+ * @param placement - The placement string (e.g., 'top-start')
+ * @returns The side portion (e.g., 'top')
+ */
+function getSide(placement: Placement): Side {
+  return placement.split('-')[0] as Side;
+}
+
+/**
+ * Extracts the alignment from a placement string.
+ * @param placement - The placement string (e.g., 'top-start')
+ * @returns The alignment portion (e.g., 'start') or undefined if no alignment
+ */
+function getAlignment(placement: Placement): Alignment | undefined {
+  return placement.split('-')[1] as Alignment | undefined;
+}
+
+/**
+ * Gets the opposite axis (x  y).
+ * @param axis - The axis to flip
+ * @returns The opposite axis
+ */
+function getOppositeAxis(axis: Axis): Axis {
+  return axis === 'x' ? 'y' : 'x';
+}
+
+/**
+ * Gets the length property name for an axis.
+ * @param axis - The axis ('x' or 'y')
+ * @returns 'width' for x-axis, 'height' for y-axis
+ */
+function getAxisLength(axis: Axis): Length {
+  return axis === 'y' ? 'height' : 'width';
+}
+
+/**
+ * Gets the axis that runs along the side of a placement.
+ * @param placement - The placement to get the side axis for
+ * @returns 'y' for top/bottom sides, 'x' for left/right sides
+ */
+function getSideAxis(placement: Placement): Axis {
+  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';
+}
+
+/**
+ * Gets the axis that runs along the alignment of a placement.
+ * @param placement - The placement to get the alignment axis for
+ * @returns The axis perpendicular to the side axis
+ */
+function getAlignmentAxis(placement: Placement): Axis {
+  return getOppositeAxis(getSideAxis(placement));
+}
+
+/**
+ * Flips the alignment portion of a placement (start  end).
+ * @param placement - The placement string to flip alignment for
+ * @returns The placement with opposite alignment
+ */
+function getOppositeAlignmentPlacement<T extends string>(placement: T): T {
+  return placement.replace(/start|end/g, alignment =>
+    oppositeAlignmentMap[alignment as Exclude<Alignment, 'center'>]) as T;
+}
+
+/**
+ * Gets the opposite placement by flipping the side.
+ * @param placement - The placement to flip
+ * @returns The placement with opposite side
+ */
+function getOppositePlacement<T extends string>(placement: T): T {
+  return placement.replace(/left|right|bottom|top/g, side =>
+    oppositeSideMap[side as Side]) as T;
+}
+
+/**
+ * Converts padding value to a complete side object.
+ * @param padding - The padding value (number or partial side object)
+ * @returns Complete side object with padding for all sides
+ */
+function getPaddingObject(padding: Padding): SideObject {
+  return typeof padding !== 'number' ? {
+    top: 0,
+    right: 0,
+    bottom: 0,
+    left: 0,
+    ...padding,
+  } : {
+    top: padding,
+    right: padding,
+    bottom: padding,
+    left: padding,
+  };
+}
+
+/**
+ * Converts a basic rect to a client rect object with all sides.
+ * @param rect - The basic rect with x, y, width, height
+ * @returns Client rect object with top, left, right, bottom properties
+ */
+function rectToClientRect(rect: Rect): ClientRectObject {
+  const { x, y, width, height } = rect;
+  return {
+    width,
+    height,
+    top: y,
+    left: x,
+    right: x + width,
+    bottom: y + height,
+    x,
+    y,
+  };
+}
+
+// =============================================================================
+// DOM UTILITY FUNCTIONS
+// =============================================================================
+
+/**
+ * Gets the node name of a given node or window object.
+ * @param {Node | Window} node - The node or window to get the name for
+ * @returns {string} The lowercase node name, or '#document' for non-Node objects
+ */
+function getNodeName(node: Node | Window): string {
+  if (isNode(node)) {
+    return (node.nodeName || '').toLowerCase();
+  }
+  // Mocked nodes in testing environments may not be instances of Node. By
+  // returning `#document` an infinite loop won't occur.
+  // https://github.com/floating-ui/floating-ui/issues/2317
+  return '#document';
+}
+
+/**
+ * Gets the document element (html element) for a given node or window.
+ * @param  node - The node or window to get the document element for
+ * @returns  The document element (html element)
+ */
+function getDocumentElement(node: Node | Window): HTMLElement {
+  return (
+    (isNode(node) ? node.ownerDocument : node.document) || window.document
+  )?.documentElement;
+}
+
+/**
+ * Type guard to check if a value is a Node.
+ * @param  value - The value to check
+ * @returns  True if the value is a Node, false otherwise
+ */
+function isNode(value: unknown): value is Node {
+  return !isServer && value instanceof Node;
+}
+
+/**
+ * Type guard to check if a value is an Element.
+ * @param  value - The value to check
+ * @returns  True if the value is an Element, false otherwise
+ */
+function isElement(value: unknown): value is Element {
+  return !isServer && value instanceof Element;
+}
+
+/**
+ * Type guard to check if a value is an HTMLElement.
+ * @param  value - The value to check
+ * @returns  True if the value is an HTMLElement, false otherwise
+ */
+function isHTMLElement(value: unknown): value is HTMLElement {
+  return !isServer && value instanceof HTMLElement;
+}
+
+/**
+ * Type guard to check if a value is a ShadowRoot.
+ * @param  value - The value to check
+ * @returns  True if the value is a ShadowRoot, false otherwise
+ */
+function isShadowRoot(value: unknown): value is ShadowRoot {
+  return !isServer && typeof ShadowRoot !== 'undefined' && value instanceof ShadowRoot;
+}
+
+/**
+ * Checks if an element has overflow properties that create a scrolling context.
+ * @param  element - The element to check
+ * @returns  True if the element has overflow properties that create a scrolling context
+ */
+function isOverflowElement(element: Element): boolean {
+  const { overflow, overflowX, overflowY, display } = window.getComputedStyle(element);
+  return (
+    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX)
+    && !invalidOverflowDisplayValues.has(display)
+  );
+}
+
+/**
+ * Checks if an element is a table-related element (table, td, th).
+ * @param  element - The element to check
+ * @returns  True if the element is a table-related element
+ */
+function isTableElement(element: Element): boolean {
+  return tableElements.has(getNodeName(element));
+}
+
+/**
+ * Checks if an element is in the top layer (popover or modal).
+ * @param  element - The element to check
+ * @returns  True if the element is in the top layer
+ */
+function isTopLayer(element: Element): boolean {
+  return topLayerSelectors.some(selector => {
+    try {
+      return element.matches(selector);
+    } catch {
+      return false;
+    }
+  });
+}
+
+/**
+ * Checks if an element or CSS style declaration creates a containing block.
+ * A containing block is the element relative to which positioned elements are positioned.
+ * @param  elementOrCss - The element or CSS style declaration to check
+ * @returns  True if the element creates a containing block
+ * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
+ * @see https://drafts.csswg.org/css-transforms-2/#individual-transforms
+ */
+function isContainingBlock(
+  elementOrCss: Element | CSSStyleDeclaration,
+): boolean {
+  const webkit = isWebKit();
+  const css = isElement(elementOrCss) ?
+    window.getComputedStyle(elementOrCss)
+    : elementOrCss;
+
+  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
+  // https://drafts.csswg.org/css-transforms-2/#individual-transforms
+  return (
+    transformProperties.some(value =>
+      css[value as keyof CSSStyleDeclaration] ?
+        css[value as keyof CSSStyleDeclaration] !== 'none'
+        : false,
+    )
+    || (css.containerType ? css.containerType !== 'normal' : false)
+    || (!webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false))
+    || (!webkit && (css.filter ? css.filter !== 'none' : false))
+    || willChangeValues.some(value => (css.willChange || '').includes(value))
+    || containValues.some(value => (css.contain || '').includes(value))
+  );
+}
+
+/**
+ * Gets the nearest containing block element for a given element.
+ * Traverses up the DOM tree to find the first element that creates a containing block.
+ * @param {Element} element - The element to find the containing block for
+ * @returns {HTMLElement | null} The containing block element, or null if none found
+ */
+function getContainingBlock(element: Element): HTMLElement | null {
+  let currentNode: Node | null = getParentNode(element);
+
+  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
+    if (isContainingBlock(currentNode)) {
+      return currentNode;
+    } else if (isTopLayer(currentNode)) {
+      return null;
+    }
+
+    currentNode = getParentNode(currentNode);
+  }
+
+  return null;
+}
+
+/**
+ * Checks if the current browser is WebKit-based.
+ * @returns {boolean} True if the browser is WebKit-based, false otherwise
+ */
+function isWebKit(): boolean {
+  if (typeof CSS === 'undefined' || !CSS.supports) {
+    return false;
+  }
+  return CSS.supports('-webkit-backdrop-filter', 'none');
+}
+
+/**
+ * Checks if a node is the last traversable node in the DOM tree.
+ * @param {Node} node - The node to check
+ * @returns {boolean} True if the node is the last traversable node (html, body, or #document)
+ */
+function isLastTraversableNode(node: Node): boolean {
+  return lastTraversableNodeNames.has(getNodeName(node));
+}
+
+/**
+ * Gets the scroll position of an element or window.
+ * @param {Element | Window} element - The element or window to get scroll position for
+ * @returns {{scrollLeft: number, scrollTop: number}} Object containing scrollLeft and scrollTop values
+ */
+function getNodeScroll(element: Element | Window): {
+  scrollLeft: number;
+  scrollTop: number;
+} {
+  if (isElement(element)) {
+    return {
+      scrollLeft: element.scrollLeft,
+      scrollTop: element.scrollTop,
+    };
+  }
+
+  return {
+    scrollLeft: element.scrollX,
+    scrollTop: element.scrollY,
+  };
+}
+
+/**
+ * Gets the parent node of a given node, handling shadow DOM and slotted elements.
+ * @param {Node} node - The node to get the parent for
+ * @returns {Node} The parent node, handling shadow DOM boundaries and slotted elements
+ */
+function getParentNode(node: Node): Node {
+  if (getNodeName(node) === 'html') {
+    return node;
+  }
+
+  const result =
+    // Step into the shadow DOM of the parent of a slotted node.
+    (node as Element).assignedSlot
+    // DOM Element detected.
+    || node.parentNode
+    // ShadowRoot detected.
+    || (isShadowRoot(node) && node.host)
+    // Fallback.
+    || getDocumentElement(node);
+
+  return isShadowRoot(result) ? result.host : result;
+}
+
+/**
+ * Gets the nearest overflow ancestor element for a given node.
+ * Traverses up the DOM tree to find the first element that has overflow properties.
+ * @param {Node} node - The node to find the overflow ancestor for
+ * @returns {HTMLElement} The nearest overflow ancestor element
+ */
+function getNearestOverflowAncestor(node: Node): HTMLElement {
+  const parentNode = getParentNode(node);
+
+  if (isLastTraversableNode(parentNode)) {
+    return node.ownerDocument ?
+      node.ownerDocument.body
+      : (node as Document).body;
+  }
+
+  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
+    return parentNode;
+  }
+
+  return getNearestOverflowAncestor(parentNode);
+}
+
+/**
+ * Gets all overflow ancestors for a given node, including windows and visual viewports.
+ * @param  node - The node to get overflow ancestors for
+ * @param  list - Accumulator list for overflow ancestors
+ * @param  traverseIframes - Whether to traverse iframe boundaries
+ * @returns  Array of overflow ancestors including elements, windows, and visual viewports
+ */
+function getOverflowAncestors(
+  node: Node,
+  list: OverflowAncestors = [],
+  traverseIframes = true,
+): OverflowAncestors {
+  const scrollableAncestor = getNearestOverflowAncestor(node);
+  const isBody = scrollableAncestor === node.ownerDocument?.body;
+  const win = window;
+
+  if (isBody) {
+    const frameElement = getFrameElement(win);
+    return list.concat(
+      win,
+      win.visualViewport || [],
+      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
+      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],
+    );
+  }
+
+  return list.concat(
+    scrollableAncestor,
+    getOverflowAncestors(scrollableAncestor, [], traverseIframes),
+  );
+}
+
+/**
+ * Gets the frame element for a window if it's within an iframe.
+ * @param {Window} win - The window to get the frame element for
+ * @returns {Element | null} The frame element if the window is within an iframe, null otherwise
+ */
+function getFrameElement(win: Window): Element | null {
+  return win.parent && Object.getPrototypeOf(win.parent) ?
+    win.frameElement
+    : null;
+}
+
+// =============================================================================
+// CORE MIDDLEWARES
+// =============================================================================
+
+// Helper function implementations
+function computeCoordsFromPlacement(
+  { reference, floating }: { reference: Rect; floating: Rect },
+  placement: Placement,
+  rtl?: boolean
+): Coords {
+  const sideAxis = getSideAxis(placement);
+  const alignmentAxis = getAlignmentAxis(placement);
+  const alignLength = getAxisLength(alignmentAxis);
+  const side = getSide(placement);
+  const isVertical = sideAxis === 'y';
+  const commonX = reference.x + reference.width / 2 - floating.width / 2;
+  const commonY = reference.y + reference.height / 2 - floating.height / 2;
+  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
+  let coords: Coords;
+
+  switch (side) {
+    case 'top':
+      coords = {
+        x: commonX,
+        y: reference.y - floating.height,
+      };
+      break;
+    case 'bottom':
+      coords = {
+        x: commonX,
+        y: reference.y + reference.height,
+      };
+      break;
+    case 'right':
+      coords = {
+        x: reference.x + reference.width,
+        y: commonY,
+      };
+      break;
+    case 'left':
+      coords = {
+        x: reference.x - floating.width,
+        y: commonY,
+      };
+      break;
+    default:
+      coords = {
+        x: reference.x,
+        y: reference.y,
+      };
+  }
+
+  switch (getAlignment(placement)) {
+    case 'start':
+      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
+      break;
+    case 'end':
+      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
+      break;
+  }
+
+  return coords;
+}
+
+/**
+ * Computes the `x` and `y` coordinates that will place the floating element
+ * next to a given reference element.
+ *
+ * @param reference - The reference element
+ * @param floating - The floating element
+ * @param config - Configuration options
+ * @param cache - Cache for clipping ancestor calculations
+ */
+function calculatePosition(
+  reference: Element,
+  floating: HTMLElement,
+  config: PositionConfig,
+  cache: Map<Element, Element[]>
+): ComputePositionReturn {
+  const {
+    placement: initialPlacement = 'bottom',
+    strategy = 'absolute',
+    offset = 0,
+    enableShift = true,
+    shiftPadding,
+    enableFlip = true,
+    flipPadding,
+    fallbackPlacements,
+    arrow,
+    arrowPadding = 0,
+  } = config;
+
+  const rtl = isRTL(floating);
+  const elements = { reference, floating };
+  let resetCount = 0;
+  let statefulPlacement = initialPlacement;
+  let arrowData: Partial<Coords> & { centerOffset: number } | undefined;
+  let x = 0;
+  let y = 0;
+
+  // Main positioning loop (handles flip resets)
+  while (resetCount < 50) {
+    const rects = getElementRects({ reference, floating, strategy });
+    const coords = computeCoordsFromPlacement(rects, statefulPlacement, rtl);
+    ({ x, y } = coords);
+
+    // 1. Apply offset
+    if (offset) {
+      const offsetCoords = convertValueToCoords(
+        { placement: statefulPlacement, elements, rects, x, y, strategy,
+          initialPlacement },
+        offset
+      );
+      x += offsetCoords.x;
+      y += offsetCoords.y;
+    }
+
+    // 2. Apply shift (keep in viewport)
+    if (enableShift) {
+      const overflow = detectOverflow(
+        { x, y, placement: statefulPlacement, strategy, rects, elements,
+          initialPlacement },
+        { padding: shiftPadding },
+        cache
+      );
+      const side = getSideAxis(getSide(statefulPlacement));
+      const mainAxis = getOppositeAxis(side);
+
+      const minSide = mainAxis === 'y' ? 'top' : 'left';
+      const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
+      const minCoord = (mainAxis === 'y' ? y : x) + overflow[minSide];
+      const maxCoord = (mainAxis === 'y' ? y : x) - overflow[maxSide];
+
+      if (mainAxis === 'y') {
+        y = clamp(minCoord, y, maxCoord);
+      } else {
+        x = clamp(minCoord, x, maxCoord);
+      }
+    }
+
+    // 3. Calculate arrow position (if arrow element provided)
+    if (arrow) {
+      const axis = getAlignmentAxis(statefulPlacement);
+      const length = getAxisLength(axis);
+      const arrowDimensions = getDimensions(arrow);
+      const isYAxis = axis === 'y';
+      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
+
+      const arrowOffsetParent = getOffsetParent(arrow);
+      let clientSize = arrowOffsetParent ? (arrowOffsetParent as Element)[clientProp] : 0;
+      if (!clientSize || !isElement(arrowOffsetParent)) {
+        clientSize = (floating as Element)[clientProp] || rects.floating[length];
+      }
+
+      const endDiff = rects.reference[length] + rects.reference[axis]
+        - (axis === 'y' ? y : x) - rects.floating[length];
+      const startDiff = (axis === 'y' ? y : x) - rects.reference[axis];
+      const centerToReference = endDiff / 2 - startDiff / 2;
+
+      const paddingObject = getPaddingObject(arrowPadding);
+      const minProp = isYAxis ? 'top' : 'left';
+      const maxProp = isYAxis ? 'bottom' : 'right';
+      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
+      const minPadding = Math.min(paddingObject[minProp], largestPossiblePadding);
+      const maxPadding = Math.min(paddingObject[maxProp], largestPossiblePadding);
+
+      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
+      const arrowOffset =
+        clamp(minPadding, center, clientSize - arrowDimensions[length] - maxPadding);
+
+      arrowData = {
+        [axis]: arrowOffset,
+        centerOffset: center - arrowOffset,
+      };
+    }
+
+    // 4. Check for flip
+    if (enableFlip) {
+      const overflow = detectOverflow(
+        { x, y, placement: statefulPlacement, strategy, rects, elements,
+          initialPlacement },
+        { padding: flipPadding },
+        cache
+      );
+
+      const side = getSide(statefulPlacement);
+      const isOverflowing = overflow[side] > 0;
+
+      if (isOverflowing) {
+        // Determine fallback placements
+        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
+        const placements = fallbackPlacements || (
+          isBasePlacement ?
+            [getOppositePlacement(initialPlacement)]
+            : (() => {
+              const oppositePlacement = getOppositePlacement(initialPlacement);
+              return [
+                getOppositeAlignmentPlacement(initialPlacement),
+                oppositePlacement,
+                getOppositeAlignmentPlacement(oppositePlacement),
+              ];
+            })()
+        );
+        const allPlacements = [initialPlacement, ...placements];
+        const nextIndex = resetCount + 1;
+
+        if (nextIndex < allPlacements.length) {
+          statefulPlacement = allPlacements[nextIndex];
+          resetCount++;
+          continue; // Restart loop with new placement
+        }
+      }
+    }
+
+    // No reset needed, we're done
+    break;
+  }
+
+  return {
+    x,
+    y,
+    placement: statefulPlacement,
+    strategy,
+    arrow: arrowData,
+  };
+}
+
+/**
+ * Resolves with an object of overflow side offsets that determine how much the
+ * element is overflowing a given clipping boundary on each side.
+ * - positive = overflowing the boundary by that number of pixels
+ * - negative = how many pixels left before it will overflow
+ * - 0 = lies flush with the boundary
+ * @see https://floating-ui.com/docs/detectOverflow
+ * @param state - The position state
+ * @param options - Detection options
+ * @param cache - Cache for clipping ancestor calculations
+ */
+function detectOverflow(
+  state: PositionState,
+  options: DetectOverflowOptions = {},
+  cache: Map<Element, Element[]>
+): SideObject {
+  const {
+    x,
+    y,
+    rects,
+    elements,
+    strategy,
+  } = state;
+  const {
+    boundary = 'clippingAncestors',
+    rootBoundary = 'viewport',
+    elementContext = 'floating',
+    altBoundary = false,
+    padding = 0,
+  } = options;
+  const paddingObject = getPaddingObject(padding);
+  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
+  const element = elements[altBoundary ? altContext : elementContext];
+  const clippingClientRect = rectToClientRect(getClippingRect({
+    element: isElement(element) ?
+      element
+      : (getDocumentElement(elements.floating) || elements.floating),
+    boundary,
+    rootBoundary,
+    strategy,
+    cache,
+  }));
+  const rect = elementContext === 'floating' ? {
+    x,
+    y,
+    width: rects.floating.width,
+    height: rects.floating.height,
+  } : rects.reference;
+  const offsetParent = getOffsetParent(elements.floating);
+  const offsetScale = (offsetParent && isElement(offsetParent)) ?
+    getScale(offsetParent) || { x: 1, y: 1 }
+    : { x: 1, y: 1 };
+  const elementClientRect = rectToClientRect(
+    offsetParent ?
+      convertOffsetParentRelativeRectToViewportRelativeRect({
+        elements,
+        rect,
+        offsetParent,
+        strategy,
+      })
+      : rect,
+  );
+  return {
+    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top)
+      / offsetScale.y,
+    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom)
+      / offsetScale.y,
+    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left)
+      / offsetScale.x,
+    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right)
+      / offsetScale.x,
+  };
+}
+
+function convertValueToCoords(state: PositionState, options: OffsetValue): Coords {
+  const {
+    placement,
+    elements,
+  } = state;
+  const rtl = isRTL(elements.floating);
+  const side = getSide(placement);
+  const alignment = getAlignment(placement);
+  const isVertical = getSideAxis(placement) === 'y';
+  const mainAxisMulti = originSides.has(side) ? -1 : 1;
+  const crossAxisMulti = rtl && isVertical ? -1 : 1;
+
+  const {
+    mainAxis,
+    crossAxis: initialCrossAxis,
+    alignmentAxis,
+  } = typeof options === 'number' ? {
+    mainAxis: options,
+    crossAxis: 0,
+    alignmentAxis: null,
+  } : {
+    mainAxis: options.mainAxis || 0,
+    crossAxis: options.crossAxis || 0,
+    alignmentAxis: options.alignmentAxis,
+  };
+  const crossAxis = alignment && typeof alignmentAxis === 'number' ?
+    alignment === 'end' ? alignmentAxis * -1 : alignmentAxis
+    : initialCrossAxis;
+  return isVertical ? {
+    x: crossAxis * crossAxisMulti,
+    y: mainAxis * mainAxisMulti,
+  } : {
+    x: mainAxis * mainAxisMulti,
+    y: crossAxis * crossAxisMulti,
+  };
+}
+
+/**
+ * Gets the CSS dimensions of an element, handling fallbacks for SVG elements.
+ * @param element - The element to get dimensions for
+ * @returns Object containing width, height, and fallback flag
+ */
+function getCssDimensions(element: Element): CssDimensions {
+  const css = window.getComputedStyle(element);
+  // In testing environments, the `width` and `height` properties are empty
+  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
+  let width = parseFloat(css.width) || 0;
+  let height = parseFloat(css.height) || 0;
+  const hasOffset = isHTMLElement(element);
+  const offsetWidth = hasOffset ? element.offsetWidth : width;
+  const offsetHeight = hasOffset ? element.offsetHeight : height;
+  const shouldFallback = Math.round(width) !== offsetWidth || Math.round(height) !== offsetHeight;
+  if (shouldFallback) {
+    width = offsetWidth;
+    height = offsetHeight;
+  }
+  return {
+    width,
+    height,
+    $: shouldFallback,
+  };
+}
+
+/**
+ * Gets the scale factor of an element based on its bounding rect vs CSS dimensions.
+ * @param element - The element to get scale for
+ * @returns Coordinates object with x and y scale factors
+ */
+function getScale(element: Element): Coords {
+  if (!isHTMLElement(element)) {
+    return createCoords(1);
+  }
+  const rect = element.getBoundingClientRect();
+  const {
+    width,
+    height,
+    $,
+  } = getCssDimensions(element);
+  let x = ($ ? Math.round(rect.width) : rect.width) / width;
+  let y = ($ ? Math.round(rect.height) : rect.height) / height;
+
+  // 0, NaN, or Infinity should always fallback to 1.
+
+  if (!x || !Number.isFinite(x)) {
+    x = 1;
+  }
+  if (!y || !Number.isFinite(y)) {
+    y = 1;
+  }
+  return {
+    x,
+    y,
+  };
+}
+
+/**
+ * Gets the visual viewport offsets for an element in WebKit browsers.
+ * @param element - The element to get visual offsets for
+ * @returns Coordinates object with x and y offsets
+ */
+function getVisualOffsets(): Coords {
+  const win = window;
+  if (!isWebKit() || !win.visualViewport) {
+    return noOffsets;
+  }
+  return {
+    x: win.visualViewport.offsetLeft,
+    y: win.visualViewport.offsetTop,
+  };
+}
+
+/**
+ * Determines if visual offsets should be added for positioning calculations.
+ * @param element - The element to check
+ * @param isFixed - Whether the element uses fixed positioning
+ * @param floatingOffsetParent - The floating element's offset parent
+ * @returns True if visual offsets should be added
+ */
+function shouldAddVisualOffsets(
+  isFixed = false,
+  floatingOffsetParent?: Element | Window
+): boolean {
+  if (!floatingOffsetParent || (isFixed && floatingOffsetParent !== window)) {
+    return false;
+  }
+  return isFixed;
+}
+
+/**
+ * Gets the bounding client rect of an element with optional scale and iframe handling.
+ * @param element - The element to get bounding rect for
+ * @param includeScale - Whether to include scale calculations
+ * @param isFixedStrategy - Whether the element uses fixed positioning strategy
+ * @param offsetParent - The offset parent for calculations
+ * @returns Client rect object with position and dimensions
+ */
+function getBoundingClientRect(
+  element: Element,
+  includeScale = false,
+  isFixedStrategy = false,
+  offsetParent?: Element | Window
+): ClientRectObject {
+  const clientRect = element.getBoundingClientRect();
+  let scale = createCoords(1);
+  if (includeScale) {
+    if (offsetParent) {
+      if (isElement(offsetParent)) {
+        scale = getScale(offsetParent);
+      }
+    } else {
+      scale = getScale(element);
+    }
+  }
+  const visualOffsets = shouldAddVisualOffsets(isFixedStrategy, offsetParent) ?
+    getVisualOffsets()
+    : createCoords(0);
+  let x = (clientRect.left + visualOffsets.x) / scale.x;
+  let y = (clientRect.top + visualOffsets.y) / scale.y;
+  let width = clientRect.width / scale.x;
+  let height = clientRect.height / scale.y;
+  if (element) {
+    const win = window;
+    const offsetWin = offsetParent
+      && isElement(offsetParent) ? window : offsetParent;
+    let currentWin = win;
+    let currentIFrame = getFrameElement(currentWin);
+    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
+      const iframeScale = getScale(currentIFrame);
+      const iframeRect = currentIFrame.getBoundingClientRect();
+      const css = window.getComputedStyle(currentIFrame);
+      const left = iframeRect.left
+        + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
+      const top = iframeRect.top
+        + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
+      x *= iframeScale.x;
+      y *= iframeScale.y;
+      width *= iframeScale.x;
+      height *= iframeScale.y;
+      x += left;
+      y += top;
+      currentWin = window;
+      currentIFrame = getFrameElement(currentWin);
+    }
+  }
+  return rectToClientRect({
+    width,
+    height,
+    x,
+    y,
+  });
+}
+
+/**
+ * Gets the X position of the window scrollbar.
+ * Note: If <html> has a CSS width greater than the viewport, this will be incorrect for RTL.
+ * @param element - The element to get scrollbar position for
+ * @param rect - Optional rect to use instead of calculating
+ * @returns The X position of the scrollbar
+ */
+function getWindowScrollBarX(element: Element, rect?: ClientRectObject): number {
+  const leftScroll = getNodeScroll(element).scrollLeft;
+  if (!rect) {
+    return getBoundingClientRect(getDocumentElement(element)!).left + leftScroll;
+  }
+  return rect.left + leftScroll;
+}
+
+/**
+ * Gets the HTML offset for positioning calculations.
+ * @param documentElement - The document element
+ * @param scroll - The scroll position object
+ * @param scroll.scrollTop
+ * @param scroll.scrollLeft
+ * @param ignoreScrollbarX - Whether to ignore X scrollbar in calculations
+ * @returns Coordinates object with x and y offsets
+ */
+function getHTMLOffset(
+  documentElement: Element,
+  scroll: { scrollLeft: number; scrollTop: number },
+  ignoreScrollbarX = false
+): Coords {
+  const htmlRect = documentElement.getBoundingClientRect();
+  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0
+  // RTL <body> scrollbar.
+  : getWindowScrollBarX(documentElement, htmlRect));
+  const y = htmlRect.top + scroll.scrollTop;
+  return {
+    x,
+    y,
+  };
+}
+
+/**
+ * Converts an offset parent relative rect to a viewport relative rect.
+ * @param args - Object containing elements, rect, offsetParent, and strategy
+ * @param args.strategy
+ * @param args.offsetParent
+ * @param args.rect
+ * @param args.elements
+ * @param args.elements.floating
+ * @returns Viewport-relative rect
+ */
+function convertOffsetParentRelativeRectToViewportRelativeRect(args: {
+  elements?: { floating: Element };
+  rect: Rect;
+  offsetParent: Element | Window;
+  strategy: Strategy;
+}): Rect {
+  const { elements, rect, offsetParent, strategy } = args;
+  const isFixed = strategy === 'fixed';
+  const documentElement = getDocumentElement(offsetParent)!;
+  const topLayer = elements ? isTopLayer(elements.floating) : false;
+  if (offsetParent === documentElement || (topLayer && isFixed)) {
+    return rect;
+  }
+  let scroll = {
+    scrollLeft: 0,
+    scrollTop: 0,
+  };
+  let scale = createCoords(1);
+  const offsets = createCoords(0);
+  const isOffsetParentAnElement = isHTMLElement(offsetParent);
+  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
+    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
+      scroll = getNodeScroll(offsetParent);
+    }
+    if (isHTMLElement(offsetParent)) {
+      const offsetRect = getBoundingClientRect(offsetParent);
+      scale = getScale(offsetParent);
+      offsets.x = offsetRect.x + offsetParent.clientLeft;
+      offsets.y = offsetRect.y + offsetParent.clientTop;
+    }
+  }
+  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ?
+    getHTMLOffset(documentElement, scroll, true)
+    : createCoords(0);
+  return {
+    width: rect.width * scale.x,
+    height: rect.height * scale.y,
+    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
+    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,
+  };
+}
+
+/**
+ * Gets the entire size of the scrollable document area, even extending outside
+ * of the `<html>` and `<body>` rect bounds if horizontally scrollable.
+ * @param element - The element to get document rect for
+ * @returns Rect object with document dimensions and position
+ */
+function getDocumentRect(element: Element): Rect {
+  const html = getDocumentElement(element)!;
+  const scroll = getNodeScroll(element);
+  const { body } = element.ownerDocument;
+  const width =
+    Math.max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
+  const height =
+    Math.max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
+  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
+  const y = -scroll.scrollTop;
+  if (window.getComputedStyle(body).direction === 'rtl') {
+    x += Math.max(html.clientWidth, body.clientWidth) - width;
+  }
+  return {
+    width,
+    height,
+    x,
+    y,
+  };
+}
+
+/**
+ * Gets the viewport rect, accounting for visual viewport if available.
+ * @param element - The element to get viewport rect for
+ * @param strategy - The positioning strategy being used
+ * @returns Rect object with viewport dimensions and position
+ */
+function getViewportRect(element: Element, strategy: Strategy): Rect {
+  const win = window;
+  const html = getDocumentElement(element)!;
+  const { visualViewport } = win;
+  const width = visualViewport ? visualViewport.width : html.clientWidth;
+  const height = visualViewport ? visualViewport.height : html.clientHeight;
+  let x = 0;
+  let y = 0;
+  if (visualViewport) {
+    const visualViewportBased = isWebKit();
+    if (!visualViewportBased || (visualViewportBased && strategy === 'fixed')) {
+      x = visualViewport.offsetLeft;
+      y = visualViewport.offsetTop;
+    }
+  }
+  return {
+    width,
+    height,
+    x,
+    y,
+  };
+}
+
+/**
+ * Returns the inner client rect, subtracting scrollbars if present.
+ * @param element - The element to get inner rect for
+ * @param strategy - The positioning strategy being used
+ * @returns Rect object with inner dimensions and position
+ */
+function getInnerBoundingClientRect(element: Element, strategy: Strategy): Rect {
+  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
+  const top = clientRect.top + (element as HTMLElement).clientTop;
+  const left = clientRect.left + (element as HTMLElement).clientLeft;
+  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
+  const width = (element as HTMLElement).clientWidth * scale.x;
+  const height = (element as HTMLElement).clientHeight * scale.y;
+  const x = left * scale.x;
+  const y = top * scale.y;
+  return {
+    width,
+    height,
+    x,
+    y,
+  };
+}
+
+/**
+ * Gets the client rect from a clipping ancestor (viewport, document, or element).
+ * @param element - The element being positioned
+ * @param clippingAncestor - The clipping ancestor ('viewport', 'document', or element)
+ * @param strategy - The positioning strategy being used
+ * @returns Client rect object for the clipping boundary
+ */
+function getClientRectFromClippingAncestor(
+  element: Element,
+  clippingAncestor: Element | RootBoundary | 'viewport' | 'document',
+  strategy: Strategy
+): ClientRectObject {
+  let rect: Rect;
+  if (clippingAncestor === 'viewport') {
+    rect = getViewportRect(element, strategy);
+  } else if (clippingAncestor === 'document') {
+    rect = getDocumentRect(getDocumentElement(element)!);
+  } else if (isElement(clippingAncestor)) {
+    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
+  } else {
+    const visualOffsets = getVisualOffsets();
+    rect = {
+      x: clippingAncestor.x - visualOffsets.x,
+      y: clippingAncestor.y - visualOffsets.y,
+      width: clippingAncestor.width,
+      height: clippingAncestor.height,
+    };
+  }
+  return rectToClientRect(rect);
+}
+
+/**
+ * Checks if an element has a fixed position ancestor up to a stop node.
+ * @param element - The element to check
+ * @param stopNode - The node to stop checking at
+ * @returns True if a fixed position ancestor is found
+ */
+function hasFixedPositionAncestor(element: Element, stopNode: Element): boolean {
+  const parentNode = getParentNode(element);
+  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
+    return false;
+  }
+  return window.getComputedStyle(parentNode).position === 'fixed'
+    || hasFixedPositionAncestor(parentNode, stopNode);
+}
+
+/**
+ * A "clipping ancestor" is an `overflow` element with the characteristic of
+ * clipping (or hiding) child elements. This returns all clipping ancestors
+ * of the given element up the tree.
+ * @param element - The element to find clipping ancestors for
+ * @param cache - Cache map to store results
+ * @returns Array of clipping ancestor elements
+ */
+function getClippingElementAncestors(element: Element, cache: Map<Element, Element[]>): Element[] {
+  const cachedResult = cache.get(element);
+  if (cachedResult) {
+    return cachedResult;
+  }
+  let result = getOverflowAncestors(element, [], false).filter(
+    el => isElement(el) && getNodeName(el) !== 'body'
+  ) as Element[];
+  let currentContainingBlockComputedStyle: CSSStyleDeclaration | null = null;
+  const elementIsFixed = window.getComputedStyle(element).position === 'fixed';
+  let currentNode: Node | null = elementIsFixed ? getParentNode(element) : element;
+
+  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
+  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
+    const computedStyle = window.getComputedStyle(currentNode);
+    const currentNodeIsContaining = isContainingBlock(currentNode);
+    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
+      currentContainingBlockComputedStyle = null;
+    }
+    const shouldDropCurrentNode = elementIsFixed ?
+      !currentNodeIsContaining && !currentContainingBlockComputedStyle
+      : !currentNodeIsContaining && computedStyle.position === 'static'
+        && !!currentContainingBlockComputedStyle
+        && absoluteOrFixed.has(currentContainingBlockComputedStyle.position)
+        || isOverflowElement(currentNode)
+        && !currentNodeIsContaining
+        && hasFixedPositionAncestor(element, currentNode);
+    if (shouldDropCurrentNode) {
+      // Drop non-containing blocks.
+      result = result.filter(ancestor => ancestor !== currentNode);
+    } else {
+      // Record last containing block for next iteration.
+      currentContainingBlockComputedStyle = computedStyle;
+    }
+    currentNode = getParentNode(currentNode as Element);
+  }
+  cache.set(element, result);
+  return result;
+}
+
+/**
+ * Gets the maximum area that the element is visible in due to any number of
+ * clipping ancestors.
+ * @param args - Object containing element, boundary, rootBoundary, strategy, and cache
+ * @returns Rect object representing the clipping area
+ */
+function getClippingRect(args: ClippingRectArgs): Rect {
+  const { element, boundary, rootBoundary, strategy, cache } = args;
+  const elementClippingAncestors = boundary === 'clippingAncestors' ?
+    isTopLayer(element) ?
+      []
+      : getClippingElementAncestors(element, cache)
+    : [boundary].flat();
+  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
+  const [firstClippingAncestor] = clippingAncestors;
+  const clippingRect = clippingAncestors.reduce((accRect: ClientRectObject, clippingAncestor) => {
+    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
+    accRect.top = Math.max(rect.top, accRect.top);
+    accRect.right = Math.min(rect.right, accRect.right);
+    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
+    accRect.left = Math.max(rect.left, accRect.left);
+    return accRect;
+  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
+  return {
+    width: clippingRect.right - clippingRect.left,
+    height: clippingRect.bottom - clippingRect.top,
+    x: clippingRect.left,
+    y: clippingRect.top,
+  };
+}
+
+/**
+ * Gets the dimensions of an element.
+ * @param element - The element to get dimensions for
+ * @returns Dimensions object with width and height
+ */
+function getDimensions(element: Element): Dimensions {
+  const { width, height } = getCssDimensions(element);
+  return {
+    width,
+    height,
+  };
+}
+
+/**
+ * Gets the rect of an element relative to its offset parent.
+ * @param element - The element to get rect for
+ * @param offsetParent - The offset parent element
+ * @param strategy - The positioning strategy being used
+ * @returns Rect object relative to the offset parent
+ */
+function getRectRelativeToOffsetParent(
+  element: Element,
+  offsetParent: Element | Window,
+  strategy: Strategy
+): Rect {
+  const isOffsetParentAnElement = isHTMLElement(offsetParent);
+  const documentElement = getDocumentElement(offsetParent)!;
+  const isFixed = strategy === 'fixed';
+  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
+  let scroll = {
+    scrollLeft: 0,
+    scrollTop: 0,
+  };
+  const offsets = createCoords(0);
+
+  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
+  // Firefox with layout.scrollbar.side = 3 in about:config to test this.
+  function setLeftRTLScrollbarOffset(): void {
+    offsets.x = getWindowScrollBarX(documentElement);
+  }
+  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
+    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
+      scroll = getNodeScroll(offsetParent);
+    }
+    if (isOffsetParentAnElement) {
+      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
+      offsets.x = offsetRect.x + offsetParent.clientLeft;
+      offsets.y = offsetRect.y + offsetParent.clientTop;
+    } else if (documentElement) {
+      setLeftRTLScrollbarOffset();
+    }
+  }
+  if (isFixed && !isOffsetParentAnElement && documentElement) {
+    setLeftRTLScrollbarOffset();
+  }
+  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ?
+    getHTMLOffset(documentElement, scroll)
+    : createCoords(0);
+  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
+  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
+  return {
+    x,
+    y,
+    width: rect.width,
+    height: rect.height,
+  };
+}
+
+/**
+ * Checks if an element has static positioning.
+ * @param element - The element to check
+ * @returns True if the element is statically positioned
+ */
+function isStaticPositioned(element: Element): boolean {
+  return window.getComputedStyle(element).position === 'static';
+}
+
+/**
+ * Gets the true offset parent of an element, handling browser differences.
+ * Firefox returns the <html> element as the offsetParent if it's non-static,
+ * while Chrome and Safari return the <body> element. The <body> element must
+ * be used to perform the correct calculations even if the <html> element is
+ * non-static.
+ * @param element - The element to get offset parent for
+ * @param polyfill - Optional polyfill function for offset parent
+ * @returns The true offset parent or null
+ */
+function getTrueOffsetParent(element: Element, polyfill?: (element: Element) =>
+  Element | null): Element | null {
+  if (!isHTMLElement(element) || window.getComputedStyle(element).position === 'fixed') {
+    return null;
+  }
+  if (polyfill) {
+    return polyfill(element);
+  }
+  let rawOffsetParent = (element as HTMLElement).offsetParent;
+  if (getDocumentElement(element) === rawOffsetParent) {
+    rawOffsetParent = rawOffsetParent.ownerDocument.body;
+  }
+  return rawOffsetParent;
+}
+
+/**
+ * Gets the closest ancestor positioned element. Handles some edge cases,
+ * such as table ancestors and cross browser bugs.
+ * @param element - The element to get offset parent for
+ * @param polyfill - Optional polyfill function for offset parent
+ * @returns The offset parent element or window
+ */
+function getOffsetParent(element: Element, polyfill?: (element: Element) =>
+  Element | null): Element | Window {
+  const win = window;
+  if (isTopLayer(element)) {
+    return win;
+  }
+  if (!isHTMLElement(element)) {
+    let svgOffsetParent = getParentNode(element);
+    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
+      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
+        return svgOffsetParent;
+      }
+      svgOffsetParent = getParentNode(svgOffsetParent);
+    }
+    return win;
+  }
+  let offsetParent = getTrueOffsetParent(element, polyfill);
+  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
+    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
+  }
+  if (offsetParent && isLastTraversableNode(offsetParent)
+      && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
+    return win;
+  }
+  return offsetParent || getContainingBlock(element) || win;
+}
+
+/**
+ * Gets the element rects for reference and floating elements.
+ * @param data - Object containing reference, floating, and strategy
+ * @param data.reference
+ * @param data.floating
+ * @param data.strategy
+ * @returns Element rects
+ */
+function getElementRects(data: {
+  reference: Element;
+  floating: Element;
+  strategy: Strategy;
+}): ElementRects {
+  const floatingDimensions = getDimensions(data.floating);
+  return {
+    reference: getRectRelativeToOffsetParent(
+      data.reference,
+      getOffsetParent(data.floating),
+      data.strategy
+    ),
+    floating: {
+      x: 0,
+      y: 0,
+      width: floatingDimensions.width,
+      height: floatingDimensions.height,
+    },
+  };
+}
+
+/**
+ * Checks if an element is in a right-to-left (RTL) context.
+ * @param element - The element to check
+ * @returns True if the element is in RTL context
+ */
+function isRTL(element: Element): boolean {
+  return window.getComputedStyle(element).direction === 'rtl';
+}
+
+/**
+ * Checks if two client rect objects are equal.
+ * @param a - First rect object
+ * @param b - Second rect object
+ * @returns True if the rects are equal
+ */
+function rectsAreEqual(a: ClientRectObject, b: ClientRectObject): boolean {
+  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
+}
+
+/**
+ * Observes an element for movement and calls a callback when it moves.
+ * Based on https://samthor.au/2021/observing-dom/
+ * @param element - The element to observe
+ * @param onMove - Callback function called when element moves
+ * @returns Cleanup function to stop observing
+ */
+function observeMove(element: Element, onMove: () => void): () => void {
+  let io: IntersectionObserver | null = null;
+  let timeoutId: ReturnType<typeof setTimeout>;
+  const root = getDocumentElement(element)!;
+  function cleanup(): void {
+    clearTimeout(timeoutId);
+    io?.disconnect();
+    io = null;
+  }
+  function refresh(skip = false, threshold = 1): void {
+    cleanup();
+    const elementRectForRootMargin = element.getBoundingClientRect();
+    const { left, top, width, height } = elementRectForRootMargin;
+    if (!skip) {
+      onMove();
+    }
+    if (!width || !height) {
+      return;
+    }
+    const insetTop = Math.floor(top);
+    const insetRight = Math.floor(root.clientWidth - (left + width));
+    const insetBottom = Math.floor(root.clientHeight - (top + height));
+    const insetLeft = Math.floor(left);
+    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;
+    const options = {
+      rootMargin,
+      threshold: Math.max(0, Math.min(1, threshold)) || 1,
+    };
+    let isFirstUpdate = true;
+    function handleObserve(entries: IntersectionObserverEntry[]): void {
+      const ratio = entries[0].intersectionRatio;
+      if (ratio !== threshold) {
+        if (!isFirstUpdate) {
+          return refresh();
+        }
+        if (!ratio) {
+          // If the reference is clipped, the ratio is 0. Throttle the refresh
+          // to prevent an infinite loop of updates.
+          timeoutId = setTimeout(() => {
+            refresh(false, 1e-7);
+          }, 1000);
+        } else {
+          refresh(false, ratio);
+        }
+      }
+      if (ratio === 1
+        && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
+        // It's possible that even though the ratio is reported as 1, the
+        // element is not actually fully within the IntersectionObserver's root
+        // area anymore. This can happen under performance constraints. This may
+        // be a bug in the browser's IntersectionObserver implementation. To
+        // work around this, we compare the element's bounding rect now with
+        // what it was at the time we created the IntersectionObserver. If they
+        // are not equal then the element moved, so we refresh.
+        refresh();
+      }
+      isFirstUpdate = false;
+    }
+
+    // Older browsers don't support a `document` as the root and will throw an
+    // error.
+    try {
+      io = new IntersectionObserver(handleObserve, {
+        ...options,
+        // Handle <iframe>s
+        root: root.ownerDocument,
+      });
+    } catch {
+      io = new IntersectionObserver(handleObserve, options);
+    }
+    io.observe(element);
+  }
+  refresh(true);
+  return cleanup;
+}
+
+/**
+ * Automatically updates the position of the floating element when necessary.
+ * Should only be called when the floating element is mounted on the DOM or
+ * visible on the screen.
+ * @param referenceEl
+ * @param floating
+ * @param update
+ * @param options
+ * @returns cleanup function that should be invoked when the floating element is
+ * removed from the DOM or hidden from the screen.
+ * @see https://floating-ui.com/docs/autoUpdate
+ */
+function autoUpdate(
+  referenceEl: Element,
+  floating: HTMLElement,
+  update: () => void,
+  options: AutoUpdateOptions = {}
+): () => void {
+  const {
+    ancestorScroll = true,
+    ancestorResize = true,
+    elementResize = typeof ResizeObserver === 'function',
+    layoutShift = typeof IntersectionObserver === 'function',
+    animationFrame = false,
+  } = options;
+  const ancestors = ancestorScroll || ancestorResize ?
+    [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)]
+    : [];
+  ancestors.forEach(ancestor => {
+    if (ancestorScroll) {
+      ancestor.addEventListener('scroll', update, { passive: true });
+    }
+    if (ancestorResize) {
+      ancestor.addEventListener('resize', update);
+    }
+  });
+  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
+  let reobserveFrame = -1;
+  let resizeObserver: ResizeObserver | null = null;
+  if (elementResize) {
+    resizeObserver = new ResizeObserver(([firstEntry]) => {
+      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
+        // Prevent update loops when using the `size` middleware.
+        // https://github.com/floating-ui/floating-ui/issues/1740
+        resizeObserver.unobserve(floating);
+        cancelAnimationFrame(reobserveFrame);
+        reobserveFrame = requestAnimationFrame(() => {
+          resizeObserver?.observe(floating);
+        });
+      }
+      update();
+    });
+    if (referenceEl && !animationFrame) {
+      resizeObserver.observe(referenceEl);
+    }
+    resizeObserver.observe(floating);
+  }
+  let frameId: number;
+  let prevRefRect = animationFrame ? getBoundingClientRect(referenceEl) : null;
+  if (animationFrame) {
+    frameLoop();
+  }
+  function frameLoop(): void {
+    const nextRefRect = getBoundingClientRect(referenceEl);
+    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
+      update();
+    }
+    prevRefRect = nextRefRect;
+    frameId = requestAnimationFrame(frameLoop);
+  }
+  update();
+  return () => {
+    ancestors.forEach(ancestor => {
+      if (ancestorScroll) {
+        ancestor.removeEventListener('scroll', update);
+      }
+      if (ancestorResize) {
+        ancestor.removeEventListener('resize', update);
+      }
+    });
+    cleanupIo?.();
+    resizeObserver?.disconnect();
+    resizeObserver = null;
+    if (animationFrame) {
+      cancelAnimationFrame(frameId);
+    }
+  };
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/internals-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/internals-controller.d.ts
index 8d66705..2151843 100644
--- a/node_modules/@patternfly/pfe-core/controllers/internals-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/internals-controller.d.ts
@@ -2,9 +2,10 @@ import { type ReactiveController, type ReactiveControllerHost } from 'lit';
 interface InternalsControllerOptions extends Partial<ARIAMixin> {
     getHTMLElement?(): HTMLElement;
 }
+type InternalsHost = ReactiveControllerHost & HTMLElement;
 export declare class InternalsController implements ReactiveController, ARIAMixin {
     #private;
-    host: ReactiveControllerHost;
+    host: InternalsHost;
     private options?;
     private static instances;
     readonly form: ElementInternals['form'];
@@ -12,9 +13,33 @@ export declare class InternalsController implements ReactiveController, ARIAMixi
     readonly states: unknown;
     readonly willValidate: ElementInternals['willValidate'];
     readonly validationMessage: ElementInternals['validationMessage'];
-    static getLabels(host: ReactiveControllerHost): Element[];
+    static getLabels(host: InternalsHost): Element[];
+    /**
+     * Gets the ARIA posinset value from a listbox item (attribute takes precedence over internals).
+     * @param host - The listbox item element.
+     */
+    static getAriaPosInSet(host: HTMLElement): string | null;
+    /**
+     * Sets the ARIA posinset on a listbox item. Uses ElementInternals when the host has
+     * an InternalsController instance; otherwise sets/removes the host attribute.
+     * @param host - The listbox item element (option or option-like).
+     * @param value - Position in set (1-based), or null to clear.
+     */
+    static setAriaPosInSet(host: HTMLElement, value: number | string | null): void;
+    /**
+     * Gets the ARIA setsize from a listbox item (aria attribute if set or defaulting to internals).
+     * @param host - The listbox item element.
+     */
+    static getAriaSetSize(host: HTMLElement): string | null;
+    /**
+     * Sets the ARIA setsize on a listbox item. Uses ElementInternals when the host has
+     * an InternalsController instance; otherwise sets/removes the host attribute.
+     * @param host - The listbox item element (option or option-like).
+     * @param value - Total set size, or null to clear.
+     */
+    static setAriaSetSize(host: HTMLElement, value: number | string | null): void;
     static isSafari: boolean;
-    static of(host: ReactiveControllerHost, options?: InternalsControllerOptions): InternalsController;
+    static of(host: InternalsHost, options?: InternalsControllerOptions): InternalsController;
     role: string | null;
     ariaActivedescendant: string | null;
     ariaAtomic: string | null;
@@ -60,21 +85,15 @@ export declare class InternalsController implements ReactiveController, ARIAMixi
     ariaValueMin: string | null;
     ariaValueNow: string | null;
     ariaValueText: string | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
+    /** As of April 2025, the following are considered Baseline supported in evergreen browsers */
     ariaActiveDescendantElement: Element | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaControlsElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaDescribedByElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaDetailsElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaErrorMessageElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaFlowToElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
     ariaLabelledByElements: Element[] | null;
-    /** WARNING: be careful of cross-root ARIA browser support */
+    /** As of February 2026, this is not supported in Chromium browsers */
     ariaOwnsElements: Element[] | null;
     /** True when the control is disabled via it's containing fieldset element */
     get formDisabled(): boolean;
diff --git a/node_modules/@patternfly/pfe-core/controllers/internals-controller.js b/node_modules/@patternfly/pfe-core/controllers/internals-controller.js
index d43ca74..0a5fd24 100644
--- a/node_modules/@patternfly/pfe-core/controllers/internals-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/internals-controller.js
@@ -41,7 +41,7 @@ function aria(target, key) {
     protos.get(target).add(key);
 }
 function getLabelText(label) {
-    if (label.hidden) {
+    if (!(label instanceof HTMLElement) || label.hidden) {
         return '';
     }
     else {
@@ -53,6 +53,60 @@ export class InternalsController {
     static getLabels(host) {
         return Array.from(this.instances.get(host)?.internals.labels ?? []);
     }
+    /**
+     * Gets the ARIA posinset value from a listbox item (attribute takes precedence over internals).
+     * @param host - The listbox item element.
+     */
+    static getAriaPosInSet(host) {
+        return host.getAttribute('aria-posinset')
+            ?? this.instances.get(host)?.ariaPosInSet
+            ?? null;
+    }
+    /**
+     * Sets the ARIA posinset on a listbox item. Uses ElementInternals when the host has
+     * an InternalsController instance; otherwise sets/removes the host attribute.
+     * @param host - The listbox item element (option or option-like).
+     * @param value - Position in set (1-based), or null to clear.
+     */
+    static setAriaPosInSet(host, value) {
+        const instance = this.instances.get(host);
+        if (instance) {
+            instance.ariaPosInSet = value != null ? String(value) : null;
+        }
+        else if (value != null) {
+            host.setAttribute('aria-posinset', String(value));
+        }
+        else {
+            host.removeAttribute('aria-posinset');
+        }
+    }
+    /**
+     * Gets the ARIA setsize from a listbox item (aria attribute if set or defaulting to internals).
+     * @param host - The listbox item element.
+     */
+    static getAriaSetSize(host) {
+        return host.getAttribute('aria-setsize')
+            ?? this.instances.get(host)?.ariaSetSize
+            ?? null;
+    }
+    /**
+     * Sets the ARIA setsize on a listbox item. Uses ElementInternals when the host has
+     * an InternalsController instance; otherwise sets/removes the host attribute.
+     * @param host - The listbox item element (option or option-like).
+     * @param value - Total set size, or null to clear.
+     */
+    static setAriaSetSize(host, value) {
+        const instance = this.instances.get(host);
+        if (instance) {
+            instance.ariaSetSize = value != null ? String(value) : null;
+        }
+        else if (value != null) {
+            host.setAttribute('aria-setsize', String(value));
+        }
+        else {
+            host.removeAttribute('aria-setsize');
+        }
+    }
     static of(host, options) {
         constructingAllowed = true;
         // implement the singleton pattern
@@ -87,8 +141,6 @@ export class InternalsController {
     }
     get element() {
         if (isServer) {
-            // FIXME(bennyp): a little white lie, which may break
-            // when the controller is applied to non-lit frameworks.
             return this.host;
         }
         else {
@@ -144,21 +196,15 @@ export class InternalsController {
         this.ariaValueMin = null;
         this.ariaValueNow = null;
         this.ariaValueText = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
+        /** As of April 2025, the following are considered Baseline supported in evergreen browsers */
         this.ariaActiveDescendantElement = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaControlsElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaDescribedByElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaDetailsElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaErrorMessageElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaFlowToElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
         this.ariaLabelledByElements = null;
-        /** WARNING: be careful of cross-root ARIA browser support */
+        /** As of February 2026, this is not supported in Chromium browsers */
         this.ariaOwnsElements = null;
         this._formDisabled = false;
         if (!constructingAllowed) {
diff --git a/node_modules/@patternfly/pfe-core/controllers/internals-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/internals-controller.js.map
index 84d588b..b1205fd 100644
--- a/node_modules/@patternfly/pfe-core/controllers/internals-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/internals-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"internals-controller.js","sourceRoot":"","sources":["internals-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  isServer,\n  type ReactiveController,\n  type ReactiveControllerHost,\n  type LitElement,\n} from 'lit';\n\nfunction isARIAMixinProp(key: string): key is keyof ARIAMixin {\n  return key === 'role' || key.startsWith('aria');\n}\n\ntype FACE = HTMLElement & {\n  formDisabledCallback?(disabled: boolean): void;\n};\n\nconst protos = new WeakMap();\n\nlet constructingAllowed = false;\n\ninterface InternalsControllerOptions extends Partial<ARIAMixin> {\n  getHTMLElement?(): HTMLElement;\n}\n\n/**\n * reactively forward the internals object's aria mixin prototype\n * @param target\n * @param key\n */\nfunction aria(\n  target: InternalsController,\n  key: keyof InternalsController,\n) {\n  if (!protos.has(target)) {\n    protos.set(target, new Set());\n  }\n  if (protos.get(target).has(key)) {\n    return;\n  }\n  if (!isARIAMixinProp(key)) {\n    throw new Error('@aria can only be called on ARIAMixin properties');\n  }\n  // typescript experimental decorator\n  Object.defineProperty(target, key, {\n    enumerable: true,\n    configurable: false,\n    get(this: InternalsController) {\n      // @ts-expect-error: because i'm bad, i'm bad\n      const internals = this.attachOrRetrieveInternals();\n      return internals[key];\n    },\n    set(this: InternalsController, value: string | null) {\n      // @ts-expect-error: ya know it!\n      const internals = this.attachOrRetrieveInternals();\n      // @ts-expect-error: shamone!\n      internals[key] = value;\n      this.host.requestUpdate();\n    },\n  });\n  protos.get(target).add(key);\n}\n\nfunction getLabelText(label: HTMLElement) {\n  if (label.hidden) {\n    return '';\n  } else {\n    const ariaLabel = label.getAttribute?.('aria-label');\n    return ariaLabel ?? label.textContent;\n  }\n}\n\nexport class InternalsController implements ReactiveController, ARIAMixin {\n  private static instances = new WeakMap<ReactiveControllerHost, InternalsController>();\n\n  declare readonly form: ElementInternals['form'];\n  declare readonly shadowRoot: ElementInternals['shadowRoot'];\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/states\n  declare readonly states: unknown;\n  declare readonly willValidate: ElementInternals['willValidate'];\n  declare readonly validationMessage: ElementInternals['validationMessage'];\n\n  public static getLabels(host: ReactiveControllerHost): Element[] {\n    return Array.from(this.instances.get(host)?.internals.labels ?? []) as Element[];\n  }\n\n  public static isSafari: boolean =\n    !isServer && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n  public static of(\n    host: ReactiveControllerHost,\n    options?: InternalsControllerOptions,\n  ): InternalsController {\n    constructingAllowed = true;\n    // implement the singleton pattern\n    // using a public static constructor method is much easier to manage,\n    // due to the quirks of our typescript config\n    const instance: InternalsController =\n      InternalsController.instances.get(host)\n      ?? new InternalsController(host, options);\n    instance.initializeOptions(options);\n    constructingAllowed = false;\n    return instance;\n  }\n\n  @aria role: string | null = null;\n\n  @aria ariaActivedescendant: string | null = null;\n  @aria ariaAtomic: string | null = null;\n  @aria ariaAutoComplete: string | null = null;\n  @aria ariaBusy: string | null = null;\n  @aria ariaBrailleLabel: string | null = null;\n  @aria ariaBrailleRoleDescription: string | null = null;\n  @aria ariaChecked: string | null = null;\n  @aria ariaColCount: string | null = null;\n  @aria ariaColIndex: string | null = null;\n  @aria ariaColIndexText: string | null = null;\n  @aria ariaColSpan: string | null = null;\n  @aria ariaCurrent: string | null = null;\n  @aria ariaDescription: string | null = null;\n  @aria ariaDisabled: string | null = null;\n  @aria ariaExpanded: string | null = null;\n  @aria ariaHasPopup: string | null = null;\n  @aria ariaHidden: string | null = null;\n  @aria ariaInvalid: string | null = null;\n  @aria ariaKeyShortcuts: string | null = null;\n  @aria ariaLabel: string | null = null;\n  @aria ariaLevel: string | null = null;\n  @aria ariaLive: string | null = null;\n  @aria ariaModal: string | null = null;\n  @aria ariaMultiLine: string | null = null;\n  @aria ariaMultiSelectable: string | null = null;\n  @aria ariaOrientation: string | null = null;\n  @aria ariaPlaceholder: string | null = null;\n  @aria ariaPosInSet: string | null = null;\n  @aria ariaPressed: string | null = null;\n  @aria ariaReadOnly: string | null = null;\n  @aria ariaRelevant: string | null = null;\n  @aria ariaRequired: string | null = null;\n  @aria ariaRoleDescription: string | null = null;\n  @aria ariaRowCount: string | null = null;\n  @aria ariaRowIndex: string | null = null;\n  @aria ariaRowIndexText: string | null = null;\n  @aria ariaRowSpan: string | null = null;\n  @aria ariaSelected: string | null = null;\n  @aria ariaSetSize: string | null = null;\n  @aria ariaSort: string | null = null;\n  @aria ariaValueMax: string | null = null;\n  @aria ariaValueMin: string | null = null;\n  @aria ariaValueNow: string | null = null;\n  @aria ariaValueText: string | null = null;\n\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaActiveDescendantElement: Element | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaControlsElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaDescribedByElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaDetailsElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaErrorMessageElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaFlowToElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaLabelledByElements: Element[] | null = null;\n  /** WARNING: be careful of cross-root ARIA browser support */\n  @aria ariaOwnsElements: Element[] | null = null;\n\n  /** True when the control is disabled via it's containing fieldset element */\n  get formDisabled(): boolean {\n    if (isServer) {\n      return this._formDisabled;\n    } else {\n      return this.element?.matches(':disabled') || this._formDisabled;\n    }\n  }\n\n  get labels(): NodeList {\n    return this.internals.labels;\n  }\n\n  get validity(): ValidityState {\n    return this.internals.validity;\n  }\n\n  /** A best-attempt based on observed behaviour in FireFox 115 on fedora 38 */\n  get computedLabelText(): string {\n    return this.internals.ariaLabel\n      || Array.from(this.internals.labels as NodeListOf<HTMLElement>)\n          .reduce((acc, label) =>\n            `${acc}${getLabelText(label)}`, '');\n  }\n\n  private get element() {\n    if (isServer) {\n      // FIXME(bennyp): a little white lie, which may break\n      // when the controller is applied to non-lit frameworks.\n      return this.host as LitElement;\n    } else {\n      return this.host instanceof HTMLElement ? this.host : this.options?.getHTMLElement?.();\n    }\n  }\n\n  private internals!: ElementInternals;\n\n  private _formDisabled = false;\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    private options?: InternalsControllerOptions,\n  ) {\n    if (!constructingAllowed) {\n      throw new Error('InternalsController must be constructed with `InternalsController.for()`');\n    }\n    if (!this.element) {\n      throw new Error(\n        `InternalsController must be instantiated with an HTMLElement or a \\`getHTMLElement\\` function`,\n      );\n    }\n    this.attachOrRetrieveInternals();\n    this.initializeOptions(options);\n    InternalsController.instances.set(host, this);\n    this.#polyfillDisabledPseudo();\n  }\n\n  /**\n   * We need to polyfill :disabled\n   * see https://github.com/calebdwilliams/element-internals-polyfill/issues/88\n   */\n  #polyfillDisabledPseudo() {\n    // START polyfill-disabled\n    // We need to polyfill :disabled\n    // see https://github.com/calebdwilliams/element-internals-polyfill/issues/88\n    const orig = (this.element as FACE).formDisabledCallback;\n    (this.element as FACE).formDisabledCallback = disabled => {\n      this._formDisabled = disabled;\n      orig?.call(this.host, disabled);\n    // END polyfill-disabled\n    };\n  }\n\n  /**\n   * Typescript (with experimental decorators) will compile the class\n   * such that the order of operations is:\n   * 1. set up constructor parameter fields\n   * 2. run decorated field setters with initializers as the value\n   * 3. run the rest of the constructor\n   * Because of that, `this.internals` may not be available in the decorator setter\n   * so we cheat here with nullish coalescing assignment operator `??=`;\n   */\n  private attachOrRetrieveInternals() {\n    this.internals ??= this.element!.attachInternals();\n    return this.internals;\n  }\n\n  private initializeOptions(options?: Partial<ARIAMixin>) {\n    this.options ??= options ?? {};\n    const { getHTMLElement, ...aria } = this.options;\n    this.options.getHTMLElement ??= getHTMLElement;\n    for (const [key, val] of Object.entries(aria)) {\n      if (isARIAMixinProp(key)) {\n        this[key as keyof this] = val as this[keyof this];\n      }\n    }\n  }\n\n  hostConnected?(): void;\n\n  setFormValue(...args: Parameters<ElementInternals['setFormValue']>): void {\n    return this.internals.setFormValue(...args);\n  }\n\n  setValidity(...args: Parameters<ElementInternals['setValidity']>): void {\n    return this.internals.setValidity(...args);\n  }\n\n  checkValidity(...args: Parameters<ElementInternals['checkValidity']>): boolean {\n    return this.internals.checkValidity(...args);\n  }\n\n  reportValidity(...args: Parameters<ElementInternals['reportValidity']>): boolean {\n    return this.internals.reportValidity(...args);\n  }\n\n  submit(): void {\n    this.internals.form?.requestSubmit();\n  }\n\n  reset(): void {\n    this.internals.form?.reset();\n  }\n}\n\n/** @see https://w3c.github.io/aria/#ref-for-dom-ariamixin-ariaactivedescendantelement-1 */\ndeclare global {\n  interface ARIAMixin {\n    ariaActiveDescendantElement: Element | null;\n    ariaControlsElements: readonly Element[] | null;\n    ariaDescribedByElements: readonly Element[] | null;\n    ariaDetailsElements: readonly Element[] | null;\n    ariaErrorMessageElements: readonly Element[] | null;\n    ariaFlowToElements: readonly Element[] | null;\n    ariaLabelledByElements: readonly Element[] | null;\n    ariaOwnsElements: readonly Element[] | null;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"internals-controller.js","sourceRoot":"","sources":["internals-controller.ts"],"names":[],"mappings":";;AAAA,OAAO,EACL,QAAQ,GAGT,MAAM,KAAK,CAAC;AAEb,SAAS,eAAe,CAAC,GAAW;IAClC,OAAO,GAAG,KAAK,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAClD,CAAC;AAMD,MAAM,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;AAE7B,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAMhC;;;;GAIG;AACH,SAAS,IAAI,CACX,MAA2B,EAC3B,GAA8B;IAE9B,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;QACxB,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;IAChC,CAAC;IACD,IAAI,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;QAChC,OAAO;IACT,CAAC;IACD,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,CAAC;QAC1B,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;IACtE,CAAC;IACD,oCAAoC;IACpC,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE;QACjC,UAAU,EAAE,IAAI;QAChB,YAAY,EAAE,KAAK;QACnB,GAAG;YACD,6CAA6C;YAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACnD,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC;QACD,GAAG,CAA4B,KAAoB;YACjD,gCAAgC;YAChC,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACnD,6BAA6B;YAC7B,SAAS,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YACvB,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC5B,CAAC;KACF,CAAC,CAAC;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,YAAY,CAAC,KAAW;IAC/B,IAAI,CAAC,CAAC,KAAK,YAAY,WAAW,CAAC,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;QACpD,OAAO,EAAE,CAAC;IACZ,CAAC;SAAM,CAAC;QACN,MAAM,SAAS,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC,YAAY,CAAC,CAAC;QACrD,OAAO,SAAS,IAAI,KAAK,CAAC,WAAW,CAAC;IACxC,CAAC;AACH,CAAC;AAID,MAAM,OAAO,mBAAmB;IAWvB,MAAM,CAAC,SAAS,CAAC,IAAmB;QACzC,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,SAAS,CAAC,MAAM,IAAI,EAAE,CAAc,CAAC;IACnF,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,eAAe,CAAC,IAAiB;QAC7C,OAAO,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC;eAClC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,YAAY;eACtC,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,eAAe,CAAC,IAAiB,EAAE,KAA6B;QAC5E,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,YAAY,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC/D,CAAC;aAAM,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YACzB,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QACpD,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,cAAc,CAAC,IAAiB;QAC5C,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC;eACjC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,WAAW;eACrC,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,cAAc,CAAC,IAAiB,EAAE,KAA6B;QAC3E,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,WAAW,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC9D,CAAC;aAAM,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YACzB,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QACnD,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;QACvC,CAAC;IACH,CAAC;IAKM,MAAM,CAAC,EAAE,CAAC,IAAmB,EAAE,OAAoC;QACxE,mBAAmB,GAAG,IAAI,CAAC;QAC3B,kCAAkC;QAClC,qEAAqE;QACrE,6CAA6C;QAC7C,MAAM,QAAQ,GACZ,mBAAmB,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC;eACpC,IAAI,mBAAmB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5C,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACpC,mBAAmB,GAAG,KAAK,CAAC;QAC5B,OAAO,QAAQ,CAAC;IAClB,CAAC;IA6DD,6EAA6E;IAC7E,IAAI,YAAY;QACd,IAAI,QAAQ,EAAE,CAAC;YACb,OAAO,IAAI,CAAC,aAAa,CAAC;QAC5B,CAAC;aAAM,CAAC;YACN,OAAO,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,WAAW,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC;QAClE,CAAC;IACH,CAAC;IAED,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,CAAC;IAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;IACjC,CAAC;IAED,6EAA6E;IAC7E,IAAI,iBAAiB;QACnB,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS;eAC1B,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;iBAC/B,MAAM,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CACrB,GAAG,GAAG,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAC9C,CAAC;IAED,IAAY,OAAO;QACjB,IAAI,QAAQ,EAAE,CAAC;YACb,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;aAAM,CAAC;YACN,OAAO,IAAI,CAAC,IAAI,YAAY,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,CAAC;QACzF,CAAC;IACH,CAAC;IAMD,YAA2B,IAAmB,EAAU,OAAoC;;QAAjE,SAAI,GAAJ,IAAI,CAAe;QAAU,YAAO,GAAP,OAAO,CAA6B;QAhGtF,SAAI,GAAkB,IAAI,CAAC;QAE3B,yBAAoB,GAAkB,IAAI,CAAC;QAC3C,eAAU,GAAkB,IAAI,CAAC;QACjC,qBAAgB,GAAkB,IAAI,CAAC;QACvC,aAAQ,GAAkB,IAAI,CAAC;QAC/B,qBAAgB,GAAkB,IAAI,CAAC;QACvC,+BAA0B,GAAkB,IAAI,CAAC;QACjD,gBAAW,GAAkB,IAAI,CAAC;QAClC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,qBAAgB,GAAkB,IAAI,CAAC;QACvC,gBAAW,GAAkB,IAAI,CAAC;QAClC,gBAAW,GAAkB,IAAI,CAAC;QAClC,oBAAe,GAAkB,IAAI,CAAC;QACtC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,eAAU,GAAkB,IAAI,CAAC;QACjC,gBAAW,GAAkB,IAAI,CAAC;QAClC,qBAAgB,GAAkB,IAAI,CAAC;QACvC,cAAS,GAAkB,IAAI,CAAC;QAChC,cAAS,GAAkB,IAAI,CAAC;QAChC,aAAQ,GAAkB,IAAI,CAAC;QAC/B,cAAS,GAAkB,IAAI,CAAC;QAChC,kBAAa,GAAkB,IAAI,CAAC;QACpC,wBAAmB,GAAkB,IAAI,CAAC;QAC1C,oBAAe,GAAkB,IAAI,CAAC;QACtC,oBAAe,GAAkB,IAAI,CAAC;QACtC,iBAAY,GAAkB,IAAI,CAAC;QACnC,gBAAW,GAAkB,IAAI,CAAC;QAClC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,wBAAmB,GAAkB,IAAI,CAAC;QAC1C,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,qBAAgB,GAAkB,IAAI,CAAC;QACvC,gBAAW,GAAkB,IAAI,CAAC;QAClC,iBAAY,GAAkB,IAAI,CAAC;QACnC,gBAAW,GAAkB,IAAI,CAAC;QAClC,aAAQ,GAAkB,IAAI,CAAC;QAC/B,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,iBAAY,GAAkB,IAAI,CAAC;QACnC,kBAAa,GAAkB,IAAI,CAAC;QAE1C,8FAA8F;QACxF,gCAA2B,GAAmB,IAAI,CAAC;QACnD,yBAAoB,GAAqB,IAAI,CAAC;QAC9C,4BAAuB,GAAqB,IAAI,CAAC;QACjD,wBAAmB,GAAqB,IAAI,CAAC;QAC7C,6BAAwB,GAAqB,IAAI,CAAC;QAClD,uBAAkB,GAAqB,IAAI,CAAC;QAC5C,2BAAsB,GAAqB,IAAI,CAAC;QAEtD,sEAAsE;QAChE,qBAAgB,GAAqB,IAAI,CAAC;QAqCxC,kBAAa,GAAG,KAAK,CAAC;QAG5B,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,0EAA0E,CAAC,CAAC;QAC9F,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YAClB,MAAM,IAAI,KAAK,CACb,+FAA+F,CAChG,CAAC;QACJ,CAAC;QACD,IAAI,CAAC,yBAAyB,EAAE,CAAC;QACjC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAChC,mBAAmB,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC9C,uBAAA,IAAI,mFAAwB,MAA5B,IAAI,CAA0B,CAAC;IACjC,CAAC;IAkBD;;;;;;;;OAQG;IACK,yBAAyB;QAC/B,IAAI,CAAC,SAAS,KAAd,IAAI,CAAC,SAAS,GAAK,IAAI,CAAC,OAAQ,CAAC,eAAe,EAAE,EAAC;QACnD,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAEO,iBAAiB,CAAC,OAA4B;;QACpD,IAAI,CAAC,OAAO,KAAZ,IAAI,CAAC,OAAO,GAAK,OAAO,IAAI,EAAE,EAAC;QAC/B,MAAM,EAAE,cAAc,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC;QACjD,MAAA,IAAI,CAAC,OAAO,EAAC,cAAc,QAAd,cAAc,GAAK,cAAc,EAAC;QAC/C,KAAK,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YAC9C,IAAI,eAAe,CAAC,GAAG,CAAC,EAAE,CAAC;gBACzB,IAAI,CAAC,GAAiB,CAAC,GAAG,GAAuB,CAAC;YACpD,CAAC;QACH,CAAC;IACH,CAAC;IAID,YAAY,CAAC,GAAG,IAAkD;QAChE,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED,WAAW,CAAC,GAAG,IAAiD;QAC9D,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED,aAAa,CAAC,GAAG,IAAmD;QAClE,OAAO,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,IAAI,CAAC,CAAC;IAC/C,CAAC;IAED,cAAc,CAAC,GAAG,IAAoD;QACpE,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,CAAC;IAED,MAAM;QACJ,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC;IACvC,CAAC;IAED,KAAK;QACH,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC;IAC/B,CAAC;;;IA5DC,0BAA0B;IAC1B,gCAAgC;IAChC,6EAA6E;IAC7E,MAAM,IAAI,GAAI,IAAI,CAAC,OAAgB,CAAC,oBAAoB,CAAC;IACxD,IAAI,CAAC,OAAgB,CAAC,oBAAoB,GAAG,QAAQ,CAAC,EAAE;QACvD,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAClC,wBAAwB;IACxB,CAAC,CAAC;AACJ,CAAC;AAjNc,6BAAS,GAAG,IAAI,OAAO,EAAoC,AAAlD,CAAmD;AAoE7D,4BAAQ,GACpB,CAAC,QAAQ,IAAI,gCAAgC,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,AADnD,CACoD;AAepE;IAAL,IAAI;iDAA4B;AAE3B;IAAL,IAAI;iEAA4C;AAC3C;IAAL,IAAI;uDAAkC;AACjC;IAAL,IAAI;6DAAwC;AACvC;IAAL,IAAI;qDAAgC;AAC/B;IAAL,IAAI;6DAAwC;AACvC;IAAL,IAAI;uEAAkD;AACjD;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;6DAAwC;AACvC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;4DAAuC;AACtC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;uDAAkC;AACjC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;6DAAwC;AACvC;IAAL,IAAI;sDAAiC;AAChC;IAAL,IAAI;sDAAiC;AAChC;IAAL,IAAI;qDAAgC;AAC/B;IAAL,IAAI;sDAAiC;AAChC;IAAL,IAAI;0DAAqC;AACpC;IAAL,IAAI;gEAA2C;AAC1C;IAAL,IAAI;4DAAuC;AACtC;IAAL,IAAI;4DAAuC;AACtC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;gEAA2C;AAC1C;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;6DAAwC;AACvC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;wDAAmC;AAClC;IAAL,IAAI;qDAAgC;AAC/B;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;yDAAoC;AACnC;IAAL,IAAI;0DAAqC;AAGpC;IAAL,IAAI;wEAAoD;AACnD;IAAL,IAAI;iEAA+C;AAC9C;IAAL,IAAI;oEAAkD;AACjD;IAAL,IAAI;gEAA8C;AAC7C;IAAL,IAAI;qEAAmD;AAClD;IAAL,IAAI;+DAA6C;AAC5C;IAAL,IAAI;mEAAiD;AAGhD;IAAL,IAAI;6DAA2C","sourcesContent":["import {\n  isServer,\n  type ReactiveController,\n  type ReactiveControllerHost,\n} from 'lit';\n\nfunction isARIAMixinProp(key: string): key is keyof ARIAMixin {\n  return key === 'role' || key.startsWith('aria');\n}\n\ntype FACE = HTMLElement & {\n  formDisabledCallback?(disabled: boolean): void;\n};\n\nconst protos = new WeakMap();\n\nlet constructingAllowed = false;\n\ninterface InternalsControllerOptions extends Partial<ARIAMixin> {\n  getHTMLElement?(): HTMLElement;\n}\n\n/**\n * reactively forward the internals object's aria mixin prototype\n * @param target\n * @param key\n */\nfunction aria(\n  target: InternalsController,\n  key: keyof InternalsController,\n) {\n  if (!protos.has(target)) {\n    protos.set(target, new Set());\n  }\n  if (protos.get(target).has(key)) {\n    return;\n  }\n  if (!isARIAMixinProp(key)) {\n    throw new Error('@aria can only be called on ARIAMixin properties');\n  }\n  // typescript experimental decorator\n  Object.defineProperty(target, key, {\n    enumerable: true,\n    configurable: false,\n    get(this: InternalsController) {\n      // @ts-expect-error: because i'm bad, i'm bad\n      const internals = this.attachOrRetrieveInternals();\n      return internals[key];\n    },\n    set(this: InternalsController, value: string | null) {\n      // @ts-expect-error: ya know it!\n      const internals = this.attachOrRetrieveInternals();\n      // @ts-expect-error: shamone!\n      internals[key] = value;\n      this.host.requestUpdate();\n    },\n  });\n  protos.get(target).add(key);\n}\n\nfunction getLabelText(label: Node) {\n  if (!(label instanceof HTMLElement) || label.hidden) {\n    return '';\n  } else {\n    const ariaLabel = label.getAttribute?.('aria-label');\n    return ariaLabel ?? label.textContent;\n  }\n}\n\ntype InternalsHost = ReactiveControllerHost & HTMLElement;\n\nexport class InternalsController implements ReactiveController, ARIAMixin {\n  private static instances = new WeakMap<HTMLElement, InternalsController>();\n\n  declare readonly form: ElementInternals['form'];\n  declare readonly shadowRoot: ElementInternals['shadowRoot'];\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/states\n  declare readonly states: unknown;\n  declare readonly willValidate: ElementInternals['willValidate'];\n  declare readonly validationMessage: ElementInternals['validationMessage'];\n\n  public static getLabels(host: InternalsHost): Element[] {\n    return Array.from(this.instances.get(host)?.internals.labels ?? []) as Element[];\n  }\n\n  /**\n   * Gets the ARIA posinset value from a listbox item (attribute takes precedence over internals).\n   * @param host - The listbox item element.\n   */\n  public static getAriaPosInSet(host: HTMLElement): string | null {\n    return host.getAttribute('aria-posinset')\n        ?? this.instances.get(host)?.ariaPosInSet\n        ?? null;\n  }\n\n  /**\n   * Sets the ARIA posinset on a listbox item. Uses ElementInternals when the host has\n   * an InternalsController instance; otherwise sets/removes the host attribute.\n   * @param host - The listbox item element (option or option-like).\n   * @param value - Position in set (1-based), or null to clear.\n   */\n  public static setAriaPosInSet(host: HTMLElement, value: number | string | null): void {\n    const instance = this.instances.get(host);\n    if (instance) {\n      instance.ariaPosInSet = value != null ? String(value) : null;\n    } else if (value != null) {\n      host.setAttribute('aria-posinset', String(value));\n    } else {\n      host.removeAttribute('aria-posinset');\n    }\n  }\n\n  /**\n   * Gets the ARIA setsize from a listbox item (aria attribute if set or defaulting to internals).\n   * @param host - The listbox item element.\n   */\n  public static getAriaSetSize(host: HTMLElement): string | null {\n    return host.getAttribute('aria-setsize')\n        ?? this.instances.get(host)?.ariaSetSize\n        ?? null;\n  }\n\n  /**\n   * Sets the ARIA setsize on a listbox item. Uses ElementInternals when the host has\n   * an InternalsController instance; otherwise sets/removes the host attribute.\n   * @param host - The listbox item element (option or option-like).\n   * @param value - Total set size, or null to clear.\n   */\n  public static setAriaSetSize(host: HTMLElement, value: number | string | null): void {\n    const instance = this.instances.get(host);\n    if (instance) {\n      instance.ariaSetSize = value != null ? String(value) : null;\n    } else if (value != null) {\n      host.setAttribute('aria-setsize', String(value));\n    } else {\n      host.removeAttribute('aria-setsize');\n    }\n  }\n\n  public static isSafari: boolean =\n    !isServer && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n  public static of(host: InternalsHost, options?: InternalsControllerOptions): InternalsController {\n    constructingAllowed = true;\n    // implement the singleton pattern\n    // using a public static constructor method is much easier to manage,\n    // due to the quirks of our typescript config\n    const instance: InternalsController =\n      InternalsController.instances.get(host)\n      ?? new InternalsController(host, options);\n    instance.initializeOptions(options);\n    constructingAllowed = false;\n    return instance;\n  }\n\n  @aria role: string | null = null;\n\n  @aria ariaActivedescendant: string | null = null;\n  @aria ariaAtomic: string | null = null;\n  @aria ariaAutoComplete: string | null = null;\n  @aria ariaBusy: string | null = null;\n  @aria ariaBrailleLabel: string | null = null;\n  @aria ariaBrailleRoleDescription: string | null = null;\n  @aria ariaChecked: string | null = null;\n  @aria ariaColCount: string | null = null;\n  @aria ariaColIndex: string | null = null;\n  @aria ariaColIndexText: string | null = null;\n  @aria ariaColSpan: string | null = null;\n  @aria ariaCurrent: string | null = null;\n  @aria ariaDescription: string | null = null;\n  @aria ariaDisabled: string | null = null;\n  @aria ariaExpanded: string | null = null;\n  @aria ariaHasPopup: string | null = null;\n  @aria ariaHidden: string | null = null;\n  @aria ariaInvalid: string | null = null;\n  @aria ariaKeyShortcuts: string | null = null;\n  @aria ariaLabel: string | null = null;\n  @aria ariaLevel: string | null = null;\n  @aria ariaLive: string | null = null;\n  @aria ariaModal: string | null = null;\n  @aria ariaMultiLine: string | null = null;\n  @aria ariaMultiSelectable: string | null = null;\n  @aria ariaOrientation: string | null = null;\n  @aria ariaPlaceholder: string | null = null;\n  @aria ariaPosInSet: string | null = null;\n  @aria ariaPressed: string | null = null;\n  @aria ariaReadOnly: string | null = null;\n  @aria ariaRelevant: string | null = null;\n  @aria ariaRequired: string | null = null;\n  @aria ariaRoleDescription: string | null = null;\n  @aria ariaRowCount: string | null = null;\n  @aria ariaRowIndex: string | null = null;\n  @aria ariaRowIndexText: string | null = null;\n  @aria ariaRowSpan: string | null = null;\n  @aria ariaSelected: string | null = null;\n  @aria ariaSetSize: string | null = null;\n  @aria ariaSort: string | null = null;\n  @aria ariaValueMax: string | null = null;\n  @aria ariaValueMin: string | null = null;\n  @aria ariaValueNow: string | null = null;\n  @aria ariaValueText: string | null = null;\n\n  /** As of April 2025, the following are considered Baseline supported in evergreen browsers */\n  @aria ariaActiveDescendantElement: Element | null = null;\n  @aria ariaControlsElements: Element[] | null = null;\n  @aria ariaDescribedByElements: Element[] | null = null;\n  @aria ariaDetailsElements: Element[] | null = null;\n  @aria ariaErrorMessageElements: Element[] | null = null;\n  @aria ariaFlowToElements: Element[] | null = null;\n  @aria ariaLabelledByElements: Element[] | null = null;\n\n  /** As of February 2026, this is not supported in Chromium browsers */\n  @aria ariaOwnsElements: Element[] | null = null;\n\n  /** True when the control is disabled via it's containing fieldset element */\n  get formDisabled(): boolean {\n    if (isServer) {\n      return this._formDisabled;\n    } else {\n      return this.element?.matches(':disabled') || this._formDisabled;\n    }\n  }\n\n  get labels(): NodeList {\n    return this.internals.labels;\n  }\n\n  get validity(): ValidityState {\n    return this.internals.validity;\n  }\n\n  /** A best-attempt based on observed behaviour in FireFox 115 on fedora 38 */\n  get computedLabelText(): string {\n    return this.internals.ariaLabel\n      || Array.from(this.internals.labels)\n          .reduce((acc, label) =>\n            `${acc}${getLabelText(label)}`, '');\n  }\n\n  private get element() {\n    if (isServer) {\n      return this.host;\n    } else {\n      return this.host instanceof HTMLElement ? this.host : this.options?.getHTMLElement?.();\n    }\n  }\n\n  private internals!: ElementInternals;\n\n  private _formDisabled = false;\n\n  private constructor(public host: InternalsHost, private options?: InternalsControllerOptions) {\n    if (!constructingAllowed) {\n      throw new Error('InternalsController must be constructed with `InternalsController.for()`');\n    }\n    if (!this.element) {\n      throw new Error(\n        `InternalsController must be instantiated with an HTMLElement or a \\`getHTMLElement\\` function`,\n      );\n    }\n    this.attachOrRetrieveInternals();\n    this.initializeOptions(options);\n    InternalsController.instances.set(host, this);\n    this.#polyfillDisabledPseudo();\n  }\n\n  /**\n   * We need to polyfill :disabled\n   * see https://github.com/calebdwilliams/element-internals-polyfill/issues/88\n   */\n  #polyfillDisabledPseudo() {\n    // START polyfill-disabled\n    // We need to polyfill :disabled\n    // see https://github.com/calebdwilliams/element-internals-polyfill/issues/88\n    const orig = (this.element as FACE).formDisabledCallback;\n    (this.element as FACE).formDisabledCallback = disabled => {\n      this._formDisabled = disabled;\n      orig?.call(this.host, disabled);\n    // END polyfill-disabled\n    };\n  }\n\n  /**\n   * Typescript (with experimental decorators) will compile the class\n   * such that the order of operations is:\n   * 1. set up constructor parameter fields\n   * 2. run decorated field setters with initializers as the value\n   * 3. run the rest of the constructor\n   * Because of that, `this.internals` may not be available in the decorator setter\n   * so we cheat here with nullish coalescing assignment operator `??=`;\n   */\n  private attachOrRetrieveInternals() {\n    this.internals ??= this.element!.attachInternals();\n    return this.internals;\n  }\n\n  private initializeOptions(options?: Partial<ARIAMixin>) {\n    this.options ??= options ?? {};\n    const { getHTMLElement, ...aria } = this.options;\n    this.options.getHTMLElement ??= getHTMLElement;\n    for (const [key, val] of Object.entries(aria)) {\n      if (isARIAMixinProp(key)) {\n        this[key as keyof this] = val as this[keyof this];\n      }\n    }\n  }\n\n  hostConnected?(): void;\n\n  setFormValue(...args: Parameters<ElementInternals['setFormValue']>): void {\n    return this.internals.setFormValue(...args);\n  }\n\n  setValidity(...args: Parameters<ElementInternals['setValidity']>): void {\n    return this.internals.setValidity(...args);\n  }\n\n  checkValidity(...args: Parameters<ElementInternals['checkValidity']>): boolean {\n    return this.internals.checkValidity(...args);\n  }\n\n  reportValidity(...args: Parameters<ElementInternals['reportValidity']>): boolean {\n    return this.internals.reportValidity(...args);\n  }\n\n  submit(): void {\n    this.internals.form?.requestSubmit();\n  }\n\n  reset(): void {\n    this.internals.form?.reset();\n  }\n}\n\n/** @see https://w3c.github.io/aria/#ref-for-dom-ariamixin-ariaactivedescendantelement-1 */\ndeclare global {\n  interface ARIAMixin {\n    ariaActiveDescendantElement: Element | null;\n    ariaControlsElements: readonly Element[] | null;\n    ariaDescribedByElements: readonly Element[] | null;\n    ariaDetailsElements: readonly Element[] | null;\n    ariaErrorMessageElements: readonly Element[] | null;\n    ariaFlowToElements: readonly Element[] | null;\n    ariaLabelledByElements: readonly Element[] | null;\n    ariaOwnsElements: readonly Element[] | null;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/internals-controller.ts b/node_modules/@patternfly/pfe-core/controllers/internals-controller.ts
new file mode 100644
index 0000000..84b8c7a
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/internals-controller.ts
@@ -0,0 +1,348 @@
+import {
+  isServer,
+  type ReactiveController,
+  type ReactiveControllerHost,
+} from 'lit';
+
+function isARIAMixinProp(key: string): key is keyof ARIAMixin {
+  return key === 'role' || key.startsWith('aria');
+}
+
+type FACE = HTMLElement & {
+  formDisabledCallback?(disabled: boolean): void;
+};
+
+const protos = new WeakMap();
+
+let constructingAllowed = false;
+
+interface InternalsControllerOptions extends Partial<ARIAMixin> {
+  getHTMLElement?(): HTMLElement;
+}
+
+/**
+ * reactively forward the internals object's aria mixin prototype
+ * @param target
+ * @param key
+ */
+function aria(
+  target: InternalsController,
+  key: keyof InternalsController,
+) {
+  if (!protos.has(target)) {
+    protos.set(target, new Set());
+  }
+  if (protos.get(target).has(key)) {
+    return;
+  }
+  if (!isARIAMixinProp(key)) {
+    throw new Error('@aria can only be called on ARIAMixin properties');
+  }
+  // typescript experimental decorator
+  Object.defineProperty(target, key, {
+    enumerable: true,
+    configurable: false,
+    get(this: InternalsController) {
+      // @ts-expect-error: because i'm bad, i'm bad
+      const internals = this.attachOrRetrieveInternals();
+      return internals[key];
+    },
+    set(this: InternalsController, value: string | null) {
+      // @ts-expect-error: ya know it!
+      const internals = this.attachOrRetrieveInternals();
+      // @ts-expect-error: shamone!
+      internals[key] = value;
+      this.host.requestUpdate();
+    },
+  });
+  protos.get(target).add(key);
+}
+
+function getLabelText(label: Node) {
+  if (!(label instanceof HTMLElement) || label.hidden) {
+    return '';
+  } else {
+    const ariaLabel = label.getAttribute?.('aria-label');
+    return ariaLabel ?? label.textContent;
+  }
+}
+
+type InternalsHost = ReactiveControllerHost & HTMLElement;
+
+export class InternalsController implements ReactiveController, ARIAMixin {
+  private static instances = new WeakMap<HTMLElement, InternalsController>();
+
+  declare readonly form: ElementInternals['form'];
+  declare readonly shadowRoot: ElementInternals['shadowRoot'];
+
+  // https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/states
+  declare readonly states: unknown;
+  declare readonly willValidate: ElementInternals['willValidate'];
+  declare readonly validationMessage: ElementInternals['validationMessage'];
+
+  public static getLabels(host: InternalsHost): Element[] {
+    return Array.from(this.instances.get(host)?.internals.labels ?? []) as Element[];
+  }
+
+  /**
+   * Gets the ARIA posinset value from a listbox item (attribute takes precedence over internals).
+   * @param host - The listbox item element.
+   */
+  public static getAriaPosInSet(host: HTMLElement): string | null {
+    return host.getAttribute('aria-posinset')
+        ?? this.instances.get(host)?.ariaPosInSet
+        ?? null;
+  }
+
+  /**
+   * Sets the ARIA posinset on a listbox item. Uses ElementInternals when the host has
+   * an InternalsController instance; otherwise sets/removes the host attribute.
+   * @param host - The listbox item element (option or option-like).
+   * @param value - Position in set (1-based), or null to clear.
+   */
+  public static setAriaPosInSet(host: HTMLElement, value: number | string | null): void {
+    const instance = this.instances.get(host);
+    if (instance) {
+      instance.ariaPosInSet = value != null ? String(value) : null;
+    } else if (value != null) {
+      host.setAttribute('aria-posinset', String(value));
+    } else {
+      host.removeAttribute('aria-posinset');
+    }
+  }
+
+  /**
+   * Gets the ARIA setsize from a listbox item (aria attribute if set or defaulting to internals).
+   * @param host - The listbox item element.
+   */
+  public static getAriaSetSize(host: HTMLElement): string | null {
+    return host.getAttribute('aria-setsize')
+        ?? this.instances.get(host)?.ariaSetSize
+        ?? null;
+  }
+
+  /**
+   * Sets the ARIA setsize on a listbox item. Uses ElementInternals when the host has
+   * an InternalsController instance; otherwise sets/removes the host attribute.
+   * @param host - The listbox item element (option or option-like).
+   * @param value - Total set size, or null to clear.
+   */
+  public static setAriaSetSize(host: HTMLElement, value: number | string | null): void {
+    const instance = this.instances.get(host);
+    if (instance) {
+      instance.ariaSetSize = value != null ? String(value) : null;
+    } else if (value != null) {
+      host.setAttribute('aria-setsize', String(value));
+    } else {
+      host.removeAttribute('aria-setsize');
+    }
+  }
+
+  public static isSafari: boolean =
+    !isServer && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
+
+  public static of(host: InternalsHost, options?: InternalsControllerOptions): InternalsController {
+    constructingAllowed = true;
+    // implement the singleton pattern
+    // using a public static constructor method is much easier to manage,
+    // due to the quirks of our typescript config
+    const instance: InternalsController =
+      InternalsController.instances.get(host)
+      ?? new InternalsController(host, options);
+    instance.initializeOptions(options);
+    constructingAllowed = false;
+    return instance;
+  }
+
+  @aria role: string | null = null;
+
+  @aria ariaActivedescendant: string | null = null;
+  @aria ariaAtomic: string | null = null;
+  @aria ariaAutoComplete: string | null = null;
+  @aria ariaBusy: string | null = null;
+  @aria ariaBrailleLabel: string | null = null;
+  @aria ariaBrailleRoleDescription: string | null = null;
+  @aria ariaChecked: string | null = null;
+  @aria ariaColCount: string | null = null;
+  @aria ariaColIndex: string | null = null;
+  @aria ariaColIndexText: string | null = null;
+  @aria ariaColSpan: string | null = null;
+  @aria ariaCurrent: string | null = null;
+  @aria ariaDescription: string | null = null;
+  @aria ariaDisabled: string | null = null;
+  @aria ariaExpanded: string | null = null;
+  @aria ariaHasPopup: string | null = null;
+  @aria ariaHidden: string | null = null;
+  @aria ariaInvalid: string | null = null;
+  @aria ariaKeyShortcuts: string | null = null;
+  @aria ariaLabel: string | null = null;
+  @aria ariaLevel: string | null = null;
+  @aria ariaLive: string | null = null;
+  @aria ariaModal: string | null = null;
+  @aria ariaMultiLine: string | null = null;
+  @aria ariaMultiSelectable: string | null = null;
+  @aria ariaOrientation: string | null = null;
+  @aria ariaPlaceholder: string | null = null;
+  @aria ariaPosInSet: string | null = null;
+  @aria ariaPressed: string | null = null;
+  @aria ariaReadOnly: string | null = null;
+  @aria ariaRelevant: string | null = null;
+  @aria ariaRequired: string | null = null;
+  @aria ariaRoleDescription: string | null = null;
+  @aria ariaRowCount: string | null = null;
+  @aria ariaRowIndex: string | null = null;
+  @aria ariaRowIndexText: string | null = null;
+  @aria ariaRowSpan: string | null = null;
+  @aria ariaSelected: string | null = null;
+  @aria ariaSetSize: string | null = null;
+  @aria ariaSort: string | null = null;
+  @aria ariaValueMax: string | null = null;
+  @aria ariaValueMin: string | null = null;
+  @aria ariaValueNow: string | null = null;
+  @aria ariaValueText: string | null = null;
+
+  /** As of April 2025, the following are considered Baseline supported in evergreen browsers */
+  @aria ariaActiveDescendantElement: Element | null = null;
+  @aria ariaControlsElements: Element[] | null = null;
+  @aria ariaDescribedByElements: Element[] | null = null;
+  @aria ariaDetailsElements: Element[] | null = null;
+  @aria ariaErrorMessageElements: Element[] | null = null;
+  @aria ariaFlowToElements: Element[] | null = null;
+  @aria ariaLabelledByElements: Element[] | null = null;
+
+  /** As of February 2026, this is not supported in Chromium browsers */
+  @aria ariaOwnsElements: Element[] | null = null;
+
+  /** True when the control is disabled via it's containing fieldset element */
+  get formDisabled(): boolean {
+    if (isServer) {
+      return this._formDisabled;
+    } else {
+      return this.element?.matches(':disabled') || this._formDisabled;
+    }
+  }
+
+  get labels(): NodeList {
+    return this.internals.labels;
+  }
+
+  get validity(): ValidityState {
+    return this.internals.validity;
+  }
+
+  /** A best-attempt based on observed behaviour in FireFox 115 on fedora 38 */
+  get computedLabelText(): string {
+    return this.internals.ariaLabel
+      || Array.from(this.internals.labels)
+          .reduce((acc, label) =>
+            `${acc}${getLabelText(label)}`, '');
+  }
+
+  private get element() {
+    if (isServer) {
+      return this.host;
+    } else {
+      return this.host instanceof HTMLElement ? this.host : this.options?.getHTMLElement?.();
+    }
+  }
+
+  private internals!: ElementInternals;
+
+  private _formDisabled = false;
+
+  private constructor(public host: InternalsHost, private options?: InternalsControllerOptions) {
+    if (!constructingAllowed) {
+      throw new Error('InternalsController must be constructed with `InternalsController.for()`');
+    }
+    if (!this.element) {
+      throw new Error(
+        `InternalsController must be instantiated with an HTMLElement or a \`getHTMLElement\` function`,
+      );
+    }
+    this.attachOrRetrieveInternals();
+    this.initializeOptions(options);
+    InternalsController.instances.set(host, this);
+    this.#polyfillDisabledPseudo();
+  }
+
+  /**
+   * We need to polyfill :disabled
+   * see https://github.com/calebdwilliams/element-internals-polyfill/issues/88
+   */
+  #polyfillDisabledPseudo() {
+    // START polyfill-disabled
+    // We need to polyfill :disabled
+    // see https://github.com/calebdwilliams/element-internals-polyfill/issues/88
+    const orig = (this.element as FACE).formDisabledCallback;
+    (this.element as FACE).formDisabledCallback = disabled => {
+      this._formDisabled = disabled;
+      orig?.call(this.host, disabled);
+    // END polyfill-disabled
+    };
+  }
+
+  /**
+   * Typescript (with experimental decorators) will compile the class
+   * such that the order of operations is:
+   * 1. set up constructor parameter fields
+   * 2. run decorated field setters with initializers as the value
+   * 3. run the rest of the constructor
+   * Because of that, `this.internals` may not be available in the decorator setter
+   * so we cheat here with nullish coalescing assignment operator `??=`;
+   */
+  private attachOrRetrieveInternals() {
+    this.internals ??= this.element!.attachInternals();
+    return this.internals;
+  }
+
+  private initializeOptions(options?: Partial<ARIAMixin>) {
+    this.options ??= options ?? {};
+    const { getHTMLElement, ...aria } = this.options;
+    this.options.getHTMLElement ??= getHTMLElement;
+    for (const [key, val] of Object.entries(aria)) {
+      if (isARIAMixinProp(key)) {
+        this[key as keyof this] = val as this[keyof this];
+      }
+    }
+  }
+
+  hostConnected?(): void;
+
+  setFormValue(...args: Parameters<ElementInternals['setFormValue']>): void {
+    return this.internals.setFormValue(...args);
+  }
+
+  setValidity(...args: Parameters<ElementInternals['setValidity']>): void {
+    return this.internals.setValidity(...args);
+  }
+
+  checkValidity(...args: Parameters<ElementInternals['checkValidity']>): boolean {
+    return this.internals.checkValidity(...args);
+  }
+
+  reportValidity(...args: Parameters<ElementInternals['reportValidity']>): boolean {
+    return this.internals.reportValidity(...args);
+  }
+
+  submit(): void {
+    this.internals.form?.requestSubmit();
+  }
+
+  reset(): void {
+    this.internals.form?.reset();
+  }
+}
+
+/** @see https://w3c.github.io/aria/#ref-for-dom-ariamixin-ariaactivedescendantelement-1 */
+declare global {
+  interface ARIAMixin {
+    ariaActiveDescendantElement: Element | null;
+    ariaControlsElements: readonly Element[] | null;
+    ariaDescribedByElements: readonly Element[] | null;
+    ariaDetailsElements: readonly Element[] | null;
+    ariaErrorMessageElements: readonly Element[] | null;
+    ariaFlowToElements: readonly Element[] | null;
+    ariaLabelledByElements: readonly Element[] | null;
+    ariaOwnsElements: readonly Element[] | null;
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.ts b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.ts
new file mode 100644
index 0000000..321010a
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.ts
@@ -0,0 +1,64 @@
+import { isServer, type ReactiveController, type ReactiveElement } from 'lit';
+
+import { Logger } from './logger.js';
+
+export interface Options {
+  observe?: boolean | MutationObserverInit;
+  emptyWarning?: string;
+}
+
+export class LightDOMController implements ReactiveController {
+  private mo: MutationObserver;
+  private logger: Logger;
+  private initializer: () => void;
+
+  constructor(
+    private host: ReactiveElement,
+    initializer: () => void,
+    private options?: Options | undefined,
+  ) {
+    this.initializer = initializer.bind(host);
+    this.mo = new MutationObserver(this.initializer);
+    this.logger = new Logger(this.host);
+    host.addController(this);
+  }
+
+  hostConnected(): void {
+    if (this.hasLightDOM()) {
+      this.initializer();
+    } else if (this.options?.emptyWarning) {
+      this.logger.warn(this.options?.emptyWarning);
+    }
+
+    this.initObserver();
+  }
+
+  hostDisconnected(): void {
+    this.mo.disconnect();
+  }
+
+  private initObserver() {
+    if (this.options?.observe ?? true) {
+      // Use the provided options, or their defaults
+      this.mo.observe(
+        this.host,
+          typeof this.options?.observe !== 'object' ? { childList: true }
+        : this.options?.observe as MutationObserverInit
+      );
+    }
+  }
+
+  /**
+   * Returns a boolean statement of whether or not this component contains any light DOM.
+   */
+  hasLightDOM(): boolean {
+    if (isServer) {
+      return false;
+    } else {
+      return !!(
+        this.host.children.length > 0
+        || (this.host.textContent ?? '').trim().length > 0
+      );
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.d.ts
index 5dce7e8..8b9d1b8 100644
--- a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.d.ts
@@ -120,9 +120,8 @@ export declare class ListboxController<Item extends HTMLElement> implements Reac
     set multi(v: boolean);
     get items(): Item[];
     /**
-     * register's the host's Item elements as listbox controller items
-     * sets aria-setsize and aria-posinset on items
-     * @param items items
+     * Registers the host's item elements as listbox controller items.
+     * @param items - Array of listbox option elements.
      */
     set items(items: Item[]);
     /**
@@ -136,6 +135,10 @@ export declare class ListboxController<Item extends HTMLElement> implements Reac
     get selected(): Item[];
     private constructor();
     hostConnected(): Promise<void>;
+    /**
+     * Called during host update; syncs control element listeners and
+     * applies aria-posinset/aria-setsize to each item via InternalsController.
+     */
     hostUpdate(): void;
     hostUpdated(): void;
     hostDisconnected(): void;
diff --git a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js
index a02b83a..3a45026 100644
--- a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js
@@ -2,6 +2,7 @@ var _ListboxController_instances, _ListboxController_shiftStartingItem, _Listbox
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
 import { isServer } from 'lit';
 import { arraysAreEquivalent } from '../functions/arraysAreEquivalent.js';
+import { InternalsController } from './internals-controller.js';
 /**
  * This is the default method for setting the selected state on an item element
  * @param item the item
@@ -101,16 +102,14 @@ export class ListboxController {
         return __classPrivateFieldGet(this, _ListboxController_items, "f");
     }
     /**
-     * register's the host's Item elements as listbox controller items
-     * sets aria-setsize and aria-posinset on items
-     * @param items items
+     * Registers the host's item elements as listbox controller items.
+     * @param items - Array of listbox option elements.
      */
     set items(items) {
-        __classPrivateFieldSet(this, _ListboxController_items, items, "f");
-        __classPrivateFieldGet(this, _ListboxController_items, "f").forEach((item, index, _items) => {
-            item.ariaSetSize = _items.length.toString();
-            item.ariaPosInSet = (index + 1).toString();
-        });
+        if (!arraysAreEquivalent(items, __classPrivateFieldGet(this, _ListboxController_items, "f"))) {
+            __classPrivateFieldSet(this, _ListboxController_items, items, "f");
+            this.host.requestUpdate();
+        }
     }
     /**
      * sets the listbox value based on selected options
@@ -302,6 +301,10 @@ export class ListboxController {
         this.hostUpdate();
         this.hostUpdated();
     }
+    /**
+     * Called during host update; syncs control element listeners and
+     * applies aria-posinset/aria-setsize to each item via InternalsController.
+     */
     hostUpdate() {
         const last = __classPrivateFieldGet(this, _ListboxController_controlsElements, "f");
         __classPrivateFieldSet(this, _ListboxController_controlsElements, __classPrivateFieldGet(this, _ListboxController_options, "f").getControlsElements?.() ?? [], "f");
@@ -312,6 +315,11 @@ export class ListboxController {
                 el.addEventListener('keyup', __classPrivateFieldGet(this, _ListboxController_onKeyup, "f"));
             }
         }
+        const items = __classPrivateFieldGet(this, _ListboxController_items, "f");
+        items.forEach((item, index) => {
+            InternalsController.setAriaPosInSet(item, index + 1);
+            InternalsController.setAriaSetSize(item, items.length);
+        });
     }
     hostUpdated() {
         if (!__classPrivateFieldGet(this, _ListboxController_listening, "f")) {
@@ -401,11 +409,13 @@ _ListboxController_shiftStartingItem = new WeakMap(), _ListboxController_options
                 return shadowRootItem;
             }
             else {
-                const index = Array.from(shadowRootListboxElement?.children ?? [])
-                    .filter(__classPrivateFieldGet(this, _ListboxController_options, "f").isItem)
-                    .filter(x => !x.hidden)
-                    .indexOf(shadowRootItem);
-                return __classPrivateFieldGet(this, _ListboxController_items, "f").filter(x => !x.hidden)[index];
+                // Shadow clone needs to be mapped back to light DOM item.
+                // Match by value attribute or text content since index-based matching
+                // doesn't work when items are filtered (hidden state differs between clone and source)
+                const cloneValue = shadowRootItem.getAttribute('value')
+                    ?? shadowRootItem.textContent?.trim();
+                const sourceItem = __classPrivateFieldGet(this, _ListboxController_items, "f").find(item => (item.getAttribute('value') ?? item.textContent?.trim()) === cloneValue);
+                return sourceItem ?? null;
             }
         }
         const itemFromEventContainer = shadowRootListboxElement ? shadowRootListboxElement
diff --git a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js.map
index c94674f..d3e775c 100644
--- a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"listbox-controller.js","sourceRoot":"","sources":["listbox-controller.ts"],"names":[],"mappings":";;AAGA,OAAO,EAAE,QAAQ,EAAE,MAAM,KAAK,CAAC;AAC/B,OAAO,EAAE,mBAAmB,EAAE,MAAM,qCAAqC,CAAC;AA2D1E;;;;GAIG;AACH,SAAS,eAAe,CAA2B,IAAU,EAAE,QAAiB;IAC9E,IAAI,QAAQ,EAAE,CAAC;QACb,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;IAC7C,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;IACxC,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,MAAM,CAA2B,IAAwB;IACvE,OAAO,IAAI,YAAY,OAAO;WACzB,IAAI,EAAE,aAAa,EAAE,IAAI,KAAK,SAAS;WACvC,IAAI,EAAE,IAAI,KAAK,cAAc;WAC7B,IAAI,EAAE,SAAS,KAAK,IAAI,CAAC;AAChC,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,cAAc,CAA2B,IAAU;IACjE,OAAO,CAAC,UAAU,IAAI,IAAI,IAAI,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC;WAC3E,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,KAAK,MAAM;WAC7C,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;WAC7B,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC;WAC1B,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACnC,CAAC;AAED,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,MAAM,OAAO,iBAAiB;IAGrB,MAAM,CAAC,EAAE,CACd,IAA4B,EAC5B,OAAuC;QAEvC,mBAAmB,GAAG,IAAI,CAAC;QAC3B,MAAM,QAAQ,GAAG,IAAI,iBAAiB,CAAO,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5D,mBAAmB,GAAG,KAAK,CAAC;QAC5B,OAAO,QAAmC,CAAC;IAC7C,CAAC;IAqBD,IAAI,SAAS;QACX,OAAO,uBAAA,IAAI,kCAAS,CAAC,iBAAiB,EAAE,EAAE,IAAI,IAAI,CAAC,IAA8B,CAAC;IACpF,CAAC;IAED,IAAI,KAAK;QACP,OAAO,CAAC,CAAC,uBAAA,IAAI,kCAAS,CAAC,KAAK,CAAC;IAC/B,CAAC;IAED,IAAI,KAAK,CAAC,CAAU;QAClB,uBAAA,IAAI,kCAAS,CAAC,KAAK,GAAG,CAAC,CAAC;QACxB,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;IAC5B,CAAC;IAED,IAAI,KAAK;QACP,OAAO,uBAAA,IAAI,gCAAO,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACH,IAAI,KAAK,CAAC,KAAa;QACrB,uBAAA,IAAI,4BAAU,KAAK,MAAA,CAAC;QACpB,uBAAA,IAAI,gCAAO,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE;YAC1C,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YAC5C,IAAI,CAAC,YAAY,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,IAAI,QAAQ,CAAC,QAAgB;QAC3B,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,KAAK,CAAC,IAAI,CAAC,uBAAA,IAAI,wCAAe,CAAC,CAAC,EAAE,CAAC;YACpE,uBAAA,IAAI,oCAAkB,IAAI,GAAG,CAAC,QAAQ,CAAC,MAAA,CAAC;YACxC,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gBAC9B,uBAAA,IAAI,kCAAS,CAAC,eAAe,CAAC,IAAI,EAAE,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;YACrE,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;IAED;;OAEG;IACH,IAAI,QAAQ;QACV,OAAO,CAAC,GAAG,uBAAA,IAAI,wCAAe,CAAC,CAAC;IAClC,CAAC;IAED,YACS,IAA4B,EACnC,OAAuC;;QADhC,SAAI,GAAJ,IAAI,CAAwB;QAvErC,0DAA0D;QAC1D,+CAAkC,IAAI,EAAC;QAEvC,6CAIE;QAEF,gBAAgB;QAChB,mCAAiB,EAAE,EAAC;QAEpB,2CAAiB,IAAI,GAAS,EAAC;QAE/B,uCAAa,KAAK,EAAC;QAEnB,kCAAkC;QAClC,aAAQ,GAAG,KAAK,CAAC;QAuFjB,8CAAmC,EAAE,EAAC;QAsJtC;;;;;WAKG;QACH,qCAAW,CAAC,KAAiB,EAAE,EAAE;YAC/B,MAAM,IAAI,GAAG,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB,KAAK,CAAC,CAAC;YAC3C,8IAA4B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB,KAAK,CAAC,MAAA,CAAC;YAC1D,IAAI,IAAI,IAAI,CAAC,uBAAA,IAAI,kCAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;gBAChD,uBAAuB;gBACvB,sCAAsC;gBACtC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;oBAChB,+CAA+C;oBAC/C,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC;oBACzB,uCAAuC;oBACvC,0DAA0D;gBAC1D,CAAC;qBAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;oBAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,CAAC,EAAE,CACrD,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,oBAAoB,KAAK,IAAI;wBAC/E,CAAC,CAAC,oBAAoB,KAAK,IAAI,CAAC,CAAC;oBACrC,qCAAqC;oBACrC,+DAA+D;oBAC/D,2GAA2G;oBAC3G,6FAA6F;gBAC7F,CAAC;qBAAM,CAAC;oBACN,MAAM,YAAY,GAAG,uBAAA,IAAI,4CAAoB,CAAC;oBAC9C,gEAAgE;oBAChE,MAAM,SAAS,GAAG,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;oBACxD,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;oBACzF,6DAA6D;oBAC7D,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;wBAC5C,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;4BAC3B,OAAO,SAAS,CAAC;wBACnB,CAAC;6BAAM,CAAC;4BACN,OAAO,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;wBACvC,CAAC;oBACH,CAAC,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YACD,uBAAA,IAAI,wCAAsB,IAAI,MAAA,CAAC;YAC/B,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC5B,CAAC,EAAC;QAEF;;;WAGG;QACH,qCAAW,CAAC,KAAoB,EAAE,EAAE;YAClC,IAAI,KAAK,CAAC,GAAG,KAAK,OAAO,EAAE,CAAC;gBAC1B,uBAAA,IAAI,wCAAsB,IAAI,MAAA,CAAC;YACjC,CAAC;QACH,CAAC,EAAC;QAEF;;;;WAIG;QACH,uCAAa,CAAC,KAAoB,EAAE,EAAE;YACpC,MAAM,IAAI,GAAG,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB,KAAK,CAAC,CAAC;YAE3C,IAAI,IAAI,CAAC,QAAQ;mBACZ,KAAK,CAAC,MAAM;mBACZ,KAAK,CAAC,OAAO;mBACb,CAAC,uBAAA,IAAI,uEAAY,EAAE,CAAC;gBACvB,OAAO;YACT,CAAC;YAED,kDAAkD;YAClD,IAAI,KAAK,CAAC,GAAG,KAAK,OAAO,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gBACxC,+IAA4B,uBAAA,IAAI,kCAAS,CAAC,gBAAgB,EAAE,IAAI,IAAI,OAAA,CAAC;YACvE,CAAC;YAED,QAAQ,KAAK,CAAC,GAAG,EAAE,CAAC;gBAClB,gCAAgC;gBAChC,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG;oBACN,IAAI,KAAK,CAAC,OAAO;2BACV,CAAC,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,SAAS;+BAC5B,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;wBAC/C,MAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,uBAAA,IAAI,kCAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;wBACvF,IAAI,mBAAmB,CAAC,IAAI,CAAC,QAAQ,EAAE,eAAe,CAAC,EAAE,CAAC;4BACxD,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;wBACrB,CAAC;6BAAM,CAAC;4BACN,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC;wBAClC,CAAC;wBACD,KAAK,CAAC,cAAc,EAAE,CAAC;oBACzB,CAAC;oBACD,MAAM;gBACR,KAAK,OAAO;oBACV,qEAAqE;oBACrE,wDAAwD;oBACxD,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;wBAC5B,MAAM,OAAO,GAAG,IAAI,CAAC;wBACrB,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,OAAO,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;wBAC1C,KAAK,CAAC,cAAc,EAAE,CAAC;oBACzB,CAAC;oBACD,MAAM;gBACR,KAAK,SAAS;oBACZ,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ,IAAI,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;wBACvE,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;wBAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CACzC,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,CAAC,CAAC;+BACvB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;6BACnC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,uBAAA,IAAI,kCAAS,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;oBACrD,CAAC;oBACD,MAAM;gBACR,KAAK,WAAW;oBACd,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,QAAQ,IAAI,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;wBACvE,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC;wBAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CACzC,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,CAAC,CAAC;+BACvB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;6BACnC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,uBAAA,IAAI,kCAAS,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;oBACrD,CAAC;oBACD,MAAM;gBACR,KAAK,GAAG;oBACN,qEAAqE;oBACrE,wDAAwD;oBACxD,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;wBAC5C,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;wBACvC,KAAK,CAAC,cAAc,EAAE,CAAC;oBACzB,CAAC;yBAAM,IAAI,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;wBAC9C,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;wBAC/C,KAAK,CAAC,cAAc,EAAE,CAAC;oBACzB,CAAC;oBACD,MAAM;gBACR;oBACE,MAAM;YACV,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;QAC5B,CAAC,EAAC;QAxTA,uBAAA,IAAI,8BAAY,EAAE,eAAe,EAAE,cAAc,EAAE,MAAM,EAAE,GAAG,OAAO,EAAE,MAAA,CAAC;QACxE,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC;QACzF,CAAC;QACD,IAAI,CAAC,QAAQ;eACN,CAAC,CAAC,IAAI,YAAY,WAAW,CAAC;eAC9B,OAAO,OAAO,CAAC,iBAAiB,KAAK,UAAU,EAAE,CAAC;YACvD,MAAM,IAAI,KAAK,CAAC;gBACd,0DAA0D;gBAC1D,kEAAkE;aACnE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACf,CAAC;QACD,MAAM,QAAQ,GAAG,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAuC,CAAC;QAC7F,IAAI,QAAQ,EAAE,CAAC;YACb,OAAO,QAAmC,CAAC;QAC7C,CAAC;QACD,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,IAAiD,CAAC,CAAC;QACzF,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,uBAAA,IAAI,kCAAS,CAAC,KAAK,IAAI,KAAK,CAAC;QAC1C,IAAI,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC;YAChC,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC;IACH,CAAC;IAED,KAAK,CAAC,aAAa;QACjB,MAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;QAC/B,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAWD,UAAU;QACR,MAAM,IAAI,GAAG,uBAAA,IAAI,2CAAkB,CAAC;QACpC,uBAAA,IAAI,uCAAqB,uBAAA,IAAI,kCAAS,CAAC,mBAAmB,EAAE,EAAE,IAAI,EAAE,MAAA,CAAC;QACrE,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,uBAAA,IAAI,2CAAkB,CAAC,EAAE,CAAC;YACvD,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,EAA0B,IAAI,CAAC,CAAC;YACpC,KAAK,MAAM,EAAE,IAAI,uBAAA,IAAI,2CAAkB,EAAE,CAAC;gBACxC,EAAE,CAAC,gBAAgB,CAAC,SAAS,EAAE,uBAAA,IAAI,oCAAW,CAAC,CAAC;gBAChD,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;YAC9C,CAAC;QACH,CAAC;IACH,CAAC;IAED,WAAW;QACT,IAAI,CAAC,uBAAA,IAAI,oCAAW,EAAE,CAAC;YACrB,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;YACzD,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,SAAS,EAAE,uBAAA,IAAI,oCAAW,CAAC,CAAC;YAC7D,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;YACzD,uBAAA,IAAI,gCAAc,IAAI,MAAA,CAAC;QACzB,CAAC;QACD,IAAI,CAAC,SAAS,EAAE,YAAY,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QAChD,IAAI,CAAC,SAAS,EAAE,YAAY,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,SAAS,EAAE,YAAY,CAAC,sBAAsB,EAAE,MAAM,CAAC,CAAC,CAAC,uBAAA,IAAI,kCAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACtF,CAAC;IAED,gBAAgB;QACd,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;QAC5D,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC,SAAS,EAAE,uBAAA,IAAI,oCAAW,CAAC,CAAC;QAChE,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;QAC5D,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAC;QAChC,uBAAA,IAAI,gCAAc,KAAK,MAAA,CAAC;IAC1B,CAAC;IAEM,UAAU,CAAC,IAAU;QAC1B,OAAO,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACvC,CAAC;;sjBAzCwB,GAAG,GAAG,uBAAA,IAAI,2CAAkB;IACnD,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE,CAAC;QACrB,EAAE,CAAC,mBAAmB,CAAC,SAAS,EAAE,uBAAA,IAAI,oCAAW,CAAC,CAAC;QACnD,EAAE,CAAC,mBAAmB,CAAC,OAAO,EAAE,uBAAA,IAAI,kCAAS,CAAC,CAAC;IACjD,CAAC;AACH,CAAC;IAuCC,OAAO,CAAC,uBAAA,IAAI,2CAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI;QAC1C,CAAC,CAAC,uBAAA,IAAI,2CAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,YAAY,KAAK,MAAM,CAAC,CAAC;AACnE,CAAC,qFASiB,KAAY;IAC5B,2DAA2D;IAC3D,0CAA0C;IAC1C,uCAAuC;IACvC,MAAM,IAAI,GAAG,KAAK,CAAC,YAAY,EAAE,CAAC;IAClC,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;IACpE,IAAI,UAAU,EAAE,CAAC;QACf,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,CAAC;QAC7C,IAAI,IAAI,EAAE,CAAC;YACT,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;SAAM,IAAI,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;WAC/B,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE;WAC3D,6BAA6B,IAAI,WAAW,CAAC,SAAS,EAAE,CAAC;QACrE,OAAO,KAAK,CAAC,MAAM,CAAC;IACtB,CAAC;SAAM,IAAI,KAAK,CAAC,MAAM,YAAY,WAAW,IAAI,KAAK,CAAC,MAAM,CAAC,2BAA2B,EAAE,CAAC;QAC3F,OAAO,KAAK,CAAC,MAAM,CAAC,2BAAmC,CAAC;IAC1D,CAAC;SAAM,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO;WACnB,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;WAClC,KAAK,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC;QAC9B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC;QAC7B,MAAM,IAAI,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;QACnC,IAAI,IAAI,YAAY,UAAU,IAAI,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACxE,MAAM,wBAAwB,GAAG,IAAI,CAAC,SAAS,CAAC;YAChD,MAAM,cAAc,GAAG,OAAO,CAAC;YAC/B,IAAI,cAAc,IAAI,wBAAwB,EAAE,CAAC;gBAC/C,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC;oBACxC,OAAO,cAAc,CAAC;gBACxB,CAAC;qBAAM,CAAC;oBACN,MAAM,KAAK,GACT,KAAK,CAAC,IAAI,CAAC,wBAAwB,EAAE,QAAQ,IAAI,EAAE,CAAC;yBAC/C,MAAM,CAAC,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC;yBAC5B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;yBACtB,OAAO,CAAC,cAAc,CAAC,CAAC;oBAC/B,OAAO,uBAAA,IAAI,gCAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC;gBACnD,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;SAAM,CAAC;QACN,0EAA0E;QAC1E,MAAM,OAAO,GAAG,KAAK,CAAC,MAAqB,CAAC;QAE5C,MAAM,IAAI,GAAG,OAAO,CAAC,WAAW,EAA2B,CAAC;QAE5D,MAAM,UAAU,GAAG,OAAO,EAAE,YAAY,CAAC,eAAe,CAAC,CAAC;QAC1D,MAAM,wBAAwB,GAC1B,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS;YAChD,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC;gBAC9C,CAAC,CAAC,IAAI,CAAC;QAET,MAAM,oCAAoC,GACxC,IAAI,CAAC,aAAa,CAAC,mBAAmB,wBAAwB,EAAE,EAAE,2BAA2B,CAAC,CAAC;QAEjG,MAAM,gBAAgB,GACpB,oCAAoC,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;QAE9E,MAAM,cAAc,GAClB,gBAAgB,IAAI,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAgB,CAAC;QAE3E,IAAI,cAAc,IAAI,wBAAwB,EAAE,CAAC;YAC/C,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC;gBACxC,OAAO,cAAc,CAAC;YACxB,CAAC;iBAAM,CAAC;gBACN,MAAM,KAAK,GACT,KAAK,CAAC,IAAI,CAAC,wBAAwB,EAAE,QAAQ,IAAI,EAAE,CAAC;qBAC/C,MAAM,CAAC,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC;qBAC5B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;qBACtB,OAAO,CAAC,cAAc,CAAC,CAAC;gBAC/B,OAAO,uBAAA,IAAI,gCAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC;YACnD,CAAC;QACH,CAAC;QAED,MAAM,sBAAsB,GAC1B,wBAAwB,CAAC,CAAC,CAAC,wBAAwB;YACrD,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CACd,CAAC,YAAY,WAAW,IAAI,CAAC,CAAC,IAAI,KAAK,SAAS,CAAgB,CAAC;QAEnE,IAAI,sBAAsB,EAAE,CAAC;YAC3B,MAAM,gCAAgC,GAAG,KAAK,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC;iBAC/E,MAAM,CAAC,uBAAA,IAAI,kCAAS,CAAC,MAAM,CAAC,CAAC;YAElC,MAAM,KAAK,GAAG,gCAAgC;iBACzC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YAE5C,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;gBACf,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC;YACnC,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC,yEAwIW,IAAU,EAAE,SAAS,GAAG,KAAK;IACvC,IAAI,uBAAA,IAAI,kCAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;QACvC,OAAO;IACT,CAAC;SAAM,IAAI,IAAI,CAAC,KAAK,IAAI,SAAS,EAAE,CAAC;QACnC,6CAA6C;QAC7C,IAAI,CAAC,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC3C,CAAC;SAAM,IAAI,IAAI,CAAC,KAAK,IAAI,uBAAA,IAAI,wCAAe,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;QACvD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC;IACxD,CAAC;SAAM,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7C,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;AACH,CAAC;AA7Zc,2BAAS,GAAG,IAAI,OAAO,EAA0D,AAAxE,CAAyE","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\nimport type { RequireProps } from '../core.ts';\n\nimport { isServer } from 'lit';\nimport { arraysAreEquivalent } from '../functions/arraysAreEquivalent.js';\n\n/**\n * Options for listbox controller\n */\nexport interface ListboxControllerOptions<Item extends HTMLElement> {\n  /**\n   * Whether the listbox supports multiple selections.\n   */\n  multi?: boolean;\n  /**\n   * Optional callback to control the selection behavior of items. By default, ListboxController\n   * will set the `aria-selected` attribute. When overriding this option, it will call it on your\n   * element with the selected state.\n   * Callers **must** ensure that the correct ARIA state is set.\n   */\n  setItemSelected?(item: Item, selected: boolean): void;\n  /**\n   * Optional predicate to ascertain whether a custom element item is disabled or not\n   * By default, if the item matches any of these conditions, it is considered disabled:\n   * 1. it's `disabled` DOM property is `true`\n   * 1. it has the `aria-disabled=\"true\"` attribute\n   * 2. it has the `disabled` attribute present\n   * 3. it matches the `:disabled` pseudo selector\n   */\n  isItemDisabled?(item: Item): boolean;\n  /**\n   * Predicate which determines if a given element is in fact an item\n   * instead of e.g a presentational divider. By default, elements must meet the following criteria\n   * 1. element a child of a listbox role,\n   * 2. element does not have role=\"presentation\"\n   * 2. element is not an `<hr>`\n   * **NB**: When overriding, you must avoid outside references. This predicate must\n   * only consider the element itself, without reference to the host element's items array.\n   * @example ```js\n   *          isItem: (item) => item instanceof MyCustomItem\n   *          ```\n   */\n  isItem?(item: EventTarget | null): item is Item;\n  /**\n   * Function returning the item which currently has assistive technology focus.\n   * In most cases, this should be the `atFocusedItem` of an ATFocusController\n   * i.e. RovingTabindexController or ActivedescendantController.\n   *\n   */\n  getATFocusedItem(): Item | null;\n  /**\n   * Function returning the DOM node which is the direct parent of the item elements\n   * Defaults to the controller host.\n   * If the controller host is not an HTMLElement, this *must* be set\n   */\n  getItemsContainer?(): HTMLElement | null;\n  /**\n   * Optional function returning an additional DOM node which controls the listbox, e.g.\n   * a combobox input.\n   */\n  getControlsElements?(): HTMLElement[];\n}\n\n/**\n * This is the default method for setting the selected state on an item element\n * @param item the item\n * @param selected is this item selected\n */\nfunction setItemSelected<Item extends HTMLElement>(item: Item, selected: boolean) {\n  if (selected) {\n    item.setAttribute('aria-selected', 'true');\n  } else {\n    item.removeAttribute('aria-selected');\n  }\n}\n\n/**\n * @param item possible disabled item\n * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time\n */\nexport function isItem<Item extends HTMLElement>(item: EventTarget | null): item is Item {\n  return item instanceof Element\n    && item?.parentElement?.role === 'listbox'\n    && item?.role !== 'presentation'\n    && item?.localName !== 'hr';\n}\n\n/**\n * This is a fib. aria-disabled might not be present on an element that uses internals,\n * and the `disabled` attribute may not accurately represent the disabled state.\n * short of patching the `attachInternals` constructor, it may not be possible at\n * runtime to know with certainty that an arbitrary custom element is disabled or not.\n * @param item possibly disabled item\n * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time\n */\nexport function isItemDisabled<Item extends HTMLElement>(item: Item): boolean {\n  return ('disabled' in item && typeof item.disabled === 'boolean' && item.disabled)\n      || item.getAttribute('aria-disabled') === 'true'\n      || item.hasAttribute('disabled')\n      || item.hasAttribute('inert')\n      || item.matches(':disabled');\n}\n\nlet constructingAllowed = false;\n\n/**\n * Implements listbox semantics and accesibility. As there are two recognized\n * patterns for implementing keyboard interactions with listbox patterns,\n * provide a secondary controller (either RovingTabindexController or\n * ActiveDescendantController) to complete the implementation.\n *\n * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_vs_selection\n *\n * > Occasionally, it may appear as if two elements on the page have focus at the same time.\n * > For example, in a multi-select list box, when an option is selected it may be greyed.\n * > Yet, the focus indicator can still be moved to other options, which may also be selected.\n * > Similarly, when a user activates a tab in a tablist, the selected state is set on the tab\n * > and its visual appearance changes. However, the user can still navigate, moving the focus\n * > indicator elsewhere on the page while the tab retains its selected appearance and state.\n * >\n * > Focus and selection are quite different. From the keyboard user's perspective,\n * > focus is a pointer, like a mouse pointer; it tracks the path of navigation.\n * > There is only one point of focus at any time and all operations take place at the\n * > point of focus. On the other hand, selection is an operation that can be performed in\n * > some widgets, such as list boxes, trees, and tablists. If a widget supports only single\n * > selection, then only one item can be selected and very often the selected state will simply\n * > follow the focus when focus is moved inside of the widget.\n * > That is, in some widgets, moving focus may also perform the select operation.\n * > However, if the widget supports multiple selection, then more than one item can be in a\n * > selected state, and keys for moving focus do not perform selection. Some multi-select widgets\n * > do support key commands that both move focus and change selection, but those keys are\n * > different from the normal navigation keys. Finally, when focus leaves a widget that includes\n * > a selected element, the selected state persists.\n * >\n * > From the developer's perspective, the difference is simple -- the focused element is the\n * > active element (document.activeElement). Selected elements are elements that have\n * > aria-selected=\"true\".\n * >\n * > With respect to focus and the selected state, the most important considerations for designers\n * > and developers are:\n * >\n * > - The visual focus indicator must always be visible.\n * > - The selected state must be visually distinct from the focus indicator.\n */\nexport class ListboxController<Item extends HTMLElement> implements ReactiveController {\n  private static instances = new WeakMap<ReactiveControllerHost, ListboxController<HTMLElement>>();\n\n  public static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: ListboxControllerOptions<Item>,\n  ): ListboxController<Item> {\n    constructingAllowed = true;\n    const instance = new ListboxController<Item>(host, options);\n    constructingAllowed = false;\n    return instance as ListboxController<Item>;\n  }\n\n  /** Current active descendant when shift key is pressed */\n  #shiftStartingItem: Item | null = null;\n\n  #options: RequireProps<ListboxControllerOptions<Item>,\n    | 'setItemSelected'\n    | 'isItemDisabled'\n    | 'isItem'\n  >;\n\n  /** All items */\n  #items: Item[] = [];\n\n  #selectedItems = new Set<Item>;\n\n  #listening = false;\n\n  /** Whether listbox is disabled */\n  disabled = false;\n\n  get container(): HTMLElement {\n    return this.#options.getItemsContainer?.() ?? this.host as unknown as HTMLElement;\n  }\n\n  get multi(): boolean {\n    return !!this.#options.multi;\n  }\n\n  set multi(v: boolean) {\n    this.#options.multi = v;\n    this.host.requestUpdate();\n  }\n\n  get items(): Item[] {\n    return this.#items;\n  }\n\n  /**\n   * register's the host's Item elements as listbox controller items\n   * sets aria-setsize and aria-posinset on items\n   * @param items items\n   */\n  set items(items: Item[]) {\n    this.#items = items;\n    this.#items.forEach((item, index, _items) => {\n      item.ariaSetSize = _items.length.toString();\n      item.ariaPosInSet = (index + 1).toString();\n    });\n  }\n\n  /**\n   * sets the listbox value based on selected options\n   * @param selected item or items\n   */\n  set selected(selected: Item[]) {\n    if (!arraysAreEquivalent(selected, Array.from(this.#selectedItems))) {\n      this.#selectedItems = new Set(selected);\n      for (const item of this.items) {\n        this.#options.setItemSelected(item, this.#selectedItems.has(item));\n      }\n      this.host.requestUpdate();\n    }\n  }\n\n  /**\n   * array of options which are selected\n   */\n  get selected(): Item[] {\n    return [...this.#selectedItems];\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    options: ListboxControllerOptions<Item>,\n  ) {\n    this.#options = { setItemSelected, isItemDisabled, isItem, ...options };\n    if (!constructingAllowed) {\n      throw new Error('ListboxController must be constructed with `ListboxController.of()`');\n    }\n    if (!isServer\n        && !(host instanceof HTMLElement)\n        && typeof options.getItemsContainer !== 'function') {\n      throw new Error([\n        'ListboxController requires the host to be an HTMLElement',\n        'or for the initializer to include a getItemsContainer() function',\n      ].join(' '));\n    }\n    const instance = ListboxController.instances.get(host) as unknown as ListboxController<Item>;\n    if (instance) {\n      return instance as ListboxController<Item>;\n    }\n    ListboxController.instances.set(host, this as unknown as ListboxController<HTMLElement>);\n    this.host.addController(this);\n    this.multi = this.#options.multi ?? false;\n    if (this.container?.isConnected) {\n      this.hostConnected();\n    }\n  }\n\n  async hostConnected(): Promise<void> {\n    await this.host.updateComplete;\n    this.hostUpdate();\n    this.hostUpdated();\n  }\n\n  #controlsElements: HTMLElement[] = [];\n\n  #removeControlsListeners(els = this.#controlsElements) {\n    for (const el of els) {\n      el.removeEventListener('keydown', this.#onKeydown);\n      el.removeEventListener('keyup', this.#onKeyup);\n    }\n  }\n\n  hostUpdate(): void {\n    const last = this.#controlsElements;\n    this.#controlsElements = this.#options.getControlsElements?.() ?? [];\n    if (!arraysAreEquivalent(last, this.#controlsElements)) {\n      this.#removeControlsListeners(last);\n      for (const el of this.#controlsElements) {\n        el.addEventListener('keydown', this.#onKeydown);\n        el.addEventListener('keyup', this.#onKeyup);\n      }\n    }\n  }\n\n  hostUpdated(): void {\n    if (!this.#listening) {\n      this.container?.addEventListener('click', this.#onClick);\n      this.container?.addEventListener('keydown', this.#onKeydown);\n      this.container?.addEventListener('keyup', this.#onKeyup);\n      this.#listening = true;\n    }\n    this.container?.setAttribute('role', 'listbox');\n    this.container?.setAttribute('aria-disabled', String(!!this.disabled));\n    this.container?.setAttribute('aria-multiselectable', String(!!this.#options.multi));\n  }\n\n  hostDisconnected(): void {\n    this.container?.removeEventListener('click', this.#onClick);\n    this.container?.removeEventListener('keydown', this.#onKeydown);\n    this.container?.removeEventListener('keyup', this.#onKeyup);\n    this.#removeControlsListeners();\n    this.#listening = false;\n  }\n\n  public isSelected(item: Item): boolean {\n    return this.#selectedItems.has(item);\n  }\n\n  get #isExpanded() {\n    return !this.#controlsElements.length ? true\n      : this.#controlsElements.every(x => x.ariaExpanded === 'true');\n  }\n\n  /**\n   * In the case where aria IDL attributes are not supported,\n   * we need to correlate the item in the event path (i.e. the shadow dom clone)\n   * with the item in listbox controller's root (i.e. the hidden light dom original)\n   * XXX: as long as there is no DOM preceeding the shadow root clones, this will work\n   * @param event click or keyboard event\n   */\n  #getItemFromEvent(event: Event): Item | null {\n    // NOTE(bennypowers): I am aware that this function *sucks*\n    // you're more than welcome to improve it.\n    // make sure there are unit tests first\n    const path = event.composedPath();\n    const tabindexed = this.items.some(x => x.hasAttribute('tabindex'));\n    if (tabindexed) {\n      const item = path.find(this.#options.isItem);\n      if (item) {\n        return item;\n      }\n    } else if (this.#options.isItem(event.target)\n               && event.target.getRootNode() !== this.container.getRootNode()\n               && 'ariaActiveDescendantElement' in HTMLElement.prototype) {\n      return event.target;\n    } else if (event.target instanceof HTMLElement && event.target.ariaActiveDescendantElement) {\n      return event.target.ariaActiveDescendantElement as Item;\n    } else if (event.type === 'click'\n               && this.#options.isItem(event.target)\n               && event.target.id) {\n      const element = event.target;\n      const root = element.getRootNode();\n      if (root instanceof ShadowRoot && this.container.getRootNode() === root) {\n        const shadowRootListboxElement = this.container;\n        const shadowRootItem = element;\n        if (shadowRootItem && shadowRootListboxElement) {\n          if (this.items.includes(shadowRootItem)) {\n            return shadowRootItem;\n          } else {\n            const index =\n              Array.from(shadowRootListboxElement?.children ?? [])\n                  .filter(this.#options.isItem)\n                  .filter(x => !x.hidden)\n                  .indexOf(shadowRootItem);\n            return this.#items.filter(x => !x.hidden)[index];\n          }\n        }\n      }\n    } else {\n      // otherwise, query the root (e.g. shadow root) for the associated element\n      const element = event.target as HTMLElement;\n\n      const root = element.getRootNode() as ShadowRoot | Document;\n\n      const controlsId = element?.getAttribute('aria-controls');\n      const shadowRootListboxElement =\n          this.#options.isItem(element) ? this.container\n        : controlsId ? root.getElementById(controlsId)\n        : null;\n\n      const shadowRootHasActiveDescendantElement =\n        root.querySelector(`[aria-controls=\"${shadowRootListboxElement?.id}\"][aria-activedescendant]`);\n\n      const shadowRootItemId =\n        shadowRootHasActiveDescendantElement?.getAttribute('aria-activedescendant');\n\n      const shadowRootItem =\n        shadowRootItemId && root.getElementById(shadowRootItemId) as Item | null;\n\n      if (shadowRootItem && shadowRootListboxElement) {\n        if (this.items.includes(shadowRootItem)) {\n          return shadowRootItem;\n        } else {\n          const index =\n            Array.from(shadowRootListboxElement?.children ?? [])\n                .filter(this.#options.isItem)\n                .filter(x => !x.hidden)\n                .indexOf(shadowRootItem);\n          return this.#items.filter(x => !x.hidden)[index];\n        }\n      }\n\n      const itemFromEventContainer =\n        shadowRootListboxElement ? shadowRootListboxElement\n      : path.find(x =>\n        x instanceof HTMLElement && x.role === 'listbox') as HTMLElement;\n\n      if (itemFromEventContainer) {\n        const possiblyShadowRootContainerItems = Array.from(itemFromEventContainer.children)\n            .filter(this.#options.isItem);\n\n        const index = possiblyShadowRootContainerItems\n            .findIndex(node => path.includes(node));\n\n        if (index >= 0) {\n          return this.items[index] ?? null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * handles clicking on a listbox option:\n   * which selects an item by default\n   * or toggles selection if multiselectable\n   * @param event click event\n   */\n  #onClick = (event: MouseEvent) => {\n    const item = this.#getItemFromEvent(event);\n    this.#shiftStartingItem ??= this.#getItemFromEvent(event);\n    if (item && !this.#options.isItemDisabled(item)) {\n      // Case: single select?\n      //       just reset the selected list.\n      if (!this.multi) {\n        // select target and deselect all other options\n        this.selected = [item];\n      // Case: multi select, but no shift key\n      //       toggle target, keep all other previously selected\n      } else if (!event.shiftKey) {\n        this.selected = this.items.filter(possiblySelectedItem =>\n            this.#selectedItems.has(possiblySelectedItem) ? possiblySelectedItem !== item\n          : possiblySelectedItem === item);\n      // Case: multi select, with shift key\n      //       find all items between previously selected and target,\n      //       and select them (if reference item is selected) or deselect them (if reference item is deselected)\n      //       Do not wrap around from end to start, rather, only select withing the range of 0-end\n      } else {\n        const startingItem = this.#shiftStartingItem!;\n        // whether options will be selected (true) or deselected (false)\n        const selecting = this.#selectedItems.has(startingItem);\n        const [start, end] = [this.items.indexOf(startingItem), this.items.indexOf(item)].sort();\n        // de/select all options between active descendant and target\n        this.selected = this.items.filter((item, i) => {\n          if (i >= start && i <= end) {\n            return selecting;\n          } else {\n            return this.#selectedItems.has(item);\n          }\n        });\n      }\n    }\n    this.#shiftStartingItem = item;\n    this.host.requestUpdate();\n  };\n\n  /**\n   * track whether shift key is being used for multiselectable listbox\n   * @param event keyup event\n   */\n  #onKeyup = (event: KeyboardEvent) => {\n    if (event.key === 'Shift') {\n      this.#shiftStartingItem = null;\n    }\n  };\n\n  /**\n   * filters listbox by keyboard event when slotted option has focus,\n   * or by external element such as a text field\n   * @param event keydown event\n   */\n  #onKeydown = (event: KeyboardEvent) => {\n    const item = this.#getItemFromEvent(event);\n\n    if (this.disabled\n      || event.altKey\n      || event.metaKey\n      || !this.#isExpanded) {\n      return;\n    }\n\n    // need to set for keyboard support of multiselect\n    if (event.key === 'Shift' && this.multi) {\n      this.#shiftStartingItem ??= this.#options.getATFocusedItem() ?? null;\n    }\n\n    switch (event.key) {\n      // ctrl+A de/selects all options\n      case 'a':\n      case 'A':\n        if (event.ctrlKey\n            && (event.target === this.container\n                || this.#options.isItem(event.target))) {\n          const selectableItems = this.items.filter(item => !this.#options.isItemDisabled(item));\n          if (arraysAreEquivalent(this.selected, selectableItems)) {\n            this.selected = [];\n          } else {\n            this.selected = selectableItems;\n          }\n          event.preventDefault();\n        }\n        break;\n      case 'Enter':\n        // enter and space are only applicable if a listbox option is clicked\n        // an external text input should not trigger multiselect\n        if (item && !event.shiftKey) {\n          const focused = item;\n          this.#selectItem(focused, event.shiftKey);\n          event.preventDefault();\n        }\n        break;\n      case 'ArrowUp':\n        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {\n          const item = event.target;\n          this.selected = this.items.filter((x, i) =>\n            this.#selectedItems.has(x)\n            || i === this.items.indexOf(item) - 1)\n              .filter(x => !this.#options.isItemDisabled(x));\n        }\n        break;\n      case 'ArrowDown':\n        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {\n          const item = event.target;\n          this.selected = this.items.filter((x, i) =>\n            this.#selectedItems.has(x)\n            || i === this.items.indexOf(item) + 1)\n              .filter(x => !this.#options.isItemDisabled(x));\n        }\n        break;\n      case ' ':\n        // enter and space are only applicable if a listbox option is clicked\n        // an external text input should not trigger multiselect\n        if (item && event.target === this.container) {\n          this.#selectItem(item, event.shiftKey);\n          event.preventDefault();\n        } else if (this.#options.isItem(event.target)) {\n          this.#selectItem(event.target, event.shiftKey);\n          event.preventDefault();\n        }\n        break;\n      default:\n        break;\n    }\n    this.host.requestUpdate();\n  };\n\n  #selectItem(item: Item, shiftDown = false) {\n    if (this.#options.isItemDisabled(item)) {\n      return;\n    } else if (this.multi && shiftDown) {\n      // update starting item for other multiselect\n      this.selected = [...this.selected, item];\n    } else if (this.multi && this.#selectedItems.has(item)) {\n      this.selected = this.selected.filter(x => x !== item);\n    } else if (this.multi) {\n      this.selected = this.selected.concat(item);\n    } else {\n      this.selected = [item];\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"listbox-controller.js","sourceRoot":"","sources":["listbox-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\nimport type { RequireProps } from '../core.ts';\n\nimport { isServer } from 'lit';\nimport { arraysAreEquivalent } from '../functions/arraysAreEquivalent.js';\nimport { InternalsController } from './internals-controller.js';\n\n/**\n * Options for listbox controller\n */\nexport interface ListboxControllerOptions<Item extends HTMLElement> {\n  /**\n   * Whether the listbox supports multiple selections.\n   */\n  multi?: boolean;\n  /**\n   * Optional callback to control the selection behavior of items. By default, ListboxController\n   * will set the `aria-selected` attribute. When overriding this option, it will call it on your\n   * element with the selected state.\n   * Callers **must** ensure that the correct ARIA state is set.\n   */\n  setItemSelected?(item: Item, selected: boolean): void;\n  /**\n   * Optional predicate to ascertain whether a custom element item is disabled or not\n   * By default, if the item matches any of these conditions, it is considered disabled:\n   * 1. it's `disabled` DOM property is `true`\n   * 1. it has the `aria-disabled=\"true\"` attribute\n   * 2. it has the `disabled` attribute present\n   * 3. it matches the `:disabled` pseudo selector\n   */\n  isItemDisabled?(item: Item): boolean;\n  /**\n   * Predicate which determines if a given element is in fact an item\n   * instead of e.g a presentational divider. By default, elements must meet the following criteria\n   * 1. element a child of a listbox role,\n   * 2. element does not have role=\"presentation\"\n   * 2. element is not an `<hr>`\n   * **NB**: When overriding, you must avoid outside references. This predicate must\n   * only consider the element itself, without reference to the host element's items array.\n   * @example ```js\n   *          isItem: (item) => item instanceof MyCustomItem\n   *          ```\n   */\n  isItem?(item: EventTarget | null): item is Item;\n  /**\n   * Function returning the item which currently has assistive technology focus.\n   * In most cases, this should be the `atFocusedItem` of an ATFocusController\n   * i.e. RovingTabindexController or ActivedescendantController.\n   *\n   */\n  getATFocusedItem(): Item | null;\n  /**\n   * Function returning the DOM node which is the direct parent of the item elements\n   * Defaults to the controller host.\n   * If the controller host is not an HTMLElement, this *must* be set\n   */\n  getItemsContainer?(): HTMLElement | null;\n  /**\n   * Optional function returning an additional DOM node which controls the listbox, e.g.\n   * a combobox input.\n   */\n  getControlsElements?(): HTMLElement[];\n}\n\n/**\n * This is the default method for setting the selected state on an item element\n * @param item the item\n * @param selected is this item selected\n */\nfunction setItemSelected<Item extends HTMLElement>(item: Item, selected: boolean) {\n  if (selected) {\n    item.setAttribute('aria-selected', 'true');\n  } else {\n    item.removeAttribute('aria-selected');\n  }\n}\n\n/**\n * @param item possible disabled item\n * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time\n */\nexport function isItem<Item extends HTMLElement>(item: EventTarget | null): item is Item {\n  return item instanceof Element\n    && item?.parentElement?.role === 'listbox'\n    && item?.role !== 'presentation'\n    && item?.localName !== 'hr';\n}\n\n/**\n * This is a fib. aria-disabled might not be present on an element that uses internals,\n * and the `disabled` attribute may not accurately represent the disabled state.\n * short of patching the `attachInternals` constructor, it may not be possible at\n * runtime to know with certainty that an arbitrary custom element is disabled or not.\n * @param item possibly disabled item\n * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time\n */\nexport function isItemDisabled<Item extends HTMLElement>(item: Item): boolean {\n  return ('disabled' in item && typeof item.disabled === 'boolean' && item.disabled)\n      || item.getAttribute('aria-disabled') === 'true'\n      || item.hasAttribute('disabled')\n      || item.hasAttribute('inert')\n      || item.matches(':disabled');\n}\n\nlet constructingAllowed = false;\n\n/**\n * Implements listbox semantics and accesibility. As there are two recognized\n * patterns for implementing keyboard interactions with listbox patterns,\n * provide a secondary controller (either RovingTabindexController or\n * ActiveDescendantController) to complete the implementation.\n *\n * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_vs_selection\n *\n * > Occasionally, it may appear as if two elements on the page have focus at the same time.\n * > For example, in a multi-select list box, when an option is selected it may be greyed.\n * > Yet, the focus indicator can still be moved to other options, which may also be selected.\n * > Similarly, when a user activates a tab in a tablist, the selected state is set on the tab\n * > and its visual appearance changes. However, the user can still navigate, moving the focus\n * > indicator elsewhere on the page while the tab retains its selected appearance and state.\n * >\n * > Focus and selection are quite different. From the keyboard user's perspective,\n * > focus is a pointer, like a mouse pointer; it tracks the path of navigation.\n * > There is only one point of focus at any time and all operations take place at the\n * > point of focus. On the other hand, selection is an operation that can be performed in\n * > some widgets, such as list boxes, trees, and tablists. If a widget supports only single\n * > selection, then only one item can be selected and very often the selected state will simply\n * > follow the focus when focus is moved inside of the widget.\n * > That is, in some widgets, moving focus may also perform the select operation.\n * > However, if the widget supports multiple selection, then more than one item can be in a\n * > selected state, and keys for moving focus do not perform selection. Some multi-select widgets\n * > do support key commands that both move focus and change selection, but those keys are\n * > different from the normal navigation keys. Finally, when focus leaves a widget that includes\n * > a selected element, the selected state persists.\n * >\n * > From the developer's perspective, the difference is simple -- the focused element is the\n * > active element (document.activeElement). Selected elements are elements that have\n * > aria-selected=\"true\".\n * >\n * > With respect to focus and the selected state, the most important considerations for designers\n * > and developers are:\n * >\n * > - The visual focus indicator must always be visible.\n * > - The selected state must be visually distinct from the focus indicator.\n */\nexport class ListboxController<Item extends HTMLElement> implements ReactiveController {\n  private static instances = new WeakMap<ReactiveControllerHost, ListboxController<HTMLElement>>();\n\n  public static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: ListboxControllerOptions<Item>,\n  ): ListboxController<Item> {\n    constructingAllowed = true;\n    const instance = new ListboxController<Item>(host, options);\n    constructingAllowed = false;\n    return instance as ListboxController<Item>;\n  }\n\n  /** Current active descendant when shift key is pressed */\n  #shiftStartingItem: Item | null = null;\n\n  #options: RequireProps<ListboxControllerOptions<Item>,\n    | 'setItemSelected'\n    | 'isItemDisabled'\n    | 'isItem'\n  >;\n\n  /** All items */\n  #items: Item[] = [];\n\n  #selectedItems = new Set<Item>;\n\n  #listening = false;\n\n  /** Whether listbox is disabled */\n  disabled = false;\n\n  get container(): HTMLElement {\n    return this.#options.getItemsContainer?.() ?? this.host as unknown as HTMLElement;\n  }\n\n  get multi(): boolean {\n    return !!this.#options.multi;\n  }\n\n  set multi(v: boolean) {\n    this.#options.multi = v;\n    this.host.requestUpdate();\n  }\n\n  get items(): Item[] {\n    return this.#items;\n  }\n\n  /**\n   * Registers the host's item elements as listbox controller items.\n   * @param items - Array of listbox option elements.\n   */\n  set items(items: Item[]) {\n    if (!arraysAreEquivalent(items, this.#items)) {\n      this.#items = items;\n      this.host.requestUpdate();\n    }\n  }\n\n  /**\n   * sets the listbox value based on selected options\n   * @param selected item or items\n   */\n  set selected(selected: Item[]) {\n    if (!arraysAreEquivalent(selected, Array.from(this.#selectedItems))) {\n      this.#selectedItems = new Set(selected);\n      for (const item of this.items) {\n        this.#options.setItemSelected(item, this.#selectedItems.has(item));\n      }\n      this.host.requestUpdate();\n    }\n  }\n\n  /**\n   * array of options which are selected\n   */\n  get selected(): Item[] {\n    return [...this.#selectedItems];\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    options: ListboxControllerOptions<Item>,\n  ) {\n    this.#options = { setItemSelected, isItemDisabled, isItem, ...options };\n    if (!constructingAllowed) {\n      throw new Error('ListboxController must be constructed with `ListboxController.of()`');\n    }\n    if (!isServer\n        && !(host instanceof HTMLElement)\n        && typeof options.getItemsContainer !== 'function') {\n      throw new Error([\n        'ListboxController requires the host to be an HTMLElement',\n        'or for the initializer to include a getItemsContainer() function',\n      ].join(' '));\n    }\n    const instance = ListboxController.instances.get(host) as unknown as ListboxController<Item>;\n    if (instance) {\n      return instance as ListboxController<Item>;\n    }\n    ListboxController.instances.set(host, this as unknown as ListboxController<HTMLElement>);\n    this.host.addController(this);\n    this.multi = this.#options.multi ?? false;\n    if (this.container?.isConnected) {\n      this.hostConnected();\n    }\n  }\n\n  async hostConnected(): Promise<void> {\n    await this.host.updateComplete;\n    this.hostUpdate();\n    this.hostUpdated();\n  }\n\n  #controlsElements: HTMLElement[] = [];\n\n  #removeControlsListeners(els = this.#controlsElements) {\n    for (const el of els) {\n      el.removeEventListener('keydown', this.#onKeydown);\n      el.removeEventListener('keyup', this.#onKeyup);\n    }\n  }\n\n  /**\n   * Called during host update; syncs control element listeners and\n   * applies aria-posinset/aria-setsize to each item via InternalsController.\n   */\n  hostUpdate(): void {\n    const last = this.#controlsElements;\n    this.#controlsElements = this.#options.getControlsElements?.() ?? [];\n    if (!arraysAreEquivalent(last, this.#controlsElements)) {\n      this.#removeControlsListeners(last);\n      for (const el of this.#controlsElements) {\n        el.addEventListener('keydown', this.#onKeydown);\n        el.addEventListener('keyup', this.#onKeyup);\n      }\n    }\n    const items = this.#items;\n    items.forEach((item, index) => {\n      InternalsController.setAriaPosInSet(item, index + 1);\n      InternalsController.setAriaSetSize(item, items.length);\n    });\n  }\n\n  hostUpdated(): void {\n    if (!this.#listening) {\n      this.container?.addEventListener('click', this.#onClick);\n      this.container?.addEventListener('keydown', this.#onKeydown);\n      this.container?.addEventListener('keyup', this.#onKeyup);\n      this.#listening = true;\n    }\n    this.container?.setAttribute('role', 'listbox');\n    this.container?.setAttribute('aria-disabled', String(!!this.disabled));\n    this.container?.setAttribute('aria-multiselectable', String(!!this.#options.multi));\n  }\n\n  hostDisconnected(): void {\n    this.container?.removeEventListener('click', this.#onClick);\n    this.container?.removeEventListener('keydown', this.#onKeydown);\n    this.container?.removeEventListener('keyup', this.#onKeyup);\n    this.#removeControlsListeners();\n    this.#listening = false;\n  }\n\n  public isSelected(item: Item): boolean {\n    return this.#selectedItems.has(item);\n  }\n\n  get #isExpanded() {\n    return !this.#controlsElements.length ? true\n      : this.#controlsElements.every(x => x.ariaExpanded === 'true');\n  }\n\n  /**\n   * In the case where aria IDL attributes are not supported,\n   * we need to correlate the item in the event path (i.e. the shadow dom clone)\n   * with the item in listbox controller's root (i.e. the hidden light dom original)\n   * XXX: as long as there is no DOM preceeding the shadow root clones, this will work\n   * @param event click or keyboard event\n   */\n  #getItemFromEvent(event: Event): Item | null {\n    // NOTE(bennypowers): I am aware that this function *sucks*\n    // you're more than welcome to improve it.\n    // make sure there are unit tests first\n    const path = event.composedPath();\n    const tabindexed = this.items.some(x => x.hasAttribute('tabindex'));\n    if (tabindexed) {\n      const item = path.find(this.#options.isItem);\n      if (item) {\n        return item;\n      }\n    } else if (this.#options.isItem(event.target)\n               && event.target.getRootNode() !== this.container.getRootNode()\n               && 'ariaActiveDescendantElement' in HTMLElement.prototype) {\n      return event.target;\n    } else if (event.target instanceof HTMLElement && event.target.ariaActiveDescendantElement) {\n      return event.target.ariaActiveDescendantElement as Item;\n    } else if (event.type === 'click'\n               && this.#options.isItem(event.target)\n               && event.target.id) {\n      const element = event.target;\n      const root = element.getRootNode();\n      if (root instanceof ShadowRoot && this.container.getRootNode() === root) {\n        const shadowRootListboxElement = this.container;\n        const shadowRootItem = element;\n        if (shadowRootItem && shadowRootListboxElement) {\n          if (this.items.includes(shadowRootItem)) {\n            return shadowRootItem;\n          } else {\n            const index =\n              Array.from(shadowRootListboxElement?.children ?? [])\n                  .filter(this.#options.isItem)\n                  .filter(x => !x.hidden)\n                  .indexOf(shadowRootItem);\n            return this.#items.filter(x => !x.hidden)[index];\n          }\n        }\n      }\n    } else {\n      // otherwise, query the root (e.g. shadow root) for the associated element\n      const element = event.target as HTMLElement;\n\n      const root = element.getRootNode() as ShadowRoot | Document;\n\n      const controlsId = element?.getAttribute('aria-controls');\n      const shadowRootListboxElement =\n          this.#options.isItem(element) ? this.container\n        : controlsId ? root.getElementById(controlsId)\n        : null;\n\n      const shadowRootHasActiveDescendantElement =\n        root.querySelector(`[aria-controls=\"${shadowRootListboxElement?.id}\"][aria-activedescendant]`);\n\n      const shadowRootItemId =\n        shadowRootHasActiveDescendantElement?.getAttribute('aria-activedescendant');\n\n      const shadowRootItem =\n        shadowRootItemId && root.getElementById(shadowRootItemId) as Item | null;\n\n      if (shadowRootItem && shadowRootListboxElement) {\n        if (this.items.includes(shadowRootItem)) {\n          return shadowRootItem;\n        } else {\n          // Shadow clone needs to be mapped back to light DOM item.\n          // Match by value attribute or text content since index-based matching\n          // doesn't work when items are filtered (hidden state differs between clone and source)\n          const cloneValue = shadowRootItem.getAttribute('value')\n                          ?? shadowRootItem.textContent?.trim();\n          const sourceItem = this.#items.find(item =>\n            (item.getAttribute('value') ?? item.textContent?.trim()) === cloneValue\n          );\n          return sourceItem ?? null;\n        }\n      }\n\n      const itemFromEventContainer =\n        shadowRootListboxElement ? shadowRootListboxElement\n      : path.find(x =>\n        x instanceof HTMLElement && x.role === 'listbox') as HTMLElement;\n\n      if (itemFromEventContainer) {\n        const possiblyShadowRootContainerItems = Array.from(itemFromEventContainer.children)\n            .filter(this.#options.isItem);\n\n        const index = possiblyShadowRootContainerItems\n            .findIndex(node => path.includes(node));\n\n        if (index >= 0) {\n          return this.items[index] ?? null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * handles clicking on a listbox option:\n   * which selects an item by default\n   * or toggles selection if multiselectable\n   * @param event click event\n   */\n  #onClick = (event: MouseEvent) => {\n    const item = this.#getItemFromEvent(event);\n    this.#shiftStartingItem ??= this.#getItemFromEvent(event);\n    if (item && !this.#options.isItemDisabled(item)) {\n      // Case: single select?\n      //       just reset the selected list.\n      if (!this.multi) {\n        // select target and deselect all other options\n        this.selected = [item];\n      // Case: multi select, but no shift key\n      //       toggle target, keep all other previously selected\n      } else if (!event.shiftKey) {\n        this.selected = this.items.filter(possiblySelectedItem =>\n            this.#selectedItems.has(possiblySelectedItem) ? possiblySelectedItem !== item\n          : possiblySelectedItem === item);\n      // Case: multi select, with shift key\n      //       find all items between previously selected and target,\n      //       and select them (if reference item is selected) or deselect them (if reference item is deselected)\n      //       Do not wrap around from end to start, rather, only select withing the range of 0-end\n      } else {\n        const startingItem = this.#shiftStartingItem!;\n        // whether options will be selected (true) or deselected (false)\n        const selecting = this.#selectedItems.has(startingItem);\n        const [start, end] = [this.items.indexOf(startingItem), this.items.indexOf(item)].sort();\n        // de/select all options between active descendant and target\n        this.selected = this.items.filter((item, i) => {\n          if (i >= start && i <= end) {\n            return selecting;\n          } else {\n            return this.#selectedItems.has(item);\n          }\n        });\n      }\n    }\n    this.#shiftStartingItem = item;\n    this.host.requestUpdate();\n  };\n\n  /**\n   * track whether shift key is being used for multiselectable listbox\n   * @param event keyup event\n   */\n  #onKeyup = (event: KeyboardEvent) => {\n    if (event.key === 'Shift') {\n      this.#shiftStartingItem = null;\n    }\n  };\n\n  /**\n   * filters listbox by keyboard event when slotted option has focus,\n   * or by external element such as a text field\n   * @param event keydown event\n   */\n  #onKeydown = (event: KeyboardEvent) => {\n    const item = this.#getItemFromEvent(event);\n\n    if (this.disabled\n      || event.altKey\n      || event.metaKey\n      || !this.#isExpanded) {\n      return;\n    }\n\n    // need to set for keyboard support of multiselect\n    if (event.key === 'Shift' && this.multi) {\n      this.#shiftStartingItem ??= this.#options.getATFocusedItem() ?? null;\n    }\n\n    switch (event.key) {\n      // ctrl+A de/selects all options\n      case 'a':\n      case 'A':\n        if (event.ctrlKey\n            && (event.target === this.container\n                || this.#options.isItem(event.target))) {\n          const selectableItems = this.items.filter(item => !this.#options.isItemDisabled(item));\n          if (arraysAreEquivalent(this.selected, selectableItems)) {\n            this.selected = [];\n          } else {\n            this.selected = selectableItems;\n          }\n          event.preventDefault();\n        }\n        break;\n      case 'Enter':\n        // enter and space are only applicable if a listbox option is clicked\n        // an external text input should not trigger multiselect\n        if (item && !event.shiftKey) {\n          const focused = item;\n          this.#selectItem(focused, event.shiftKey);\n          event.preventDefault();\n        }\n        break;\n      case 'ArrowUp':\n        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {\n          const item = event.target;\n          this.selected = this.items.filter((x, i) =>\n            this.#selectedItems.has(x)\n            || i === this.items.indexOf(item) - 1)\n              .filter(x => !this.#options.isItemDisabled(x));\n        }\n        break;\n      case 'ArrowDown':\n        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {\n          const item = event.target;\n          this.selected = this.items.filter((x, i) =>\n            this.#selectedItems.has(x)\n            || i === this.items.indexOf(item) + 1)\n              .filter(x => !this.#options.isItemDisabled(x));\n        }\n        break;\n      case ' ':\n        // enter and space are only applicable if a listbox option is clicked\n        // an external text input should not trigger multiselect\n        if (item && event.target === this.container) {\n          this.#selectItem(item, event.shiftKey);\n          event.preventDefault();\n        } else if (this.#options.isItem(event.target)) {\n          this.#selectItem(event.target, event.shiftKey);\n          event.preventDefault();\n        }\n        break;\n      default:\n        break;\n    }\n    this.host.requestUpdate();\n  };\n\n  #selectItem(item: Item, shiftDown = false) {\n    if (this.#options.isItemDisabled(item)) {\n      return;\n    } else if (this.multi && shiftDown) {\n      // update starting item for other multiselect\n      this.selected = [...this.selected, item];\n    } else if (this.multi && this.#selectedItems.has(item)) {\n      this.selected = this.selected.filter(x => x !== item);\n    } else if (this.multi) {\n      this.selected = this.selected.concat(item);\n    } else {\n      this.selected = [item];\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/listbox-controller.ts b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.ts
new file mode 100644
index 0000000..491d77d
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/listbox-controller.ts
@@ -0,0 +1,571 @@
+import type { ReactiveController, ReactiveControllerHost } from 'lit';
+import type { RequireProps } from '../core.ts';
+
+import { isServer } from 'lit';
+import { arraysAreEquivalent } from '../functions/arraysAreEquivalent.js';
+import { InternalsController } from './internals-controller.js';
+
+/**
+ * Options for listbox controller
+ */
+export interface ListboxControllerOptions<Item extends HTMLElement> {
+  /**
+   * Whether the listbox supports multiple selections.
+   */
+  multi?: boolean;
+  /**
+   * Optional callback to control the selection behavior of items. By default, ListboxController
+   * will set the `aria-selected` attribute. When overriding this option, it will call it on your
+   * element with the selected state.
+   * Callers **must** ensure that the correct ARIA state is set.
+   */
+  setItemSelected?(item: Item, selected: boolean): void;
+  /**
+   * Optional predicate to ascertain whether a custom element item is disabled or not
+   * By default, if the item matches any of these conditions, it is considered disabled:
+   * 1. it's `disabled` DOM property is `true`
+   * 1. it has the `aria-disabled="true"` attribute
+   * 2. it has the `disabled` attribute present
+   * 3. it matches the `:disabled` pseudo selector
+   */
+  isItemDisabled?(item: Item): boolean;
+  /**
+   * Predicate which determines if a given element is in fact an item
+   * instead of e.g a presentational divider. By default, elements must meet the following criteria
+   * 1. element a child of a listbox role,
+   * 2. element does not have role="presentation"
+   * 2. element is not an `<hr>`
+   * **NB**: When overriding, you must avoid outside references. This predicate must
+   * only consider the element itself, without reference to the host element's items array.
+   * @example ```js
+   *          isItem: (item) => item instanceof MyCustomItem
+   *          ```
+   */
+  isItem?(item: EventTarget | null): item is Item;
+  /**
+   * Function returning the item which currently has assistive technology focus.
+   * In most cases, this should be the `atFocusedItem` of an ATFocusController
+   * i.e. RovingTabindexController or ActivedescendantController.
+   *
+   */
+  getATFocusedItem(): Item | null;
+  /**
+   * Function returning the DOM node which is the direct parent of the item elements
+   * Defaults to the controller host.
+   * If the controller host is not an HTMLElement, this *must* be set
+   */
+  getItemsContainer?(): HTMLElement | null;
+  /**
+   * Optional function returning an additional DOM node which controls the listbox, e.g.
+   * a combobox input.
+   */
+  getControlsElements?(): HTMLElement[];
+}
+
+/**
+ * This is the default method for setting the selected state on an item element
+ * @param item the item
+ * @param selected is this item selected
+ */
+function setItemSelected<Item extends HTMLElement>(item: Item, selected: boolean) {
+  if (selected) {
+    item.setAttribute('aria-selected', 'true');
+  } else {
+    item.removeAttribute('aria-selected');
+  }
+}
+
+/**
+ * @param item possible disabled item
+ * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time
+ */
+export function isItem<Item extends HTMLElement>(item: EventTarget | null): item is Item {
+  return item instanceof Element
+    && item?.parentElement?.role === 'listbox'
+    && item?.role !== 'presentation'
+    && item?.localName !== 'hr';
+}
+
+/**
+ * This is a fib. aria-disabled might not be present on an element that uses internals,
+ * and the `disabled` attribute may not accurately represent the disabled state.
+ * short of patching the `attachInternals` constructor, it may not be possible at
+ * runtime to know with certainty that an arbitrary custom element is disabled or not.
+ * @param item possibly disabled item
+ * @package do not import this outside of `@patternfly/pfe-core`, it is subject to change at any time
+ */
+export function isItemDisabled<Item extends HTMLElement>(item: Item): boolean {
+  return ('disabled' in item && typeof item.disabled === 'boolean' && item.disabled)
+      || item.getAttribute('aria-disabled') === 'true'
+      || item.hasAttribute('disabled')
+      || item.hasAttribute('inert')
+      || item.matches(':disabled');
+}
+
+let constructingAllowed = false;
+
+/**
+ * Implements listbox semantics and accesibility. As there are two recognized
+ * patterns for implementing keyboard interactions with listbox patterns,
+ * provide a secondary controller (either RovingTabindexController or
+ * ActiveDescendantController) to complete the implementation.
+ *
+ * @see https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_vs_selection
+ *
+ * > Occasionally, it may appear as if two elements on the page have focus at the same time.
+ * > For example, in a multi-select list box, when an option is selected it may be greyed.
+ * > Yet, the focus indicator can still be moved to other options, which may also be selected.
+ * > Similarly, when a user activates a tab in a tablist, the selected state is set on the tab
+ * > and its visual appearance changes. However, the user can still navigate, moving the focus
+ * > indicator elsewhere on the page while the tab retains its selected appearance and state.
+ * >
+ * > Focus and selection are quite different. From the keyboard user's perspective,
+ * > focus is a pointer, like a mouse pointer; it tracks the path of navigation.
+ * > There is only one point of focus at any time and all operations take place at the
+ * > point of focus. On the other hand, selection is an operation that can be performed in
+ * > some widgets, such as list boxes, trees, and tablists. If a widget supports only single
+ * > selection, then only one item can be selected and very often the selected state will simply
+ * > follow the focus when focus is moved inside of the widget.
+ * > That is, in some widgets, moving focus may also perform the select operation.
+ * > However, if the widget supports multiple selection, then more than one item can be in a
+ * > selected state, and keys for moving focus do not perform selection. Some multi-select widgets
+ * > do support key commands that both move focus and change selection, but those keys are
+ * > different from the normal navigation keys. Finally, when focus leaves a widget that includes
+ * > a selected element, the selected state persists.
+ * >
+ * > From the developer's perspective, the difference is simple -- the focused element is the
+ * > active element (document.activeElement). Selected elements are elements that have
+ * > aria-selected="true".
+ * >
+ * > With respect to focus and the selected state, the most important considerations for designers
+ * > and developers are:
+ * >
+ * > - The visual focus indicator must always be visible.
+ * > - The selected state must be visually distinct from the focus indicator.
+ */
+export class ListboxController<Item extends HTMLElement> implements ReactiveController {
+  private static instances = new WeakMap<ReactiveControllerHost, ListboxController<HTMLElement>>();
+
+  public static of<Item extends HTMLElement>(
+    host: ReactiveControllerHost,
+    options: ListboxControllerOptions<Item>,
+  ): ListboxController<Item> {
+    constructingAllowed = true;
+    const instance = new ListboxController<Item>(host, options);
+    constructingAllowed = false;
+    return instance as ListboxController<Item>;
+  }
+
+  /** Current active descendant when shift key is pressed */
+  #shiftStartingItem: Item | null = null;
+
+  #options: RequireProps<ListboxControllerOptions<Item>,
+    | 'setItemSelected'
+    | 'isItemDisabled'
+    | 'isItem'
+  >;
+
+  /** All items */
+  #items: Item[] = [];
+
+  #selectedItems = new Set<Item>;
+
+  #listening = false;
+
+  /** Whether listbox is disabled */
+  disabled = false;
+
+  get container(): HTMLElement {
+    return this.#options.getItemsContainer?.() ?? this.host as unknown as HTMLElement;
+  }
+
+  get multi(): boolean {
+    return !!this.#options.multi;
+  }
+
+  set multi(v: boolean) {
+    this.#options.multi = v;
+    this.host.requestUpdate();
+  }
+
+  get items(): Item[] {
+    return this.#items;
+  }
+
+  /**
+   * Registers the host's item elements as listbox controller items.
+   * @param items - Array of listbox option elements.
+   */
+  set items(items: Item[]) {
+    if (!arraysAreEquivalent(items, this.#items)) {
+      this.#items = items;
+      this.host.requestUpdate();
+    }
+  }
+
+  /**
+   * sets the listbox value based on selected options
+   * @param selected item or items
+   */
+  set selected(selected: Item[]) {
+    if (!arraysAreEquivalent(selected, Array.from(this.#selectedItems))) {
+      this.#selectedItems = new Set(selected);
+      for (const item of this.items) {
+        this.#options.setItemSelected(item, this.#selectedItems.has(item));
+      }
+      this.host.requestUpdate();
+    }
+  }
+
+  /**
+   * array of options which are selected
+   */
+  get selected(): Item[] {
+    return [...this.#selectedItems];
+  }
+
+  private constructor(
+    public host: ReactiveControllerHost,
+    options: ListboxControllerOptions<Item>,
+  ) {
+    this.#options = { setItemSelected, isItemDisabled, isItem, ...options };
+    if (!constructingAllowed) {
+      throw new Error('ListboxController must be constructed with `ListboxController.of()`');
+    }
+    if (!isServer
+        && !(host instanceof HTMLElement)
+        && typeof options.getItemsContainer !== 'function') {
+      throw new Error([
+        'ListboxController requires the host to be an HTMLElement',
+        'or for the initializer to include a getItemsContainer() function',
+      ].join(' '));
+    }
+    const instance = ListboxController.instances.get(host) as unknown as ListboxController<Item>;
+    if (instance) {
+      return instance as ListboxController<Item>;
+    }
+    ListboxController.instances.set(host, this as unknown as ListboxController<HTMLElement>);
+    this.host.addController(this);
+    this.multi = this.#options.multi ?? false;
+    if (this.container?.isConnected) {
+      this.hostConnected();
+    }
+  }
+
+  async hostConnected(): Promise<void> {
+    await this.host.updateComplete;
+    this.hostUpdate();
+    this.hostUpdated();
+  }
+
+  #controlsElements: HTMLElement[] = [];
+
+  #removeControlsListeners(els = this.#controlsElements) {
+    for (const el of els) {
+      el.removeEventListener('keydown', this.#onKeydown);
+      el.removeEventListener('keyup', this.#onKeyup);
+    }
+  }
+
+  /**
+   * Called during host update; syncs control element listeners and
+   * applies aria-posinset/aria-setsize to each item via InternalsController.
+   */
+  hostUpdate(): void {
+    const last = this.#controlsElements;
+    this.#controlsElements = this.#options.getControlsElements?.() ?? [];
+    if (!arraysAreEquivalent(last, this.#controlsElements)) {
+      this.#removeControlsListeners(last);
+      for (const el of this.#controlsElements) {
+        el.addEventListener('keydown', this.#onKeydown);
+        el.addEventListener('keyup', this.#onKeyup);
+      }
+    }
+    const items = this.#items;
+    items.forEach((item, index) => {
+      InternalsController.setAriaPosInSet(item, index + 1);
+      InternalsController.setAriaSetSize(item, items.length);
+    });
+  }
+
+  hostUpdated(): void {
+    if (!this.#listening) {
+      this.container?.addEventListener('click', this.#onClick);
+      this.container?.addEventListener('keydown', this.#onKeydown);
+      this.container?.addEventListener('keyup', this.#onKeyup);
+      this.#listening = true;
+    }
+    this.container?.setAttribute('role', 'listbox');
+    this.container?.setAttribute('aria-disabled', String(!!this.disabled));
+    this.container?.setAttribute('aria-multiselectable', String(!!this.#options.multi));
+  }
+
+  hostDisconnected(): void {
+    this.container?.removeEventListener('click', this.#onClick);
+    this.container?.removeEventListener('keydown', this.#onKeydown);
+    this.container?.removeEventListener('keyup', this.#onKeyup);
+    this.#removeControlsListeners();
+    this.#listening = false;
+  }
+
+  public isSelected(item: Item): boolean {
+    return this.#selectedItems.has(item);
+  }
+
+  get #isExpanded() {
+    return !this.#controlsElements.length ? true
+      : this.#controlsElements.every(x => x.ariaExpanded === 'true');
+  }
+
+  /**
+   * In the case where aria IDL attributes are not supported,
+   * we need to correlate the item in the event path (i.e. the shadow dom clone)
+   * with the item in listbox controller's root (i.e. the hidden light dom original)
+   * XXX: as long as there is no DOM preceeding the shadow root clones, this will work
+   * @param event click or keyboard event
+   */
+  #getItemFromEvent(event: Event): Item | null {
+    // NOTE(bennypowers): I am aware that this function *sucks*
+    // you're more than welcome to improve it.
+    // make sure there are unit tests first
+    const path = event.composedPath();
+    const tabindexed = this.items.some(x => x.hasAttribute('tabindex'));
+    if (tabindexed) {
+      const item = path.find(this.#options.isItem);
+      if (item) {
+        return item;
+      }
+    } else if (this.#options.isItem(event.target)
+               && event.target.getRootNode() !== this.container.getRootNode()
+               && 'ariaActiveDescendantElement' in HTMLElement.prototype) {
+      return event.target;
+    } else if (event.target instanceof HTMLElement && event.target.ariaActiveDescendantElement) {
+      return event.target.ariaActiveDescendantElement as Item;
+    } else if (event.type === 'click'
+               && this.#options.isItem(event.target)
+               && event.target.id) {
+      const element = event.target;
+      const root = element.getRootNode();
+      if (root instanceof ShadowRoot && this.container.getRootNode() === root) {
+        const shadowRootListboxElement = this.container;
+        const shadowRootItem = element;
+        if (shadowRootItem && shadowRootListboxElement) {
+          if (this.items.includes(shadowRootItem)) {
+            return shadowRootItem;
+          } else {
+            const index =
+              Array.from(shadowRootListboxElement?.children ?? [])
+                  .filter(this.#options.isItem)
+                  .filter(x => !x.hidden)
+                  .indexOf(shadowRootItem);
+            return this.#items.filter(x => !x.hidden)[index];
+          }
+        }
+      }
+    } else {
+      // otherwise, query the root (e.g. shadow root) for the associated element
+      const element = event.target as HTMLElement;
+
+      const root = element.getRootNode() as ShadowRoot | Document;
+
+      const controlsId = element?.getAttribute('aria-controls');
+      const shadowRootListboxElement =
+          this.#options.isItem(element) ? this.container
+        : controlsId ? root.getElementById(controlsId)
+        : null;
+
+      const shadowRootHasActiveDescendantElement =
+        root.querySelector(`[aria-controls="${shadowRootListboxElement?.id}"][aria-activedescendant]`);
+
+      const shadowRootItemId =
+        shadowRootHasActiveDescendantElement?.getAttribute('aria-activedescendant');
+
+      const shadowRootItem =
+        shadowRootItemId && root.getElementById(shadowRootItemId) as Item | null;
+
+      if (shadowRootItem && shadowRootListboxElement) {
+        if (this.items.includes(shadowRootItem)) {
+          return shadowRootItem;
+        } else {
+          // Shadow clone needs to be mapped back to light DOM item.
+          // Match by value attribute or text content since index-based matching
+          // doesn't work when items are filtered (hidden state differs between clone and source)
+          const cloneValue = shadowRootItem.getAttribute('value')
+                          ?? shadowRootItem.textContent?.trim();
+          const sourceItem = this.#items.find(item =>
+            (item.getAttribute('value') ?? item.textContent?.trim()) === cloneValue
+          );
+          return sourceItem ?? null;
+        }
+      }
+
+      const itemFromEventContainer =
+        shadowRootListboxElement ? shadowRootListboxElement
+      : path.find(x =>
+        x instanceof HTMLElement && x.role === 'listbox') as HTMLElement;
+
+      if (itemFromEventContainer) {
+        const possiblyShadowRootContainerItems = Array.from(itemFromEventContainer.children)
+            .filter(this.#options.isItem);
+
+        const index = possiblyShadowRootContainerItems
+            .findIndex(node => path.includes(node));
+
+        if (index >= 0) {
+          return this.items[index] ?? null;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  /**
+   * handles clicking on a listbox option:
+   * which selects an item by default
+   * or toggles selection if multiselectable
+   * @param event click event
+   */
+  #onClick = (event: MouseEvent) => {
+    const item = this.#getItemFromEvent(event);
+    this.#shiftStartingItem ??= this.#getItemFromEvent(event);
+    if (item && !this.#options.isItemDisabled(item)) {
+      // Case: single select?
+      //       just reset the selected list.
+      if (!this.multi) {
+        // select target and deselect all other options
+        this.selected = [item];
+      // Case: multi select, but no shift key
+      //       toggle target, keep all other previously selected
+      } else if (!event.shiftKey) {
+        this.selected = this.items.filter(possiblySelectedItem =>
+            this.#selectedItems.has(possiblySelectedItem) ? possiblySelectedItem !== item
+          : possiblySelectedItem === item);
+      // Case: multi select, with shift key
+      //       find all items between previously selected and target,
+      //       and select them (if reference item is selected) or deselect them (if reference item is deselected)
+      //       Do not wrap around from end to start, rather, only select withing the range of 0-end
+      } else {
+        const startingItem = this.#shiftStartingItem!;
+        // whether options will be selected (true) or deselected (false)
+        const selecting = this.#selectedItems.has(startingItem);
+        const [start, end] = [this.items.indexOf(startingItem), this.items.indexOf(item)].sort();
+        // de/select all options between active descendant and target
+        this.selected = this.items.filter((item, i) => {
+          if (i >= start && i <= end) {
+            return selecting;
+          } else {
+            return this.#selectedItems.has(item);
+          }
+        });
+      }
+    }
+    this.#shiftStartingItem = item;
+    this.host.requestUpdate();
+  };
+
+  /**
+   * track whether shift key is being used for multiselectable listbox
+   * @param event keyup event
+   */
+  #onKeyup = (event: KeyboardEvent) => {
+    if (event.key === 'Shift') {
+      this.#shiftStartingItem = null;
+    }
+  };
+
+  /**
+   * filters listbox by keyboard event when slotted option has focus,
+   * or by external element such as a text field
+   * @param event keydown event
+   */
+  #onKeydown = (event: KeyboardEvent) => {
+    const item = this.#getItemFromEvent(event);
+
+    if (this.disabled
+      || event.altKey
+      || event.metaKey
+      || !this.#isExpanded) {
+      return;
+    }
+
+    // need to set for keyboard support of multiselect
+    if (event.key === 'Shift' && this.multi) {
+      this.#shiftStartingItem ??= this.#options.getATFocusedItem() ?? null;
+    }
+
+    switch (event.key) {
+      // ctrl+A de/selects all options
+      case 'a':
+      case 'A':
+        if (event.ctrlKey
+            && (event.target === this.container
+                || this.#options.isItem(event.target))) {
+          const selectableItems = this.items.filter(item => !this.#options.isItemDisabled(item));
+          if (arraysAreEquivalent(this.selected, selectableItems)) {
+            this.selected = [];
+          } else {
+            this.selected = selectableItems;
+          }
+          event.preventDefault();
+        }
+        break;
+      case 'Enter':
+        // enter and space are only applicable if a listbox option is clicked
+        // an external text input should not trigger multiselect
+        if (item && !event.shiftKey) {
+          const focused = item;
+          this.#selectItem(focused, event.shiftKey);
+          event.preventDefault();
+        }
+        break;
+      case 'ArrowUp':
+        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {
+          const item = event.target;
+          this.selected = this.items.filter((x, i) =>
+            this.#selectedItems.has(x)
+            || i === this.items.indexOf(item) - 1)
+              .filter(x => !this.#options.isItemDisabled(x));
+        }
+        break;
+      case 'ArrowDown':
+        if (this.multi && event.shiftKey && this.#options.isItem(event.target)) {
+          const item = event.target;
+          this.selected = this.items.filter((x, i) =>
+            this.#selectedItems.has(x)
+            || i === this.items.indexOf(item) + 1)
+              .filter(x => !this.#options.isItemDisabled(x));
+        }
+        break;
+      case ' ':
+        // enter and space are only applicable if a listbox option is clicked
+        // an external text input should not trigger multiselect
+        if (item && event.target === this.container) {
+          this.#selectItem(item, event.shiftKey);
+          event.preventDefault();
+        } else if (this.#options.isItem(event.target)) {
+          this.#selectItem(event.target, event.shiftKey);
+          event.preventDefault();
+        }
+        break;
+      default:
+        break;
+    }
+    this.host.requestUpdate();
+  };
+
+  #selectItem(item: Item, shiftDown = false) {
+    if (this.#options.isItemDisabled(item)) {
+      return;
+    } else if (this.multi && shiftDown) {
+      // update starting item for other multiselect
+      this.selected = [...this.selected, item];
+    } else if (this.multi && this.#selectedItems.has(item)) {
+      this.selected = this.selected.filter(x => x !== item);
+    } else if (this.multi) {
+      this.selected = this.selected.concat(item);
+    } else {
+      this.selected = [item];
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/logger.ts b/node_modules/@patternfly/pfe-core/controllers/logger.ts
new file mode 100644
index 0000000..d7cf7e9
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/logger.ts
@@ -0,0 +1,151 @@
+import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';
+
+export class Logger implements ReactiveController {
+  private static logDebug: boolean;
+
+  private static instances = new WeakMap<ReactiveControllerHost, Logger>();
+
+  private get prefix() {
+    if (!isServer && this.host instanceof HTMLElement) {
+      return `[${this.host.localName}${this.host.id ? `#${this.host.id}` : ''}]`;
+    } else {
+      return `[${this.host.constructor.name}]`;
+    }
+  }
+
+  /**
+   * A boolean value that indicates if the logging should be printed to the console; used for debugging.
+   * For use in a JS file or script tag; can also be added in the constructor of a component during development.
+   * @example Logger.debugLog(true);
+   * @param [preference=null]
+   */
+  static debugLog(preference = null): boolean {
+    // wrap localStorage references in a try/catch; merely referencing it can
+    // throw errors in some locked down environments
+    try {
+      if (preference !== null) {
+        Logger.logDebug = !!preference;
+        localStorage.pfeLog = !!preference;
+      }
+      return localStorage.pfeLog === 'true';
+    } catch {
+      return Logger.logDebug;
+    }
+  }
+
+  /* eslint-disable no-console */
+
+  /**
+   * A logging wrapper which checks the debugLog boolean and prints to the console if true.
+   * @example Logger.debug("Hello");
+   * @param msgs console.log params
+   */
+  static debug(...msgs: unknown[]): void {
+    if (Logger.debugLog()) {
+      console.debug(...msgs);
+    }
+  }
+
+  /**
+   * A logging wrapper which checks the debugLog boolean and prints to the console if true.
+   * @example Logger.info("Hello");
+   * @param msgs console.log params
+   */
+  static info(...msgs: unknown[]): void {
+    if (Logger.debugLog()) {
+      console.info(...msgs);
+    }
+  }
+
+  /**
+   * A logging wrapper which checks the debugLog boolean and prints to the console if true.
+   * @example Logger.log("Hello");
+   * @param msgs console.log params
+   */
+  static log(...msgs: unknown[]): void {
+    if (Logger.debugLog()) {
+      console.log(...msgs);
+    }
+  }
+
+  /**
+   * A console warning wrapper which formats your output with useful debugging information.
+   * @example Logger.warn("Hello");
+   * @param msgs console.log params
+   */
+  static warn(...msgs: unknown[]): void {
+    console.warn(...msgs);
+  }
+
+  /**
+   * A console error wrapper which formats your output with useful debugging information.
+   * For use inside a component's function.
+   * @example Logger.error("Hello");
+   * @param msgs console.log params
+   */
+  static error(...msgs: unknown[]): void {
+    console.error([...msgs].join(' '));
+  }
+
+  /* eslint-enable no-console */
+
+  /**
+   * Debug logging that outputs the tag name as a prefix automatically
+   * @example this.logger.log("Hello");
+   * @param msgs console.log params
+   */
+  debug(...msgs: unknown[]): void {
+    Logger.debug(this.prefix, ...msgs);
+  }
+
+  /**
+   * Info logging that outputs the tag name as a prefix automatically
+   * @example this.logger.log("Hello");
+   * @param msgs console.log params
+   */
+  info(...msgs: unknown[]): void {
+    Logger.info(this.prefix, ...msgs);
+  }
+
+  /**
+   * Local logging that outputs the tag name as a prefix automatically
+   * @example this.logger.log("Hello");
+   * @param msgs console.log params
+   */
+  log(...msgs: unknown[]): void {
+    Logger.log(this.prefix, ...msgs);
+  }
+
+  /**
+   * Local warning wrapper that outputs the tag name as a prefix automatically.
+   * For use inside a component's function.
+   * @example this.logger.warn("Hello");
+   * @param msgs console.log params
+   */
+  warn(...msgs: unknown[]): void {
+    Logger.warn(this.prefix, ...msgs);
+  }
+
+  /**
+   * Local error wrapper that outputs the tag name as a prefix automatically.
+   * For use inside a component's function.
+   * @example this.logger.error("Hello");
+   * @param msgs console.log params
+   */
+  error(...msgs: unknown[]): void {
+    Logger.error(this.prefix, ...msgs);
+  }
+
+  constructor(private host: ReactiveControllerHost) {
+    // We only need one logger instance per host
+    if (Logger.instances.get(host)) {
+      return Logger.instances.get(host) as Logger;
+    }
+    host.addController(this);
+    Logger.instances.set(host, this);
+  }
+
+  hostConnected(): void {
+    this.debug('connected');
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/overflow-controller.ts b/node_modules/@patternfly/pfe-core/controllers/overflow-controller.ts
new file mode 100644
index 0000000..72bd5fc
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/overflow-controller.ts
@@ -0,0 +1,146 @@
+import type { ReactiveController, ReactiveElement } from 'lit';
+
+import { isElementInView } from '@patternfly/pfe-core/functions/isElementInView.js';
+
+export interface Options {
+  /**
+   * Force hide the scroll buttons regardless of overflow
+   */
+  hideOverflowButtons?: boolean;
+  /**
+   * Delay in ms to wait before checking for overflow
+   */
+  scrollTimeoutDelay?: number;
+}
+
+export class OverflowController implements ReactiveController {
+  static #instances = new Set<OverflowController>();
+
+  static {
+    // on resize check for overflows to add or remove scroll buttons
+    globalThis.addEventListener?.('resize', () => {
+      for (const instance of this.#instances) {
+        instance.onScroll();
+      }
+    }, { capture: false, passive: true });
+  }
+
+  /** Overflow container */
+  #container?: HTMLElement;
+  /** Children that can overflow */
+  #items: HTMLElement[] = [];
+
+  #scrollTimeoutDelay: number;
+  #scrollTimeout?: ReturnType<typeof setTimeout>;
+
+  /** Default state */
+  #hideOverflowButtons: boolean;
+
+  #mo = new MutationObserver(mutations => {
+    for (const mutation of mutations) {
+      if (mutation.type === 'childList') {
+        this.#setOverflowState();
+      }
+    }
+  });
+
+  #ro = new ResizeObserver(() => {
+    requestAnimationFrame(() => {
+      this.#setOverflowState();
+    });
+  });
+
+  showScrollButtons = false;
+  overflowLeft = false;
+  overflowRight = false;
+
+  get firstItem(): HTMLElement | undefined {
+    return this.#items.at(0);
+  }
+
+  get lastItem(): HTMLElement | undefined {
+    return this.#items.at(-1);
+  }
+
+  constructor(
+    // TODO: widen this type to ReactiveControllerHost
+    public host: ReactiveElement,
+    private options?: Options | undefined,
+  ) {
+    this.#hideOverflowButtons = options?.hideOverflowButtons ?? false;
+    this.#scrollTimeoutDelay = options?.scrollTimeoutDelay ?? 0;
+    if (host.isConnected) {
+      OverflowController.#instances.add(this);
+    }
+    host.addController(this);
+    if (host.isConnected) {
+      this.hostConnected();
+    }
+  }
+
+  #setOverflowState(): void {
+    if (!this.firstItem || !this.lastItem || !this.#container) {
+      return;
+    }
+    const prevLeft = this.overflowLeft;
+    const prevRight = this.overflowRight;
+
+    this.overflowLeft = !this.#hideOverflowButtons
+      && !isElementInView(this.#container, this.firstItem);
+    this.overflowRight = !this.#hideOverflowButtons
+      && !isElementInView(this.#container, this.lastItem);
+    let scrollButtonsWidth = 0;
+    if (this.overflowLeft || this.overflowRight) {
+      scrollButtonsWidth =
+        (this.#container.parentElement?.querySelector('button')?.getBoundingClientRect().width || 0)
+      * 2;
+    }
+    this.showScrollButtons = !this.#hideOverflowButtons
+    && this.#container.scrollWidth > (this.#container.clientWidth + scrollButtonsWidth);
+
+    // only request update if there has been a change
+    if ((prevLeft !== this.overflowLeft) || (prevRight !== this.overflowRight)) {
+      this.host.requestUpdate();
+    }
+  }
+
+  init(container: HTMLElement, items: HTMLElement[]): void {
+    this.#container = container;
+    // convert HTMLCollection to HTMLElement[]
+    this.#items = items;
+  }
+
+  onScroll = (): void => {
+    clearTimeout(this.#scrollTimeout);
+    this.#scrollTimeout = setTimeout(() => this.#setOverflowState(), this.#scrollTimeoutDelay);
+  };
+
+  scrollLeft(): void {
+    if (!this.#container) {
+      return;
+    }
+    const leftScroll = this.#container.scrollLeft - this.#container.clientWidth;
+    this.#container.scroll({ left: leftScroll, behavior: 'smooth' });
+    this.#setOverflowState();
+  }
+
+  scrollRight(): void {
+    if (!this.#container) {
+      return;
+    }
+    const leftScroll = this.#container.scrollLeft + this.#container.clientWidth;
+    this.#container.scroll({ left: leftScroll, behavior: 'smooth' });
+    this.#setOverflowState();
+  }
+
+  update(): void {
+    this.#setOverflowState();
+  }
+
+  hostConnected(): void {
+    this.#mo.observe(this.host, { attributes: false, childList: true, subtree: true });
+    this.#ro.observe(this.host);
+    this.onScroll();
+    this.#setOverflowState();
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/perf-controller.ts b/node_modules/@patternfly/pfe-core/controllers/perf-controller.ts
new file mode 100644
index 0000000..f5e8660
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/perf-controller.ts
@@ -0,0 +1,50 @@
+import type { ReactiveController, ReactiveElement } from 'lit';
+
+import { getRandomId } from '../functions/random.js';
+
+export class PerfController implements ReactiveController {
+  hasMeasured = false;
+
+  markId: string;
+
+  constructor(private host: ReactiveElement) {
+    host.addController(this);
+
+    // Set up the mark ID based on existing ID on component if it exists
+    if (!host.id) {
+      this.markId = getRandomId(host.localName);
+    } else if (host.id.startsWith('pf-') && !host.id.startsWith(host.localName)) {
+      this.markId = host.id.replace('pf', host.localName);
+    } else {
+      this.markId = `${host.localName}-${host.id}`;
+    }
+
+    performance.mark(`${this.markId}-defined`);
+  }
+
+  hostUpdate(): void {
+    if (!this.hasMeasured) {
+      this.measure();
+    }
+  }
+
+  measure(): void {
+    this.hasMeasured = true;
+
+    performance.mark(`${this.markId}-rendered`);
+
+    // Navigation start, i.e., the browser first sees that the user has navigated to the page
+    performance.measure(`${this.markId}-from-navigation-to-first-render`, undefined, `${this.markId}-rendered`);
+
+    // Render is run before connection unless delayRender is used
+    performance.measure(
+      `${this.markId}-from-defined-to-first-render`,
+      `${this.markId}-defined`,
+      `${this.markId}-rendered`
+    );
+
+    // Once we've measured time to render, we no longer need the controller,
+    // so we allow it to be garbage-collected
+    this.host.removeController(this);
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/property-observer-controller.ts b/node_modules/@patternfly/pfe-core/controllers/property-observer-controller.ts
new file mode 100644
index 0000000..1b9234b
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/property-observer-controller.ts
@@ -0,0 +1,91 @@
+import type { ReactiveController, ReactiveElement } from 'lit';
+
+import { notEqual } from 'lit';
+
+export type ChangeCallback<T extends ReactiveElement, V = T[keyof T]> = (
+  this: T,
+  old?: V,
+  newV?: V,
+) => void;
+
+export interface PropertyObserverOptions<T extends ReactiveElement> {
+  propertyName: string & keyof T;
+  callback: ChangeCallback<T>;
+  waitFor?: 'connected' | 'updated' | 'firstUpdated';
+}
+
+const UNINITIALIZED = Symbol('uninitialized');
+
+export class PropertyObserverController<
+  T extends ReactiveElement
+> implements ReactiveController {
+  private oldVal: T[keyof T] = UNINITIALIZED as T[keyof T];
+
+  constructor(
+    private host: T,
+    private options: PropertyObserverOptions<T>
+  ) {
+  }
+
+  #neverRan = true;
+
+  hostConnected(): void {
+    this.#init();
+  }
+
+  /**
+   * Because of how typescript transpiles private fields,
+   * the __accessPrivate helper might not be entirely initialized
+   * by the time this constructor runs (in `addInitializer`'s instance callback')
+   * Therefore, we pull this shtick.
+   *
+   * When browser support improves to the point we can ship decorated private fields,
+   * we'll be able to get rid of this.
+   */
+  #init() {
+    if (this.oldVal === UNINITIALIZED) {
+      this.oldVal = this.host[this.options.propertyName];
+    }
+  }
+
+  /** Set any cached valued accumulated between constructor and connectedCallback */
+  async hostUpdate(): Promise<void> {
+    this.#init();
+    const { oldVal, options: { waitFor, propertyName, callback } } = this;
+    if (!callback) {
+      throw new Error(`no callback for ${propertyName}`);
+    }
+    const newVal = this.host[propertyName];
+    this.oldVal = newVal;
+    if (newVal !== oldVal) {
+      switch (waitFor) {
+        case 'connected':
+          if (!this.host.isConnected) {
+            const origConnected = this.host.connectedCallback;
+            await new Promise<void>(resolve => {
+              this.host.connectedCallback = function() {
+                resolve(origConnected?.call(this));
+              };
+            });
+          }
+          break;
+        case 'firstUpdated':
+          if (!this.host.hasUpdated) {
+            await this.host.updateComplete;
+          }
+          break;
+        case 'updated':
+          await this.host.updateComplete;
+          break;
+      }
+    }
+    const Class = (this.host.constructor as typeof ReactiveElement);
+    const hasChanged = Class
+        .getPropertyOptions(this.options.propertyName)
+        .hasChanged ?? notEqual;
+    if (this.#neverRan || hasChanged(oldVal, newVal)) {
+      callback.call(this.host, oldVal as T[keyof T], newVal);
+      this.#neverRan = false;
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
index f0bd33c..8e08a78 100644
--- a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js
@@ -59,6 +59,21 @@ export class RovingTabindexController extends ATFocusController {
         if (!isServer) {
             if (container instanceof HTMLElement) {
                 container.addEventListener('focusin', () => __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, true, "f"), { once: true });
+                // Sync atFocusedItemIndex when an item receives DOM focus (e.g., via mouse click)
+                // This ensures keyboard navigation starts from the correct position
+                container.addEventListener('focusin', (event) => {
+                    const target = event.target;
+                    const index = this.items.indexOf(target);
+                    // Only update if the target is a valid item and index differs
+                    if (index >= 0 && index !== this.atFocusedItemIndex) {
+                        // Update index via setter, but avoid the focus() call by temporarily
+                        // clearing #gainedInitialFocus to prevent redundant focus
+                        const hadInitialFocus = __classPrivateFieldGet(this, _RovingTabindexController_gainedInitialFocus, "f");
+                        __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, false, "f");
+                        this.atFocusedItemIndex = index;
+                        __classPrivateFieldSet(this, _RovingTabindexController_gainedInitialFocus, hadInitialFocus, "f");
+                    }
+                });
             }
             else {
                 __classPrivateFieldGet(this, _RovingTabindexController_logger, "f").warn('RovingTabindexController requires a getItemsContainer function');
diff --git a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js.map
index 6129899..1e69953 100644
--- a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"roving-tabindex-controller.js","sourceRoot":"","sources":["roving-tabindex-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveControllerHost } from 'lit';\nimport { ATFocusController, type ATFocusControllerOptions } from './at-focus-controller.js';\nimport { Logger } from './logger.js';\nimport { bound } from '../decorators/bound.js';\n\nexport type RovingTabindexControllerOptions<Item extends HTMLElement> =\n  ATFocusControllerOptions<Item>;\n\n/**\n * Implements roving tabindex, as described in WAI-ARIA practices, [Managing Focus Within\n * Components Using a Roving tabindex][rti]\n *\n * [rti]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex\n */\nexport class RovingTabindexController<\n  Item extends HTMLElement = HTMLElement\n> extends ATFocusController<Item> {\n  static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: RovingTabindexControllerOptions<Item>,\n  ): RovingTabindexController<Item> {\n    return new RovingTabindexController(host, options);\n  }\n\n  #logger = new Logger(this.host);\n\n  #gainedInitialFocus = false;\n\n  #itemsSet = new Set<Item>();\n\n  get atFocusedItemIndex(): number {\n    return super.atFocusedItemIndex;\n  }\n\n  /**\n   * Sets the DOM Focus on the item with assistive technology focus\n   * @param item item\n   */\n  set atFocusedItemIndex(index: number) {\n    super.atFocusedItemIndex = index;\n    const item = this.items.at(this.atFocusedItemIndex);\n    for (const i of this.items) {\n      i.tabIndex = item === i ? 0 : -1;\n    }\n    if (this.#gainedInitialFocus) {\n      item?.focus();\n    }\n    this.host.requestUpdate();\n  }\n\n  get items() {\n    return this._items;\n  }\n\n  public set items(items: Item[]) {\n    this._items = items;\n    this.#itemsSet = new Set(items);\n    const pivot = Math.max(0, this.atFocusedItemIndex);\n    const [firstFocusable] = this.atFocusableItems;\n    const firstFocusableIndex = firstFocusable ? items.indexOf(firstFocusable) : -1;\n    const pivotFocusableIndex = items.indexOf(this.items\n        .slice(pivot)\n        .concat(this.items.slice(0, pivot))\n        .find(item => this.atFocusableItems.includes(item))!);\n    this.atFocusedItemIndex = Math.max(firstFocusableIndex, pivotFocusableIndex);\n    this.host.requestUpdate();\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    options: RovingTabindexControllerOptions<Item>,\n  ) {\n    super(host, options);\n    this.initItems();\n    const container = options.getItemsContainer?.() ?? this.host;\n    if (!isServer) {\n      if (container instanceof HTMLElement) {\n        container.addEventListener('focusin', () =>\n          this.#gainedInitialFocus = true, { once: true });\n      } else {\n        this.#logger.warn('RovingTabindexController requires a getItemsContainer function');\n      }\n    }\n  }\n\n  @bound\n  protected override onKeydown(event: KeyboardEvent): void {\n    if (!event.ctrlKey\n        && !event.altKey\n        && !event.metaKey\n        && !!this.atFocusableItems.length\n        && !!event.composedPath().some(node => this.#itemsSet.has(node as Item))) {\n      super.onKeydown(event);\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"roving-tabindex-controller.js","sourceRoot":"","sources":["roving-tabindex-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveControllerHost } from 'lit';\nimport { ATFocusController, type ATFocusControllerOptions } from './at-focus-controller.js';\nimport { Logger } from './logger.js';\nimport { bound } from '../decorators/bound.js';\n\nexport type RovingTabindexControllerOptions<Item extends HTMLElement> =\n  ATFocusControllerOptions<Item>;\n\n/**\n * Implements roving tabindex, as described in WAI-ARIA practices, [Managing Focus Within\n * Components Using a Roving tabindex][rti]\n *\n * [rti]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex\n */\nexport class RovingTabindexController<\n  Item extends HTMLElement = HTMLElement\n> extends ATFocusController<Item> {\n  static of<Item extends HTMLElement>(\n    host: ReactiveControllerHost,\n    options: RovingTabindexControllerOptions<Item>,\n  ): RovingTabindexController<Item> {\n    return new RovingTabindexController(host, options);\n  }\n\n  #logger = new Logger(this.host);\n\n  #gainedInitialFocus = false;\n\n  #itemsSet = new Set<Item>();\n\n  get atFocusedItemIndex(): number {\n    return super.atFocusedItemIndex;\n  }\n\n  /**\n   * Sets the DOM Focus on the item with assistive technology focus\n   * @param item item\n   */\n  set atFocusedItemIndex(index: number) {\n    super.atFocusedItemIndex = index;\n    const item = this.items.at(this.atFocusedItemIndex);\n    for (const i of this.items) {\n      i.tabIndex = item === i ? 0 : -1;\n    }\n    if (this.#gainedInitialFocus) {\n      item?.focus();\n    }\n    this.host.requestUpdate();\n  }\n\n  get items() {\n    return this._items;\n  }\n\n  public set items(items: Item[]) {\n    this._items = items;\n    this.#itemsSet = new Set(items);\n    const pivot = Math.max(0, this.atFocusedItemIndex);\n    const [firstFocusable] = this.atFocusableItems;\n    const firstFocusableIndex = firstFocusable ? items.indexOf(firstFocusable) : -1;\n    const pivotFocusableIndex = items.indexOf(this.items\n        .slice(pivot)\n        .concat(this.items.slice(0, pivot))\n        .find(item => this.atFocusableItems.includes(item))!);\n    this.atFocusedItemIndex = Math.max(firstFocusableIndex, pivotFocusableIndex);\n    this.host.requestUpdate();\n  }\n\n  private constructor(\n    public host: ReactiveControllerHost,\n    options: RovingTabindexControllerOptions<Item>,\n  ) {\n    super(host, options);\n    this.initItems();\n    const container = options.getItemsContainer?.() ?? this.host;\n    if (!isServer) {\n      if (container instanceof HTMLElement) {\n        container.addEventListener('focusin', () =>\n          this.#gainedInitialFocus = true, { once: true });\n        // Sync atFocusedItemIndex when an item receives DOM focus (e.g., via mouse click)\n        // This ensures keyboard navigation starts from the correct position\n        container.addEventListener('focusin', (event: FocusEvent) => {\n          const target = event.target as Item;\n          const index = this.items.indexOf(target);\n          // Only update if the target is a valid item and index differs\n          if (index >= 0 && index !== this.atFocusedItemIndex) {\n            // Update index via setter, but avoid the focus() call by temporarily\n            // clearing #gainedInitialFocus to prevent redundant focus\n            const hadInitialFocus = this.#gainedInitialFocus;\n            this.#gainedInitialFocus = false;\n            this.atFocusedItemIndex = index;\n            this.#gainedInitialFocus = hadInitialFocus;\n          }\n        });\n      } else {\n        this.#logger.warn('RovingTabindexController requires a getItemsContainer function');\n      }\n    }\n  }\n\n  @bound\n  protected override onKeydown(event: KeyboardEvent): void {\n    if (!event.ctrlKey\n        && !event.altKey\n        && !event.metaKey\n        && !!this.atFocusableItems.length\n        && !!event.composedPath().some(node => this.#itemsSet.has(node as Item))) {\n      super.onKeydown(event);\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.ts b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.ts
new file mode 100644
index 0000000..6189ac6
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/roving-tabindex-controller.ts
@@ -0,0 +1,111 @@
+import { isServer, type ReactiveControllerHost } from 'lit';
+import { ATFocusController, type ATFocusControllerOptions } from './at-focus-controller.js';
+import { Logger } from './logger.js';
+import { bound } from '../decorators/bound.js';
+
+export type RovingTabindexControllerOptions<Item extends HTMLElement> =
+  ATFocusControllerOptions<Item>;
+
+/**
+ * Implements roving tabindex, as described in WAI-ARIA practices, [Managing Focus Within
+ * Components Using a Roving tabindex][rti]
+ *
+ * [rti]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex
+ */
+export class RovingTabindexController<
+  Item extends HTMLElement = HTMLElement
+> extends ATFocusController<Item> {
+  static of<Item extends HTMLElement>(
+    host: ReactiveControllerHost,
+    options: RovingTabindexControllerOptions<Item>,
+  ): RovingTabindexController<Item> {
+    return new RovingTabindexController(host, options);
+  }
+
+  #logger = new Logger(this.host);
+
+  #gainedInitialFocus = false;
+
+  #itemsSet = new Set<Item>();
+
+  get atFocusedItemIndex(): number {
+    return super.atFocusedItemIndex;
+  }
+
+  /**
+   * Sets the DOM Focus on the item with assistive technology focus
+   * @param item item
+   */
+  set atFocusedItemIndex(index: number) {
+    super.atFocusedItemIndex = index;
+    const item = this.items.at(this.atFocusedItemIndex);
+    for (const i of this.items) {
+      i.tabIndex = item === i ? 0 : -1;
+    }
+    if (this.#gainedInitialFocus) {
+      item?.focus();
+    }
+    this.host.requestUpdate();
+  }
+
+  get items() {
+    return this._items;
+  }
+
+  public set items(items: Item[]) {
+    this._items = items;
+    this.#itemsSet = new Set(items);
+    const pivot = Math.max(0, this.atFocusedItemIndex);
+    const [firstFocusable] = this.atFocusableItems;
+    const firstFocusableIndex = firstFocusable ? items.indexOf(firstFocusable) : -1;
+    const pivotFocusableIndex = items.indexOf(this.items
+        .slice(pivot)
+        .concat(this.items.slice(0, pivot))
+        .find(item => this.atFocusableItems.includes(item))!);
+    this.atFocusedItemIndex = Math.max(firstFocusableIndex, pivotFocusableIndex);
+    this.host.requestUpdate();
+  }
+
+  private constructor(
+    public host: ReactiveControllerHost,
+    options: RovingTabindexControllerOptions<Item>,
+  ) {
+    super(host, options);
+    this.initItems();
+    const container = options.getItemsContainer?.() ?? this.host;
+    if (!isServer) {
+      if (container instanceof HTMLElement) {
+        container.addEventListener('focusin', () =>
+          this.#gainedInitialFocus = true, { once: true });
+        // Sync atFocusedItemIndex when an item receives DOM focus (e.g., via mouse click)
+        // This ensures keyboard navigation starts from the correct position
+        container.addEventListener('focusin', (event: FocusEvent) => {
+          const target = event.target as Item;
+          const index = this.items.indexOf(target);
+          // Only update if the target is a valid item and index differs
+          if (index >= 0 && index !== this.atFocusedItemIndex) {
+            // Update index via setter, but avoid the focus() call by temporarily
+            // clearing #gainedInitialFocus to prevent redundant focus
+            const hadInitialFocus = this.#gainedInitialFocus;
+            this.#gainedInitialFocus = false;
+            this.atFocusedItemIndex = index;
+            this.#gainedInitialFocus = hadInitialFocus;
+          }
+        });
+      } else {
+        this.#logger.warn('RovingTabindexController requires a getItemsContainer function');
+      }
+    }
+  }
+
+  @bound
+  protected override onKeydown(event: KeyboardEvent): void {
+    if (!event.ctrlKey
+        && !event.altKey
+        && !event.metaKey
+        && !!this.atFocusableItems.length
+        && !!event.composedPath().some(node => this.#itemsSet.has(node as Item))) {
+      super.onKeydown(event);
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.ts b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.ts
new file mode 100644
index 0000000..5edd597
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.ts
@@ -0,0 +1,257 @@
+import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';
+
+export interface ScrollSpyControllerOptions extends IntersectionObserverInit {
+  /**
+   * Tag names of legal link children.
+   * Legal children must have an `href` property/attribute pair, like `<a>`.
+   */
+  tagNames: string[];
+
+  /**
+   * Attribute to set on the active link element.
+   * @default 'active'
+   */
+  activeAttribute?: string;
+
+  /**
+   * The root node to query content for
+   * @default the host's root node
+   */
+  rootNode?: Node;
+
+  /**
+   * function to call on link children to get their URL hash (i.e. id to scroll to)
+   * @default el => el.getAttribute('href');
+   */
+  getHash?: (el: Element) => string | null;
+
+  /**
+   * Optional callback for when an intersection occurs
+   */
+  onIntersection?(): void;
+}
+
+export class ScrollSpyController implements ReactiveController {
+  static #instances = new Set<ScrollSpyController>;
+
+  static {
+    if (!isServer) {
+      addEventListener('scroll', () => {
+        if (Math.round(window.innerHeight + window.scrollY) >= document.body.scrollHeight) {
+          this.#instances.forEach(ssc => {
+            ssc.#setActive(ssc.#linkChildren.at(-1));
+          });
+        }
+      }, { passive: true });
+      addEventListener('hashchange', () => {
+        this.#instances.forEach(ssc => {
+          ssc.#activateHash();
+        });
+      });
+    }
+  }
+
+  #tagNames: string[];
+
+  #activeAttribute: string;
+
+  #io?: IntersectionObserver;
+
+  /** Which link's targets have already scrolled past? */
+  #passedLinks = new Set<Element>();
+
+  /** Ignore intersections? */
+  #force = false;
+
+  /** Has the intersection observer found an element? */
+  #intersected = false;
+
+  #root: ScrollSpyControllerOptions['root'];
+
+  #rootMargin?: string;
+
+  #threshold: number | number[];
+
+  #intersectingTargets = new Set<Element>();
+
+  #linkTargetMap = new Map<Element, Element | null>();
+
+  #getRootNode: () => Node | null;
+
+  #getHash: (el: Element) => string | null;
+
+  #onIntersection?: () => void;
+
+  get #linkChildren(): Element[] {
+    if (isServer) {
+      return [];
+    } else {
+      return Array.from(this.host.querySelectorAll(this.#tagNames.join(',')))
+          .filter(this.#getHash);
+    }
+  }
+
+  get root(): Element | Document | null | undefined {
+    return this.#root;
+  }
+
+  set root(v) {
+    this.#root = v;
+    this.#io?.disconnect();
+    this.#initIo();
+  }
+
+  get rootMargin(): string | undefined {
+    return this.#rootMargin;
+  }
+
+  set rootMargin(v) {
+    this.#rootMargin = v;
+    this.#io?.disconnect();
+    this.#initIo();
+  }
+
+  get threshold(): number | number[] {
+    return this.#threshold;
+  }
+
+  set threshold(v) {
+    this.#threshold = v;
+    this.#io?.disconnect();
+    this.#initIo();
+  }
+
+  constructor(
+    private host: ReactiveControllerHost & HTMLElement,
+    options: ScrollSpyControllerOptions,
+  ) {
+    host.addController(this);
+    this.#tagNames = options.tagNames;
+    this.#root = options.root;
+    this.#rootMargin = options.rootMargin;
+    this.#activeAttribute = options.activeAttribute ?? 'active';
+    this.#threshold = options.threshold ?? 0.85;
+    this.#getRootNode = () => options.rootNode ?? host.getRootNode?.() ?? null;
+    this.#getHash = options?.getHash ?? ((el: Element) => el.getAttribute('href'));
+    this.#onIntersection = options?.onIntersection;
+  }
+
+  hostConnected(): void {
+    ScrollSpyController.#instances.add(this);
+    this.#initIo();
+  }
+
+  hostDisconnected(): void {
+    ScrollSpyController.#instances.delete(this);
+    this.#io?.disconnect();
+  }
+
+  #initializing = true;
+
+  async #initIo() {
+    const rootNode = this.#getRootNode();
+    if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {
+      const { rootMargin, threshold, root } = this;
+      this.#io = new IntersectionObserver(r => this.#onIo(r), { root, rootMargin, threshold });
+      for (const link of this.#linkChildren) {
+        const id = this.#getHash(link)?.replace('#', '');
+        if (id) {
+          const target = document.getElementById(id);
+          if (target) {
+            this.#io?.observe(target);
+            this.#linkTargetMap.set(link, target);
+          }
+        }
+      }
+    }
+  }
+
+  #markPassed(link: Element, force: boolean) {
+    if (force) {
+      this.#passedLinks.add(link);
+    } else {
+      this.#passedLinks.delete(link);
+    }
+  }
+
+  #setActive(link?: EventTarget | null) {
+    for (const child of this.#linkChildren) {
+      child.toggleAttribute(this.#activeAttribute, child === link);
+    }
+  }
+
+  async #activateHash() {
+    const links = this.#linkChildren;
+    const { hash } = location;
+    if (!hash) {
+      this.setActive(links.at(0) ?? null);
+    } else {
+      await this.#nextIntersection();
+      this.setActive(links.find(x => this.#getHash(x) === hash) ?? null);
+    }
+  }
+
+  async #nextIntersection() {
+    this.#intersected = false;
+    // safeguard the loop
+    setTimeout(() => this.#intersected = false, 3000);
+    while (!this.#intersected) {
+      await new Promise(requestAnimationFrame);
+    }
+  }
+
+  async #onIo(entries: IntersectionObserverEntry[]) {
+    if (!this.#force) {
+      for (const { target, boundingClientRect, intersectionRect } of entries) {
+        const selector = `:is(${this.#tagNames.join(',')})[href="#${target.id}"]`;
+        const link = this.host.querySelector(selector);
+        if (link) {
+          this.#markPassed(link, boundingClientRect.top < intersectionRect.top);
+        }
+      }
+      const link = [...this.#passedLinks];
+      const last = link.at(-1);
+      this.#setActive(last ?? this.#linkChildren.at(0));
+    }
+    this.#intersected = true;
+    this.#intersectingTargets.clear();
+    for (const entry of entries) {
+      if (entry.isIntersecting) {
+        this.#intersectingTargets.add(entry.target);
+      }
+    }
+    if (this.#initializing) {
+      const ints = entries?.filter(x => x.isIntersecting) ?? [];
+      if (this.#intersectingTargets.size > 0) {
+        const [{ target = null } = {}] = ints;
+        const { id } = target ?? {};
+        if (id) {
+          const link = this.#linkChildren.find(link => this.#getHash(link) === `#${id}`);
+          if (link) {
+            this.#setActive(link);
+          }
+        }
+      }
+      this.#initializing = false;
+    }
+    this.#onIntersection?.();
+  }
+
+  /**
+   * Explicitly set the active item
+   * @param link usually an `<a>`
+   */
+  public async setActive(link: EventTarget | null): Promise<void> {
+    this.#force = true;
+    this.#setActive(link);
+    let sawActive = false;
+    for (const child of this.#linkChildren) {
+      this.#markPassed(child, !sawActive);
+      if (child === link) {
+        sawActive = true;
+      }
+    }
+    await this.#nextIntersection();
+    this.#force = false;
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.ts
new file mode 100644
index 0000000..40b7ea6
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.ts
@@ -0,0 +1,46 @@
+import type { ReactiveElement } from 'lit';
+import {
+  type SlotControllerArgs,
+  type SlotControllerPublicAPI,
+} from './slot-controller.js';
+
+export class SlotController implements SlotControllerPublicAPI {
+  public static default = Symbol('default slot') satisfies symbol as symbol;
+
+  /** @deprecated use `default` */
+  public static anonymous: symbol = this.default;
+
+  static attribute = 'ssr-hint-has-slotted' as const;
+
+  static anonymousAttribute = 'ssr-hint-has-slotted-default' as const;
+
+  constructor(public host: ReactiveElement, ..._: SlotControllerArgs) {
+    host.addController(this);
+  }
+
+  hostConnected?(): Promise<void>;
+
+  private fromAttribute(slots: string | null) {
+    return (slots ?? '')
+        .split(/[, ]/)
+        .map(x => x.trim());
+  }
+
+  getSlotted<T extends Element = Element>(..._: (string | null)[]): T[] {
+    return [];
+  }
+
+  hasSlotted(...names: (string | null)[]): boolean {
+    const attr = this.host.getAttribute(SlotController.attribute);
+    const anon = this.host.hasAttribute(SlotController.anonymousAttribute);
+    const hints = new Set(this.fromAttribute(attr));
+    if (!names.length) {
+      names.push(null);
+    }
+    return names.every(x => x === null ? anon : hints.has(x));
+  }
+
+  isEmpty(...names: (string | null)[]): boolean {
+    return !this.hasSlotted(...names);
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller.ts
new file mode 100644
index 0000000..85cb4d9
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.ts
@@ -0,0 +1,256 @@
+import type { ReactiveController, ReactiveElement } from 'lit';
+
+interface AnonymousSlot {
+  hasContent: boolean;
+  elements: Element[];
+  slot: HTMLSlotElement | null;
+}
+
+interface NamedSlot extends AnonymousSlot {
+  name: string;
+  initialized: true;
+}
+
+export type Slot = NamedSlot | AnonymousSlot;
+
+export type SlotName = string | null;
+
+export interface SlotsConfig {
+  slots: SlotName[];
+  /**
+   * Object mapping new slot name keys to deprecated slot name values
+   * @example `pf-modal--header` is deprecated in favour of `header`
+   * ```js
+   * new SlotController(this, {
+   *   slots: ['header'],
+   *   deprecations: {
+   *     'header': 'pf-modal--header'
+   *   }
+   * })
+   * ```
+   */
+  deprecations?: Record<string, string>;
+}
+
+export type SlotControllerArgs = [SlotsConfig] | SlotName[];
+
+export function isObjectSpread(config: SlotControllerArgs): config is [SlotsConfig] {
+  return config.length === 1 && typeof config[0] === 'object' && config[0] !== null;
+}
+
+function isContent(node: Node) {
+  switch (node.nodeType) {
+    case Node.TEXT_NODE:
+      return !!node.textContent?.trim();
+    case Node.COMMENT_NODE:
+      return false;
+    default:
+      return true;
+  }
+}
+
+export declare class SlotControllerPublicAPI implements ReactiveController {
+  static default: symbol;
+
+  public host: ReactiveElement;
+
+  constructor(host: ReactiveElement, ...args: SlotControllerArgs);
+
+  hostConnected?(): Promise<void>;
+
+  hostDisconnected?(): void;
+
+  hostUpdated?(): void;
+
+  /**
+   * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
+   * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
+   * @param slotNames slots to query
+   * @example Get header-slotted elements
+   *          ```js
+   *          this.getSlotted('header')
+   *          ```
+   * @example Get header- and footer-slotted elements
+   *          ```js
+   *          this.getSlotted('header', 'footer')
+   *          ```
+   * @example Get default-slotted elements
+   *          ```js
+   *          this.getSlotted();
+   *          ```
+   */
+  getSlotted<T extends Element = Element>(...slotNames: string[]): T[];
+
+  /**
+   * Returns a boolean statement of whether or not any of those slots exists in the light DOM.
+   * @param names The slot names to check.
+   * @example this.hasSlotted('header');
+   */
+  hasSlotted(...names: (string | null | undefined)[]): boolean;
+
+  /**
+   * Whether or not all the requested slots are empty.
+   * @param  names The slot names to query.  If no value is provided, it returns the default slot.
+   * @example this.isEmpty('header', 'footer');
+   * @example this.isEmpty();
+   * @returns
+   */
+  isEmpty(...names: (string | null | undefined)[]): boolean;
+}
+
+class SlotRecord {
+  constructor(
+    public slot: HTMLSlotElement,
+    public name: string | symbol,
+    private host: ReactiveElement,
+  ) {}
+
+  get elements() {
+    return this.slot?.assignedElements?.();
+  }
+
+  get hasContent() {
+    if (this.name === SlotController.default) {
+      return !!this.elements.length
+        || !![...this.host.childNodes]
+            .some(node => {
+              if (node instanceof Element) {
+                return !node.hasAttribute('slot');
+              } else {
+                return isContent(node);
+              }
+            });
+    } else {
+      return !!this.slot.assignedNodes()
+          .some(isContent);
+    }
+  }
+}
+
+export class SlotController implements SlotControllerPublicAPI {
+  public static default = Symbol('default slot') satisfies symbol as symbol;
+
+  /** @deprecated use `default` */
+  public static anonymous: symbol = this.default;
+
+  #slotRecords = new Map<string | typeof SlotController.default, SlotRecord>();
+
+  #slotNames: (string | symbol | null)[] = [];
+
+  #deprecations: Record<string, string> = {};
+
+  #initSlotMap = async () => {
+    const { host } = this;
+    await host.updateComplete;
+    const slotRecords = this.#slotRecords;
+    // Loop over the properties provided by the schema
+    for (let slotName of this.#slotNames.concat(Object.values(this.#deprecations))) {
+      slotName ||= SlotController.default;
+      const slot = this.#getSlotElement(slotName);
+      if (slot) {
+        slotRecords.set(slotName, new SlotRecord(slot, slotName, host));
+      }
+    }
+    host.requestUpdate();
+  };
+
+  #mo = new MutationObserver(this.#initSlotMap);
+
+  constructor(public host: ReactiveElement, ...args: SlotControllerArgs) {
+    host.addController(this);
+    this.#initialize(...args);
+    if (!this.#slotNames.length) {
+      this.#slotNames = [null];
+    }
+  }
+
+  #initialize(...config: SlotControllerArgs) {
+    if (isObjectSpread(config)) {
+      const [{ slots, deprecations }] = config;
+      this.#slotNames = slots;
+      this.#deprecations = deprecations ?? {};
+    } else if (config.length >= 1) {
+      this.#slotNames = config;
+      this.#deprecations = {};
+    }
+  }
+
+  #getSlotElement(slotId: string | symbol) {
+    const selector =
+      slotId === SlotController.default ? 'slot:not([name])' : `slot[name="${slotId as string}"]`;
+    return this.host.shadowRoot?.querySelector?.<HTMLSlotElement>(selector) ?? null;
+  }
+
+  async hostConnected(): Promise<void> {
+    this.#mo.observe(this.host, { childList: true });
+    // Map the defined slots into an object that is easier to query
+    this.#slotRecords.clear();
+    await this.host.updateComplete;
+    this.#initSlotMap();
+    // insurance for framework integrations
+    await this.host.updateComplete;
+    this.host.requestUpdate();
+  }
+
+  hostDisconnected(): void {
+    this.#mo.disconnect();
+  }
+
+  /**
+   * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
+   * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
+   * @param slotNames slots to query
+   * @example Get header-slotted elements
+   *          ```js
+   *          this.getSlotted('header')
+   *          ```
+   * @example Get header- and footer-slotted elements
+   *          ```js
+   *          this.getSlotted('header', 'footer')
+   *          ```
+   * @example Get default-slotted elements
+   *          ```js
+   *          this.getSlotted();
+   *          ```
+   */
+  public getSlotted<T extends Element = Element>(...slotNames: string[] | [null]): T[] {
+    if (!slotNames.length || slotNames.length === 1 && slotNames.at(0) === null) {
+      return (this.#slotRecords.get(SlotController.default)?.elements ?? []) as T[];
+    } else {
+      return slotNames.flatMap(slotName =>
+        this.#slotRecords.get(slotName ?? SlotController.default)?.elements ?? []) as T[];
+    }
+  }
+
+  /**
+   * Returns a boolean statement of whether or not any of those slots exists in the light DOM.
+   * @param names The slot names to check.
+   * @example this.hasSlotted('header');
+   */
+  public hasSlotted(...names: (string | null | undefined)[]): boolean {
+    const slotNames = Array.from(names, x =>
+      x == null ? SlotController.default : x);
+    if (!slotNames.length) {
+      slotNames.push(SlotController.default);
+    }
+    return slotNames.some(slotName => {
+      const slot = this.#slotRecords.get(slotName);
+      if (!slot) {
+        return false;
+      } else {
+        return slot.hasContent;
+      }
+    });
+  }
+
+  /**
+   * Whether or not all the requested slots are empty.
+   * @param  names The slot names to query.  If no value is provided, it returns the default slot.
+   * @example this.isEmpty('header', 'footer');
+   * @example this.isEmpty();
+   * @returns
+   */
+  public isEmpty(...names: (string | null | undefined)[]): boolean {
+    return !this.hasSlotted(...names);
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/style-controller.ts b/node_modules/@patternfly/pfe-core/controllers/style-controller.ts
new file mode 100644
index 0000000..ef3ca52
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/style-controller.ts
@@ -0,0 +1,61 @@
+import type {
+  ReactiveController,
+  ReactiveElement,
+  CSSResultGroup,
+  CSSResultOrNative,
+  CSSResult,
+} from 'lit';
+import { getCompatibleStyle, supportsAdoptingStyleSheets } from 'lit';
+
+declare global {
+  interface ShadowRoot {
+    adoptedStyleSheets: CSSStyleSheet[];
+  }
+}
+
+/**
+ * Controller which adds styles to it's host element.
+ * Like `static styles = []`, except a controller.
+ * Should typically only be used within other controllers.
+ */
+export class StyleController implements ReactiveController {
+  private stylesAdopted = false;
+
+  constructor(
+    private host: ReactiveElement,
+    /** These styles will be applied to the host element */
+    private styles: CSSResultGroup,
+  ) {
+    host.addController(this);
+  }
+
+  hostConnected(): void {
+    if (this.stylesAdopted || !(this.host.renderRoot instanceof ShadowRoot)) {
+      return;
+    }
+
+    const styles = [this.styles]
+        .flatMap(x => getCompatibleStyle(x as CSSResultOrNative))
+        .filter(x => !!x);
+
+    if (supportsAdoptingStyleSheets) {
+      this.host.renderRoot.adoptedStyleSheets = [
+        ...styles.map(x => x instanceof CSSStyleSheet ? x : x.styleSheet as CSSStyleSheet),
+        ...this.host.renderRoot.adoptedStyleSheets ?? [],
+      ];
+    } else {
+      styles.forEach(s => {
+        const style = document.createElement('style');
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        const nonce = (window as any)['litNonce'];
+        if (nonce !== undefined) {
+          style.setAttribute('nonce', nonce);
+        }
+        style.textContent = (s as CSSResult).cssText;
+        this.host.renderRoot.appendChild(style);
+      });
+    }
+
+    this.stylesAdopted = true;
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/tabs-aria-controller.ts b/node_modules/@patternfly/pfe-core/controllers/tabs-aria-controller.ts
new file mode 100644
index 0000000..bfd7ab6
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/tabs-aria-controller.ts
@@ -0,0 +1,130 @@
+import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';
+
+import { Logger } from '@patternfly/pfe-core/controllers/logger.js';
+
+export interface TabsAriaControllerOptions<Tab, Panel> {
+  /** Add an `isTab` predicate to ensure this tabs instance' state does not leak into parent tabs' state */
+  isTab: (node: unknown) => node is Tab;
+  isActiveTab: (tab: Tab) => boolean;
+  /** Add an `isPanel` predicate to ensure this tabs instance' state does not leak into parent tabs' state */
+  isPanel: (node: unknown) => node is Panel;
+  getHTMLElement?: () => HTMLElement;
+}
+
+export class TabsAriaController<
+  Tab extends HTMLElement = HTMLElement,
+  Panel extends HTMLElement = HTMLElement
+> implements ReactiveController {
+  #logger: Logger;
+
+  #host: ReactiveControllerHost;
+
+  #element!: HTMLElement;
+
+  #tabPanelMap = new Map<Tab, Panel>();
+
+  #options: TabsAriaControllerOptions<Tab, Panel>;
+
+  #mo = new MutationObserver(this.#onSlotchange.bind(this));
+
+  get tabs() {
+    return [...this.#tabPanelMap.keys()] as Tab[];
+  }
+
+  get activeTab(): Tab | undefined {
+    return this.tabs.find(x => this.#options.isActiveTab(x));
+  }
+
+  /**
+   * @param host controller host
+   * @param options controller options
+   * @example Usage in PfTab
+   *          ```ts
+   *          new TabsController(this, {
+   *             isTab: (x): x is PfTab => x instanceof PfTab,
+   *             isPanel: (x): x is PfTabPanel => x instanceof PfTabPanel
+   *          });
+   *          ```
+   */
+  constructor(
+    host: ReactiveControllerHost,
+    options: TabsAriaControllerOptions<Tab, Panel>,
+  ) {
+    this.#options = options;
+    this.#logger = new Logger(host);
+    (this.#host = host).addController(this);
+    if (isServer) {
+      return;
+    }
+    if (host instanceof HTMLElement) {
+      this.#element = host;
+    } else {
+      const element = options.getHTMLElement?.();
+      if (!element) {
+        throw new Error(
+          'TabsController must be instantiated with an HTMLElement or a `getHTMLElement()` option',
+        );
+      }
+      this.#element = element;
+    }
+    this.#element.addEventListener('slotchange', this.#onSlotchange);
+    if (this.#element.isConnected) {
+      this.hostConnected();
+    }
+  }
+
+  hostConnected(): void {
+    this.#mo.observe(this.#element, { attributes: false, childList: true, subtree: false });
+    this.#onSlotchange();
+  }
+
+  hostUpdated(): void {
+    for (const [tab, panel] of this.#tabPanelMap) {
+      panel.setAttribute('aria-labelledby', tab.id);
+      tab.setAttribute('aria-controls', panel.id);
+    }
+  }
+
+  hostDisconnected(): void {
+    this.#mo.disconnect();
+  }
+
+  /**
+   * zip the tabs and panels together into #tabPanelMap
+   */
+  #onSlotchange() {
+    this.#tabPanelMap.clear();
+    const tabs = [];
+    const panels = [];
+    for (const child of this.#element?.children ?? []) {
+      if (this.#options.isTab(child)) {
+        tabs.push(child);
+        child.role ??= 'tab';
+      } else if (this.#options.isPanel(child)) {
+        panels.push(child);
+        child.role ??= 'tabpanel';
+      }
+    }
+    if (tabs.length > panels.length) {
+      this.#logger.warn('Too many tabs!');
+    } else if (panels.length > tabs.length) {
+      this.#logger.warn('Too many panels!');
+    }
+    while (tabs.length) {
+      this.#tabPanelMap.set(tabs.shift()!, panels.shift()!);
+    }
+    this.#host.requestUpdate();
+  }
+
+  panelFor(tab: Tab): Panel | undefined {
+    return this.#tabPanelMap.get(tab);
+  }
+
+  tabFor(panel: Panel): Tab | undefined {
+    for (const [tab, panelToCheck] of this.#tabPanelMap) {
+      if (panel === panelToCheck) {
+        return tab;
+      }
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.d.ts b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js
new file mode 100644
index 0000000..3173035
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js
@@ -0,0 +1,214 @@
+import { __decorate } from "tslib";
+import { expect, fixture } from '@open-wc/testing';
+import { customElement } from 'lit/decorators/custom-element.js';
+import { LitElement, html } from 'lit';
+import { RovingTabindexController } from '../roving-tabindex-controller.js';
+let TestElement = class TestElement extends LitElement {
+    constructor() {
+        super(...arguments);
+        this.controller = RovingTabindexController.of(this, {
+            getItems: () => [...this.querySelectorAll('.item')],
+        });
+    }
+    render() {
+        return html `<slot></slot>`;
+    }
+};
+TestElement = __decorate([
+    customElement('x-at-focus-test')
+], TestElement);
+describe('ATFocusController', function () {
+    describe('atFocusedItemIndex', function () {
+        describe('with all items focusable', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item">0</div>
+            <div class="item">1</div>
+            <div class="item">2</div>
+            <div class="item">3</div>
+            <div class="item">4</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('initializes to first item', function () {
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+            it('sets to a valid index', function () {
+                element.controller.atFocusedItemIndex = 3;
+                expect(element.controller.atFocusedItemIndex).to.equal(3);
+            });
+            it('wraps to last item when navigating before start', function () {
+                element.controller.atFocusedItemIndex = 0;
+                element.controller.atFocusedItemIndex--;
+                const { items } = element.controller;
+                expect(items.at(element.controller.atFocusedItemIndex))
+                    .to.equal(items[4]);
+            });
+            it('wraps to first item when navigating past end', function () {
+                element.controller.atFocusedItemIndex = 4;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+        });
+        describe('with non-focusable placeholder at index 0', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">Placeholder</div>
+            <div class="item">1</div>
+            <div class="item">2</div>
+            <div class="item">3</div>
+            <div class="item">4</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('initializes to first focusable item', function () {
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+            });
+            it('wraps to last when navigating up from first focusable', function () {
+                element.controller.atFocusedItemIndex = 1;
+                element.controller.atFocusedItemIndex--;
+                expect(element.controller.atFocusedItemIndex).to.equal(4);
+            });
+            it('snaps to first focusable when set to placeholder from elsewhere', function () {
+                element.controller.atFocusedItemIndex = 3;
+                element.controller.atFocusedItemIndex = 0;
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+            });
+            it('wraps to first focusable when navigating past end', function () {
+                element.controller.atFocusedItemIndex = 4;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+            });
+        });
+        describe('with mid-list non-focusable items', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item">B</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">C</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('scans forward past non-focusable item', function () {
+                element.controller.atFocusedItemIndex = 0;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(2);
+            });
+            it('scans backward past non-focusable item', function () {
+                element.controller.atFocusedItemIndex = 2;
+                element.controller.atFocusedItemIndex--;
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+            it('scans forward past second non-focusable item', function () {
+                element.controller.atFocusedItemIndex = 2;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(4);
+            });
+            it('scans backward past second non-focusable item', function () {
+                element.controller.atFocusedItemIndex = 4;
+                element.controller.atFocusedItemIndex--;
+                expect(element.controller.atFocusedItemIndex).to.equal(2);
+            });
+        });
+        describe('with consecutive non-focusable items', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">B</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('scans forward past two consecutive non-focusable items', function () {
+                element.controller.atFocusedItemIndex = 0;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(3);
+            });
+            it('scans backward past two consecutive non-focusable items', function () {
+                element.controller.atFocusedItemIndex = 3;
+                element.controller.atFocusedItemIndex--;
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+        });
+        describe('with non-focusable tail', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item">B</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('wraps to first when navigating forward into non-focusable tail', function () {
+                element.controller.atFocusedItemIndex = 1;
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+            it('wraps to last focusable when navigating backward into non-focusable head', async function () {
+                const el = await fixture(html `
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">A</div>
+            <div class="item">B</div>
+          </x-at-focus-test>
+        `);
+                el.controller.atFocusedItemIndex = 2;
+                el.controller.atFocusedItemIndex--;
+                expect(el.controller.atFocusedItemIndex).to.equal(3);
+            });
+        });
+        describe('with only one focusable item', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('stays on sole focusable item when navigating forward', function () {
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+                element.controller.atFocusedItemIndex++;
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+            });
+            it('stays on sole focusable item when navigating backward', function () {
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+                element.controller.atFocusedItemIndex--;
+                expect(element.controller.atFocusedItemIndex).to.equal(1);
+            });
+        });
+        describe('with no focusable items', function () {
+            let element;
+            beforeEach(async function () {
+                element = await fixture(html `
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+            });
+            it('stores index as-is', function () {
+                element.controller.atFocusedItemIndex = 0;
+                expect(element.controller.atFocusedItemIndex).to.equal(0);
+            });
+        });
+    });
+});
+//# sourceMappingURL=at-focus-controller.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js.map b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js.map
new file mode 100644
index 0000000..ab8d1e8
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"at-focus-controller.spec.js","sourceRoot":"","sources":["at-focus-controller.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect, fixture } from '@open-wc/testing';\nimport { customElement } from 'lit/decorators/custom-element.js';\nimport { LitElement, html } from 'lit';\n\nimport { RovingTabindexController } from '../roving-tabindex-controller.js';\n\n@customElement('x-at-focus-test')\nclass TestElement extends LitElement {\n  controller = RovingTabindexController.of(this, {\n    getItems: () => [...this.querySelectorAll<HTMLElement>('.item')],\n  });\n\n  protected override render() {\n    return html`<slot></slot>`;\n  }\n}\n\ndescribe('ATFocusController', function() {\n  describe('atFocusedItemIndex', function() {\n    describe('with all items focusable', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\">0</div>\n            <div class=\"item\">1</div>\n            <div class=\"item\">2</div>\n            <div class=\"item\">3</div>\n            <div class=\"item\">4</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('initializes to first item', function() {\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n\n      it('sets to a valid index', function() {\n        element.controller.atFocusedItemIndex = 3;\n        expect(element.controller.atFocusedItemIndex).to.equal(3);\n      });\n\n      it('wraps to last item when navigating before start', function() {\n        element.controller.atFocusedItemIndex = 0;\n        element.controller.atFocusedItemIndex--;\n        const { items } = element.controller;\n        expect(items.at(element.controller.atFocusedItemIndex))\n            .to.equal(items[4]);\n      });\n\n      it('wraps to first item when navigating past end', function() {\n        element.controller.atFocusedItemIndex = 4;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n    });\n\n    describe('with non-focusable placeholder at index 0', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\" aria-hidden=\"true\">Placeholder</div>\n            <div class=\"item\">1</div>\n            <div class=\"item\">2</div>\n            <div class=\"item\">3</div>\n            <div class=\"item\">4</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('initializes to first focusable item', function() {\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n      });\n\n      it('wraps to last when navigating up from first focusable', function() {\n        element.controller.atFocusedItemIndex = 1;\n        element.controller.atFocusedItemIndex--;\n        expect(element.controller.atFocusedItemIndex).to.equal(4);\n      });\n\n      it('snaps to first focusable when set to placeholder from elsewhere', function() {\n        element.controller.atFocusedItemIndex = 3;\n        element.controller.atFocusedItemIndex = 0;\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n      });\n\n      it('wraps to first focusable when navigating past end', function() {\n        element.controller.atFocusedItemIndex = 4;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n      });\n    });\n\n    describe('with mid-list non-focusable items', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\">A</div>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\">B</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n            <div class=\"item\">C</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('scans forward past non-focusable item', function() {\n        element.controller.atFocusedItemIndex = 0;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(2);\n      });\n\n      it('scans backward past non-focusable item', function() {\n        element.controller.atFocusedItemIndex = 2;\n        element.controller.atFocusedItemIndex--;\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n\n      it('scans forward past second non-focusable item', function() {\n        element.controller.atFocusedItemIndex = 2;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(4);\n      });\n\n      it('scans backward past second non-focusable item', function() {\n        element.controller.atFocusedItemIndex = 4;\n        element.controller.atFocusedItemIndex--;\n        expect(element.controller.atFocusedItemIndex).to.equal(2);\n      });\n    });\n\n    describe('with consecutive non-focusable items', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\">A</div>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n            <div class=\"item\">B</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('scans forward past two consecutive non-focusable items', function() {\n        element.controller.atFocusedItemIndex = 0;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(3);\n      });\n\n      it('scans backward past two consecutive non-focusable items', function() {\n        element.controller.atFocusedItemIndex = 3;\n        element.controller.atFocusedItemIndex--;\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n    });\n\n    describe('with non-focusable tail', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\">A</div>\n            <div class=\"item\">B</div>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('wraps to first when navigating forward into non-focusable tail', function() {\n        element.controller.atFocusedItemIndex = 1;\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n\n      it('wraps to last focusable when navigating backward into non-focusable head', async function() {\n        const el: TestElement = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n            <div class=\"item\">A</div>\n            <div class=\"item\">B</div>\n          </x-at-focus-test>\n        `);\n        el.controller.atFocusedItemIndex = 2;\n        el.controller.atFocusedItemIndex--;\n        expect(el.controller.atFocusedItemIndex).to.equal(3);\n      });\n    });\n\n    describe('with only one focusable item', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\">A</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('stays on sole focusable item when navigating forward', function() {\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n        element.controller.atFocusedItemIndex++;\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n      });\n\n      it('stays on sole focusable item when navigating backward', function() {\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n        element.controller.atFocusedItemIndex--;\n        expect(element.controller.atFocusedItemIndex).to.equal(1);\n      });\n    });\n\n    describe('with no focusable items', function() {\n      let element: TestElement;\n\n      beforeEach(async function() {\n        element = await fixture(html`\n          <x-at-focus-test>\n            <div class=\"item\" aria-hidden=\"true\">X</div>\n            <div class=\"item\" aria-hidden=\"true\">Y</div>\n          </x-at-focus-test>\n        `);\n      });\n\n      it('stores index as-is', function() {\n        element.controller.atFocusedItemIndex = 0;\n        expect(element.controller.atFocusedItemIndex).to.equal(0);\n      });\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.ts b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.ts
new file mode 100644
index 0000000..24292aa
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/at-focus-controller.spec.ts
@@ -0,0 +1,243 @@
+import { expect, fixture } from '@open-wc/testing';
+import { customElement } from 'lit/decorators/custom-element.js';
+import { LitElement, html } from 'lit';
+
+import { RovingTabindexController } from '../roving-tabindex-controller.js';
+
+@customElement('x-at-focus-test')
+class TestElement extends LitElement {
+  controller = RovingTabindexController.of(this, {
+    getItems: () => [...this.querySelectorAll<HTMLElement>('.item')],
+  });
+
+  protected override render() {
+    return html`<slot></slot>`;
+  }
+}
+
+describe('ATFocusController', function() {
+  describe('atFocusedItemIndex', function() {
+    describe('with all items focusable', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item">0</div>
+            <div class="item">1</div>
+            <div class="item">2</div>
+            <div class="item">3</div>
+            <div class="item">4</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('initializes to first item', function() {
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+
+      it('sets to a valid index', function() {
+        element.controller.atFocusedItemIndex = 3;
+        expect(element.controller.atFocusedItemIndex).to.equal(3);
+      });
+
+      it('wraps to last item when navigating before start', function() {
+        element.controller.atFocusedItemIndex = 0;
+        element.controller.atFocusedItemIndex--;
+        const { items } = element.controller;
+        expect(items.at(element.controller.atFocusedItemIndex))
+            .to.equal(items[4]);
+      });
+
+      it('wraps to first item when navigating past end', function() {
+        element.controller.atFocusedItemIndex = 4;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+    });
+
+    describe('with non-focusable placeholder at index 0', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">Placeholder</div>
+            <div class="item">1</div>
+            <div class="item">2</div>
+            <div class="item">3</div>
+            <div class="item">4</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('initializes to first focusable item', function() {
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+      });
+
+      it('wraps to last when navigating up from first focusable', function() {
+        element.controller.atFocusedItemIndex = 1;
+        element.controller.atFocusedItemIndex--;
+        expect(element.controller.atFocusedItemIndex).to.equal(4);
+      });
+
+      it('snaps to first focusable when set to placeholder from elsewhere', function() {
+        element.controller.atFocusedItemIndex = 3;
+        element.controller.atFocusedItemIndex = 0;
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+      });
+
+      it('wraps to first focusable when navigating past end', function() {
+        element.controller.atFocusedItemIndex = 4;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+      });
+    });
+
+    describe('with mid-list non-focusable items', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item">B</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">C</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('scans forward past non-focusable item', function() {
+        element.controller.atFocusedItemIndex = 0;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(2);
+      });
+
+      it('scans backward past non-focusable item', function() {
+        element.controller.atFocusedItemIndex = 2;
+        element.controller.atFocusedItemIndex--;
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+
+      it('scans forward past second non-focusable item', function() {
+        element.controller.atFocusedItemIndex = 2;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(4);
+      });
+
+      it('scans backward past second non-focusable item', function() {
+        element.controller.atFocusedItemIndex = 4;
+        element.controller.atFocusedItemIndex--;
+        expect(element.controller.atFocusedItemIndex).to.equal(2);
+      });
+    });
+
+    describe('with consecutive non-focusable items', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">B</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('scans forward past two consecutive non-focusable items', function() {
+        element.controller.atFocusedItemIndex = 0;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(3);
+      });
+
+      it('scans backward past two consecutive non-focusable items', function() {
+        element.controller.atFocusedItemIndex = 3;
+        element.controller.atFocusedItemIndex--;
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+    });
+
+    describe('with non-focusable tail', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item">A</div>
+            <div class="item">B</div>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('wraps to first when navigating forward into non-focusable tail', function() {
+        element.controller.atFocusedItemIndex = 1;
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+
+      it('wraps to last focusable when navigating backward into non-focusable head', async function() {
+        const el: TestElement = await fixture(html`
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+            <div class="item">A</div>
+            <div class="item">B</div>
+          </x-at-focus-test>
+        `);
+        el.controller.atFocusedItemIndex = 2;
+        el.controller.atFocusedItemIndex--;
+        expect(el.controller.atFocusedItemIndex).to.equal(3);
+      });
+    });
+
+    describe('with only one focusable item', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item">A</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('stays on sole focusable item when navigating forward', function() {
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+        element.controller.atFocusedItemIndex++;
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+      });
+
+      it('stays on sole focusable item when navigating backward', function() {
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+        element.controller.atFocusedItemIndex--;
+        expect(element.controller.atFocusedItemIndex).to.equal(1);
+      });
+    });
+
+    describe('with no focusable items', function() {
+      let element: TestElement;
+
+      beforeEach(async function() {
+        element = await fixture(html`
+          <x-at-focus-test>
+            <div class="item" aria-hidden="true">X</div>
+            <div class="item" aria-hidden="true">Y</div>
+          </x-at-focus-test>
+        `);
+      });
+
+      it('stores index as-is', function() {
+        element.controller.atFocusedItemIndex = 0;
+        expect(element.controller.atFocusedItemIndex).to.equal(0);
+      });
+    });
+  });
+});
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/combobox-controller.spec.ts b/node_modules/@patternfly/pfe-core/controllers/test/combobox-controller.spec.ts
new file mode 100644
index 0000000..1249ab1
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/combobox-controller.spec.ts
@@ -0,0 +1,312 @@
+import { expect, fixture, nextFrame } from '@open-wc/testing';
+import { sendKeys } from '@web/test-runner-commands';
+import { a11ySnapshot } from '@patternfly/pfe-tools/test/a11y-snapshot.js';
+
+import { customElement } from 'lit/decorators/custom-element.js';
+import { query } from 'lit/decorators/query.js';
+import { ReactiveElement, html, render, type PropertyValues, type TemplateResult } from 'lit';
+
+import { ComboboxController } from '../combobox-controller.js';
+
+function press(key: string) {
+  return async function() {
+    await sendKeys({ press: key });
+  };
+}
+
+abstract class TestCombobox extends ReactiveElement {
+  declare static template: TemplateResult;
+
+  static styles = new CSSStyleSheet();
+
+  static {
+    this.styles.replaceSync(/* css */`
+      option {
+        &.active {
+          outline: 1px solid black;
+        }
+        &[selected] {
+          background: lightblue;
+        }
+      }
+    `);
+  }
+
+  controller = ComboboxController.of(this, {
+    multi: false,
+    getItems: () => this.options,
+    isItem: item => item instanceof HTMLOptionElement,
+    getFallbackLabel: () => 'options',
+    getListboxElement: () => this.listbox ?? null,
+    getToggleButton: () => this.button ?? null,
+    getComboboxInput: () => this.combobox ?? null,
+    isExpanded: () => !this.listbox.hidden,
+    requestShowListbox: () => void (this.listbox.hidden = false),
+    requestHideListbox: () => void (this.listbox.hidden = true),
+    setItemActive: (item, active) => item.classList.toggle('active', active),
+    setItemSelected: (item, selected) => item.selected = selected,
+  });
+
+  @query('#listbox') listbox!: HTMLElement;
+  @query('#button') button!: HTMLButtonElement;
+  @query('#combobox') combobox!: HTMLInputElement;
+  @query('#placeholder') placeholder!: HTMLOptionElement;
+
+  /** List of options */
+  get options(): HTMLOptionElement[] {
+    return [
+      ...new Set([
+        this.placeholder,
+        ...this.querySelectorAll('option'),
+        ...this.renderRoot.querySelectorAll('option'),
+      ]),
+    ].filter(x => !!x);
+  }
+
+  get selected() {
+    return this.options.filter(x => x.selected);
+  }
+
+  get activeOption() {
+    return this.options.find(x => x.classList.contains('active'));
+  }
+
+  abstract render(): TemplateResult;
+
+  override update(changed: PropertyValues<this>) {
+    render(this.render(), this.renderRoot);
+    super.update(changed);
+    this.placeholder.inert = !!this.controller.selected.length;
+  }
+
+  connectedCallback(): void {
+    super.connectedCallback();
+    const root = this.renderRoot.getRootNode() as Document | ShadowRoot;
+    root.adoptedStyleSheets = [...root.adoptedStyleSheets ?? [], TestCombobox.styles];
+  }
+
+  static async test() {
+    let element: TestCombobox;
+
+    const updateComplete = () => element.updateComplete;
+
+    const { template } = this;
+
+    if (!template) {
+      throw new Error(`${this.constructor.name} must implement template`);
+    }
+
+    beforeEach(async function() {
+      element = await fixture<TestCombobox>(template);
+    });
+
+    describe('Tab', function() {
+      beforeEach(press('Tab'));
+      beforeEach(updateComplete);
+
+      it('focuses the combobox', async function() {
+        expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+      });
+
+      // describe('Tab', function() {
+      //   beforeEach(press('Tab'));
+      //   beforeEach(updateComplete);
+      //   beforeEach(nextFrame);
+
+      //   it('does not focus the toggle button', async function() {
+      //     expect(await a11ySnapshot()).to.not.axContainQuery({ focused: true });
+      //   });
+      // });
+
+      describe('ArrowDown', function() {
+        beforeEach(press('ArrowDown'));
+        beforeEach(updateComplete);
+
+        it('expands the listbox', async function() {
+          expect(await a11ySnapshot())
+              .to.axContainRole('listbox')
+              .and
+              .to.axContainQuery({ role: 'combobox', expanded: true });
+        });
+
+        it('maintains DOM focus on the combobox', async function() {
+          expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+        });
+
+        it('sets active state on the placeholder', function() {
+          expect(element.activeOption).to.equal(element.placeholder);
+        });
+
+        describe('Enter', function() {
+          beforeEach(press('Enter'));
+          beforeEach(updateComplete);
+
+          it('maintains DOM focus on the combobox', async function() {
+            expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+          });
+
+          it('selects nothing', function() {
+            expect(element.selected).to.have.length(0);
+          });
+        });
+
+        describe('ArrowDown', function() {
+          beforeEach(press('ArrowDown'));
+          beforeEach(updateComplete);
+
+          it('maintains DOM focus on the combobox', async function() {
+            expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+          });
+
+          it('sets active state on the 1st option', function() {
+            expect(element.activeOption).to.have.text('1');
+          });
+
+          describe('Enter', function() {
+            beforeEach(press('Enter'));
+            beforeEach(updateComplete);
+
+            it('maintains DOM focus on the combobox', async function() {
+              expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+            });
+
+            it('selects the first option', function() {
+              expect(element.selected).to.have.length(1);
+              expect(element.selected.at(0)).to.have.text('1');
+            });
+
+            it('collapses the listbox', async function() {
+              expect(await a11ySnapshot())
+                  .to.not.axContainRole('listbox')
+                  .and
+                  .to.axContainQuery({ role: 'combobox', expanded: false });
+            });
+          });
+        });
+
+        describe('Escape', function() {
+          beforeEach(press('Escape'));
+          beforeEach(updateComplete);
+
+          it('collapses the listbox', async function() {
+            expect(await a11ySnapshot())
+                .to.not.axContainRole('listbox')
+                .and
+                .to.axContainQuery({ role: 'combobox', expanded: false });
+          });
+
+          it('maintains DOM focus on the combobox', async function() {
+            expect(await a11ySnapshot()).axTreeFocusedNode.to.have.axRole('combobox');
+          });
+        });
+      });
+    });
+  };
+}
+
+@customElement('x-combobox-cross-root')
+class XComboboxCrossRoot extends TestCombobox {
+  static template = html`
+    <x-combobox-cross-root>
+      <option>1</option>
+      <option>2</option>
+      <option>3</option>
+      <option>4</option>
+      <option>5</option>
+      <option>6</option>
+      <option>7</option>
+      <option>8</option>
+      <option>9</option>
+      <option>10</option>
+    </x-combobox-cross-root>
+  `;
+
+
+  /** List of options */
+  override get options(): HTMLOptionElement[] {
+    return [
+      ...new Set([
+        this.placeholder,
+        ...this.querySelectorAll('option'),
+      ]),
+    ].filter(x => !!x);
+  }
+
+  render() {
+    return html`
+      <div id="toggle">
+        <input id="combobox">
+        <button id="button">Show Options</button>
+      </div>
+      <div id="listbox">
+        <option id="placeholder" aria-disabled="true">Select an Option</option>
+        ${this.controller.renderItemsToShadowRoot()}
+        <div ?hidden=${!ComboboxController.supportsCrossRootActiveDescendant}>
+          <slot></slot>
+        </div>
+      </div>
+    `;
+  }
+}
+
+@customElement('x-combobox-light')
+class XComboboxLight extends TestCombobox {
+  static template = html`
+    <x-combobox-light></x-combobox-light>
+  `;
+
+  protected createRenderRoot(): HTMLElement | DocumentFragment {
+    return this;
+  }
+
+  render() {
+    return html`
+      <input id="combobox">
+      <button id="button">Show Options</button>
+      <div id="listbox">
+        <option id="placeholder" aria-disabled="true">Select an Option</option>
+        <option>1</option>
+        <option>2</option>
+        <option>3</option>
+        <option>4</option>
+        <option>5</option>
+        <option>6</option>
+        <option>7</option>
+        <option>8</option>
+        <option>9</option>
+        <option>10</option>
+      </div>`;
+  }
+}
+
+@customElement('x-combobox-shadow')
+class XComboboxShadow extends TestCombobox {
+  static template = html`
+    <x-combobox-shadow></x-combobox-shadow>
+  `;
+
+  render() {
+    return html`
+      <input id="combobox">
+      <button id="button">Show Options</button>
+      <div id="listbox">
+        <option id="placeholder" aria-disabled="true">Select an Option</option>
+        <option>1</option>
+        <option>2</option>
+        <option>3</option>
+        <option>4</option>
+        <option>5</option>
+        <option>6</option>
+        <option>7</option>
+        <option>8</option>
+        <option>9</option>
+        <option>10</option>
+      </div>`;
+  }
+}
+
+describe('ComboboxController', function() {
+  describe('Cross-root ARIA', XComboboxCrossRoot.test.bind(XComboboxCrossRoot));
+  describe('Light-DOM only', XComboboxLight.test.bind(XComboboxLight));
+  describe('Shadow-DOM only', XComboboxShadow.test.bind(XComboboxShadow));
+});
diff --git a/node_modules/@patternfly/pfe-core/controllers/test/slot-controller.spec.ts b/node_modules/@patternfly/pfe-core/controllers/test/slot-controller.spec.ts
new file mode 100644
index 0000000..4e7f6b6
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/test/slot-controller.spec.ts
@@ -0,0 +1,353 @@
+import { expect, fixture } from '@open-wc/testing';
+
+import { customElement } from 'lit/decorators/custom-element.js';
+import { LitElement, html, type TemplateResult } from 'lit';
+
+import { SlotController } from '../slot-controller.js';
+import { SlotController as SlotControllerServer } from '../slot-controller-server.js';
+
+@customElement('test-slot-controller')
+class TestSlotController extends LitElement {
+  controller = new SlotController(this, 'a', null);
+  render(): TemplateResult {
+    return html`
+      <slot name="a"></slot>
+      <slot></slot>
+    `;
+  }
+}
+
+@customElement('test-slot-controller-server')
+class TestSlotControllerServer extends LitElement {
+  controller = new SlotControllerServer(this, 'a', null);
+  render(): TemplateResult {
+    return html`
+      <slot name="a"></slot>
+      <slot></slot>
+    `;
+  }
+}
+
+describe('SlotController', function() {
+  describe('with named and anonymous slots', function() {
+    describe('with no content', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller></test-slot-controller>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with element content in default slot', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller>
+            <p>element</p>
+          </test-slot-controller>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports non-empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.true;
+        expect(element.controller.isEmpty(null)).to.be.false;
+      });
+      it('reports non-empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.true;
+        expect(element.controller.isEmpty()).to.be.false;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns lengthy list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.not.be.empty;
+      });
+      it('returns lengthy list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.not.be.empty;
+      });
+    });
+
+    describe('with element content in named slot', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller>
+            <p slot="a">element</p>
+          </test-slot-controller>
+        `);
+      });
+      it('reports non-empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.true;
+        expect(element.controller.isEmpty('a')).to.be.false;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns lengthy list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.not.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with text content in default slot', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller>
+            text
+          </test-slot-controller>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports non-empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.true;
+        expect(element.controller.isEmpty(null)).to.be.false;
+      });
+      it('reports non-empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.true;
+        expect(element.controller.isEmpty()).to.be.false;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with white space in default slot', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server>
+
+          </test-slot-controller-server>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+  });
+});
+
+describe('SlotController (server)', function() {
+  describe('with named and anonymous slots', function() {
+    describe('with no ssr hint attrs', function() {
+      let element: TestSlotControllerServer;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server></test-slot-controller-server>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with ssr-hint-has-slotted-default attr', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server ssr-hint-has-slotted-default>
+            <p>element</p>
+          </test-slot-controller-server>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports non-empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.true;
+        expect(element.controller.isEmpty(null)).to.be.false;
+      });
+      it('reports non-empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.true;
+        expect(element.controller.isEmpty()).to.be.false;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with ssr-hint-has-slotted="a" attr', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server ssr-hint-has-slotted="a">
+            <p slot="a">element</p>
+          </test-slot-controller-server>
+        `);
+      });
+      it('reports non-empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.true;
+        expect(element.controller.isEmpty('a')).to.be.false;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with ssr-hint-has-slotted-default attr (text node)', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server ssr-hint-has-slotted-default>
+            text
+          </test-slot-controller-server>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports non-empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.true;
+        expect(element.controller.isEmpty(null)).to.be.false;
+      });
+      it('reports non-empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.true;
+        expect(element.controller.isEmpty()).to.be.false;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+
+    describe('with no ssr hint attrs (white space text node)', function() {
+      let element: TestSlotController;
+      beforeEach(async function() {
+        element = await fixture(html`
+          <test-slot-controller-server>
+
+          </test-slot-controller-server>
+        `);
+      });
+      it('reports empty named slots', function() {
+        expect(element.controller.hasSlotted('a')).to.be.false;
+        expect(element.controller.isEmpty('a')).to.be.true;
+      });
+      it('reports empty default slot', function() {
+        expect(element.controller.hasSlotted(null)).to.be.false;
+        expect(element.controller.isEmpty(null)).to.be.true;
+      });
+      it('reports empty default slot with no arguments', function() {
+        expect(element.controller.hasSlotted()).to.be.false;
+        expect(element.controller.isEmpty()).to.be.true;
+      });
+      it('returns empty list for getSlotted("a")', function() {
+        expect(element.controller.getSlotted('a')).to.be.empty;
+      });
+      it('returns empty list for getSlotted(null)', function() {
+        expect(element.controller.getSlotted(null)).to.be.empty;
+      });
+      it('returns empty list for getSlotted()', function() {
+        expect(element.controller.getSlotted()).to.be.empty;
+      });
+    });
+  });
+});
diff --git a/node_modules/@patternfly/pfe-core/controllers/timestamp-controller.ts b/node_modules/@patternfly/pfe-core/controllers/timestamp-controller.ts
new file mode 100644
index 0000000..e6deb68
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/timestamp-controller.ts
@@ -0,0 +1,137 @@
+import type { ReactiveController, ReactiveControllerHost } from 'lit';
+
+export type DateTimeFormat = 'full' | 'long' | 'medium' | 'short';
+
+export interface TimestampOptions {
+  dateFormat?: DateTimeFormat;
+  timeFormat?: DateTimeFormat;
+  customFormat?: Intl.DateTimeFormatOptions;
+  displaySuffix: string;
+  locale: Intl.LocalesArgument;
+  relative: boolean;
+  utc: boolean;
+  hour12: boolean;
+}
+
+const defaults = {
+  dateFormat: undefined,
+  timeFormat: undefined,
+  customFormat: undefined,
+  displaySuffix: '',
+  locale: undefined,
+  relative: false,
+  utc: false,
+  hour12: false,
+} as const;
+
+export class TimestampController implements ReactiveController {
+  static #isTimestampOptionKey(prop: PropertyKey): prop is keyof TimestampOptions {
+    return prop in defaults;
+  }
+
+  #date = new Date();
+
+  #options: TimestampOptions = {} as TimestampOptions;
+
+  #host: ReactiveControllerHost;
+
+  get localeString(): string {
+    return this.#date.toLocaleString(this.#options.locale);
+  }
+
+  get date(): Date {
+    return this.#date;
+  }
+
+  set date(string) {
+    this.#date = new Date(string);
+  }
+
+  get isoString(): string {
+    return this.#date.toISOString();
+  }
+
+  get time(): string {
+    if (this.#options.relative) {
+      return this.#getTimeRelative();
+    } else {
+      let { displaySuffix } = this.#options;
+      const { locale } = this.#options;
+      if (this.#options.utc) {
+        displaySuffix ||= 'UTC';
+      }
+      const localeString = this.#date.toLocaleString(locale, this.#options.customFormat ?? {
+        hour12: this.#options.hour12,
+        timeStyle: this.#options.timeFormat,
+        dateStyle: this.#options.dateFormat,
+        ...this.#options.utc && { timeZone: 'UTC' },
+      });
+
+      return `${localeString} ${displaySuffix ?? ''}`.trim();
+    }
+  }
+
+  constructor(host: ReactiveControllerHost, options?: Partial<TimestampOptions>) {
+    this.#host = host;
+    host.addController(this);
+    for (const [name, value] of Object.entries(this.#options)) {
+      // @ts-expect-error: seems typescript compiler isn't up to the task here
+      this.#options[name] = options?.[name] ?? value;
+    }
+  }
+
+  hostConnected?(): void;
+
+  /**
+   * Based off of Github Relative Time
+   * https://github.com/github/time-elements/blob/master/src/relative-time.js
+   */
+  #getTimeRelative() {
+    const date = this.#date;
+    const { locale } = this.#options;
+    const rtf = new Intl.RelativeTimeFormat(locale as string, {
+      localeMatcher: 'best fit',
+      numeric: 'auto',
+      style: 'long',
+    });
+    const ms: number = date.getTime() - Date.now();
+    const tense = ms > 0 ? 1 : -1;
+    let qty = 0;
+    let units: Intl.RelativeTimeFormatUnit | undefined;
+    const s = Math.round(Math.abs(ms) / 1000);
+    const min = Math.round(s / 60);
+    const h = Math.round(min / 60);
+    const d = Math.round(h / 24);
+    const m = Math.round(d / 30);
+    const y = Math.round(m / 12);
+    if (m >= 12) {
+      qty = y;
+      units = 'year';
+    } else if (d >= 30) {
+      qty = m;
+      units = 'month';
+    } else if (h >= 24) {
+      qty = d;
+      units = 'day';
+    } else if (min >= 45) {
+      qty = h;
+      units = 'hour';
+    } else if (s >= 45) {
+      qty = min;
+      units = 'minute';
+    } else if (s >= 10) {
+      qty = s;
+      units = 'second';
+    }
+
+    return typeof (units) !== 'undefined' ? rtf.format(tense * qty, units) : 'just now';
+  }
+
+  set(prop: PropertyKey, value: unknown): void {
+    if (TimestampController.#isTimestampOptionKey(prop)) {
+      // @ts-expect-error: seems typescript compiler isn't up to the task here
+      this.#options[prop] = value;
+      this.#host.requestUpdate();
+    }
+  }
+}
diff --git a/node_modules/@patternfly/pfe-core/custom-elements.json b/node_modules/@patternfly/pfe-core/custom-elements.json
index d2da062..20da7f5 100644
--- a/node_modules/@patternfly/pfe-core/custom-elements.json
+++ b/node_modules/@patternfly/pfe-core/custom-elements.json
@@ -7,7 +7,7 @@
       "declarations": [
         {
           "name": "ActivedescendantController",
-          "description": "Implements activedescendant pattern, as described in WAI-ARIA practices,\n[Managing Focus in Composites Using aria-activedescendant][ad]\n\nThe steps for using the aria-activedescendant method of managing focus are as follows.\n\n- When the container element that has a role that supports aria-activedescendant is loaded\nor created, ensure that:\n- The container element is included in the tab sequence as described in\nKeyboard Navigation Between Components or is a focusable element of a composite\nthat implements a roving tabindex.\n- It has aria-activedescendant=\"IDREF\" where IDREF is the ID of the element within\nthe container that should be identified as active when the widget receives focus.\nThe referenced element needs to meet the DOM relationship requirements described below.\n- When the container element receives DOM focus, draw a visual focus indicator on the active\nelement and ensure the active element is scrolled into view.\n- When the composite widget contains focus and the user presses a navigation key that moves\nfocus within the widget, such as an arrow key:\n- Change the value of aria-activedescendant on the container to refer to the element\nthat should be reported to assistive technologies as active.\n- Move the visual focus indicator and, if necessary, scrolled the active element into view.\n- If the design calls for a specific element to be focused the next time a user moves focus\ninto the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to\nthat target element when the container loses focus. If it is not, set aria-activedescendant\nto refer to the target element.\n\nThe specification for aria-activedescendant places important restrictions on the\nDOM relationship between the focused element that has the aria-activedescendant attribute\nand the element referenced as active by the value of the attribute.\nOne of the following three conditions must be met.\n\n1. The element referenced as active is a DOM descendant of the focused referencing element.\n2. The focused referencing element has a value specified for the aria-owns property that\nincludes the ID of the element referenced as active.\n3. The focused referencing element has role of combobox, textbox, or searchbox\nand has aria-controls property referring to an element with a role that supports\naria-activedescendant and either:\n1. The element referenced as active is a descendant of the controlled element.\n2. The controlled element has a value specified for the aria-owns property that includes\nthe ID of the element referenced as active.\n\n[ad]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant",
+          "description": "Implements activedescendant pattern, as described in WAI-ARIA practices,\n[Managing Focus in Composites Using aria-activedescendant][ad]\n* The steps for using the aria-activedescendant method of managing focus are as follows.\n*  - When the container element that has a role that supports aria-activedescendant is loaded\nor created, ensure that:\n- The container element is included in the tab sequence as described in\nKeyboard Navigation Between Components or is a focusable element of a composite\nthat implements a roving tabindex.\n- It has aria-activedescendant=\"IDREF\" where IDREF is the ID of the element within\nthe container that should be identified as active when the widget receives focus.\nThe referenced element needs to meet the DOM relationship requirements described below.\n- When the container element receives DOM focus, draw a visual focus indicator on the active\nelement and ensure the active element is scrolled into view.\n- When the composite widget contains focus and the user presses a navigation key that moves\nfocus within the widget, such as an arrow key:\n- Change the value of aria-activedescendant on the container to refer to the element\nthat should be reported to assistive technologies as active.\n- Move the visual focus indicator and, if necessary, scrolled the active element into view.\n- If the design calls for a specific element to be focused the next time a user moves focus\ninto the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to\nthat target element when the container loses focus. If it is not, set aria-activedescendant\nto refer to the target element.\n* The specification for aria-activedescendant places important restrictions on the\nDOM relationship between the focused element that has the aria-activedescendant attribute\nand the element referenced as active by the value of the attribute.\nOne of the following three conditions must be met.\n* 1. The element referenced as active is a DOM descendant of the focused referencing element.\n2. The focused referencing element has a value specified for the aria-owns property that\nincludes the ID of the element referenced as active.\n3. The focused referencing element has role of combobox, textbox, or searchbox\nand has aria-controls property referring to an element with a role that supports\naria-activedescendant and either:\n1. The element referenced as active is a descendant of the controlled element.\n2. The controlled element has a value specified for the aria-owns property that includes\nthe ID of the element referenced as active.\n* [ad]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant",
           "superclass": {
             "name": "ATFocusController"
           },
@@ -67,21 +67,6 @@
               "description": "All items",
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "ActivedescendantControllerOptions\u003cItem\u003e"
-              },
-              "kind": "field",
-              "privacy": "protected"
-            },
             {
               "return": {
                 "type": {
@@ -130,9 +115,6 @@
               "privacy": "public"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/activedescendant-controller.ts#L76"
-          },
           "kind": "class"
         }
       ],
@@ -199,20 +181,6 @@
               "default": "new Map\u003cstring, string[]\u003e()",
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "E"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "Options\u003cE\u003e | undefined"
-              },
-              "kind": "field"
-            },
             {
               "return": {
                 "type": {
@@ -355,9 +323,6 @@
               "privacy": "private"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/cascade-controller.ts#L18"
-          },
           "kind": "class",
           "deprecated": "use context, especially via `@patternfly/pfe-core/functions/context.js`;"
         }
@@ -379,7 +344,7 @@
       "declarations": [
         {
           "name": "ComboboxController",
-          "summary": "Implements the WAI-ARIA pattern [Editable Combobox with Both List and Inline Autocomplete].\n\nCombobox with keyboard and pointer navigation, using the aria-activedescendant pattern.\n\nWARNING: Safari VoiceOver does not support aria-activedescendant, so Safari users\nrely on the combobox input value being announced when navigating the listbox with the keyboard.\nWe have erred on the side that it may be less-broken to avoid announcing disabled items in that\ncase, rather than announcing the disabled items value without indicating that it is disabled.",
+          "summary": "Implements the WAI-ARIA pattern [Editable Combobox with Both List and Inline Autocomplete].\n* Combobox with keyboard and pointer navigation, using the aria-activedescendant pattern.\n* WARNING: Safari VoiceOver does not support aria-activedescendant, so Safari users\nrely on the combobox input value being announced when navigating the listbox with the keyboard.\nWe have erred on the side that it may be less-broken to avoid announcing disabled items in that\ncase, rather than announcing the disabled items value without indicating that it is disabled.",
           "members": [
             {
               "parameters": [
@@ -430,20 +395,6 @@
               "static": true,
               "privacy": "private"
             },
-            {
-              "name": "instances",
-              "default": "new WeakMap\u003cReactiveControllerHost, ComboboxController\u003cHTMLElement\u003e\u003e()",
-              "kind": "field",
-              "static": true,
-              "privacy": "private"
-            },
-            {
-              "name": "hosts",
-              "default": "new Set\u003cReactiveControllerHost\u003e()",
-              "kind": "field",
-              "static": true,
-              "privacy": "private"
-            },
             {
               "name": "options",
               "type": {
@@ -475,13 +426,6 @@
               "description": "The current selection: a list of items",
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field"
-            },
             {
               "return": {
                 "type": {
@@ -509,24 +453,6 @@
               "name": "hostDisconnected",
               "kind": "method"
             },
-            {
-              "return": {
-                "type": {
-                  "text": "void"
-                }
-              },
-              "name": "disconnect",
-              "kind": "method"
-            },
-            {
-              "return": {
-                "type": {
-                  "text": "Promise\u003cvoid\u003e"
-                }
-              },
-              "name": "_onFocusoutElement",
-              "kind": "method"
-            },
             {
               "return": {
                 "type": {
@@ -539,9 +465,6 @@
               "privacy": "public"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/combobox-controller.ts#L158"
-          },
           "kind": "class"
         }
       ],
@@ -570,13 +493,6 @@
               },
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field"
-            },
             {
               "parameters": [
                 {
@@ -617,9 +533,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/css-variable-controller.ts#L3"
-          },
           "kind": "class"
         }
       ],
@@ -680,21 +593,13 @@
             },
             {
               "name": "styles",
-              "description": "Styles to apply to your element's container\n\n- `--_floating-content-translate`: translate to apply to floating content.",
+              "description": "Styles to apply to your element's container\n* - `--_floating-content-translate`: translate to apply to floating content.",
               "type": {
                 "text": "StyleInfo"
               },
               "readonly": true,
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -725,9 +630,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/floating-dom-controller.ts#L29"
-          },
           "kind": "class"
         }
       ],
@@ -748,6 +650,7 @@
       "declarations": [
         {
           "name": "InternalsController",
+          "description": "reactively forward the internals object's aria mixin prototype",
           "members": [
             {
               "name": "instances",
@@ -1338,21 +1241,6 @@
               "kind": "field",
               "privacy": "private"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "InternalsControllerOptions"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "name": "attachOrRetrieveInternals",
               "description": "Typescript (with experimental decorators) will compile the class\nsuch that the order of operations is:\n1. set up constructor parameter fields\n2. run decorated field setters with initializers as the value\n3. run the rest of the constructor\nBecause of that, `this.internals` may not be available in the decorator setter\nso we cheat here with nullish coalescing assignment operator `??=`;",
@@ -1463,9 +1351,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/internals-controller.ts#L71"
-          },
           "kind": "class"
         }
       ],
@@ -1511,22 +1396,6 @@
               "kind": "field",
               "privacy": "private"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "Options | undefined"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -1561,9 +1430,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/light-dom-controller.ts#L10"
-          },
           "kind": "class"
         }
       ],
@@ -1593,10 +1459,7 @@
             }
           ],
           "name": "isItem",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/listbox-controller.ts#L81"
-          }
+          "kind": "function"
         },
         {
           "parameters": [
@@ -1610,14 +1473,11 @@
           ],
           "name": "isItemDisabled",
           "description": "This is a fib. aria-disabled might not be present on an element that uses internals,\nand the `disabled` attribute may not accurately represent the disabled state.\nshort of patching the `attachInternals` constructor, it may not be possible at\nruntime to know with certainty that an arbitrary custom element is disabled or not.",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/listbox-controller.ts#L96"
-          }
+          "kind": "function"
         },
         {
           "name": "ListboxController",
-          "description": "Implements listbox semantics and accesibility. As there are two recognized\npatterns for implementing keyboard interactions with listbox patterns,\nprovide a secondary controller (either RovingTabindexController or\nActiveDescendantController) to complete the implementation.",
+          "description": "Options for listbox controller",
           "members": [
             {
               "name": "instances",
@@ -1691,13 +1551,6 @@
               },
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field"
-            },
             {
               "return": {
                 "type": {
@@ -1753,9 +1606,6 @@
               "privacy": "public"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/listbox-controller.ts#L145"
-          },
           "kind": "class"
         }
       ],
@@ -1822,7 +1672,7 @@
                 }
               },
               "name": "debugLog",
-              "description": "A boolean value that indicates if the logging should be printed to the console; used for debugging.\nFor use in a JS file or script tag; can also be added in the constructor of a component during development.\n\nLogger.debugLog(true);",
+              "description": "A boolean value that indicates if the logging should be printed to the console; used for debugging.\nFor use in a JS file or script tag; can also be added in the constructor of a component during development.",
               "kind": "method",
               "static": true
             },
@@ -1842,7 +1692,7 @@
                 }
               },
               "name": "debug",
-              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.\n\nLogger.debug(\"Hello\");",
+              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.",
               "kind": "method",
               "static": true
             },
@@ -1862,7 +1712,7 @@
                 }
               },
               "name": "info",
-              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.\n\nLogger.info(\"Hello\");",
+              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.",
               "kind": "method",
               "static": true
             },
@@ -1882,7 +1732,7 @@
                 }
               },
               "name": "log",
-              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.\n\nLogger.log(\"Hello\");",
+              "description": "A logging wrapper which checks the debugLog boolean and prints to the console if true.",
               "kind": "method",
               "static": true
             },
@@ -1902,7 +1752,7 @@
                 }
               },
               "name": "warn",
-              "description": "A console warning wrapper which formats your output with useful debugging information.\n\nLogger.warn(\"Hello\");",
+              "description": "A console warning wrapper which formats your output with useful debugging information.",
               "kind": "method",
               "static": true
             },
@@ -1922,7 +1772,7 @@
                 }
               },
               "name": "error",
-              "description": "A console error wrapper which formats your output with useful debugging information.\nFor use inside a component's function.\n\nLogger.error(\"Hello\");",
+              "description": "A console error wrapper which formats your output with useful debugging information.\nFor use inside a component's function.",
               "kind": "method",
               "static": true
             },
@@ -1942,7 +1792,7 @@
                 }
               },
               "name": "debug",
-              "description": "Debug logging that outputs the tag name as a prefix automatically\n\nthis.logger.log(\"Hello\");",
+              "description": "Debug logging that outputs the tag name as a prefix automatically",
               "kind": "method"
             },
             {
@@ -1961,7 +1811,7 @@
                 }
               },
               "name": "info",
-              "description": "Info logging that outputs the tag name as a prefix automatically\n\nthis.logger.log(\"Hello\");",
+              "description": "Info logging that outputs the tag name as a prefix automatically",
               "kind": "method"
             },
             {
@@ -1980,7 +1830,7 @@
                 }
               },
               "name": "log",
-              "description": "Local logging that outputs the tag name as a prefix automatically\n\nthis.logger.log(\"Hello\");",
+              "description": "Local logging that outputs the tag name as a prefix automatically",
               "kind": "method"
             },
             {
@@ -1999,7 +1849,7 @@
                 }
               },
               "name": "warn",
-              "description": "Local warning wrapper that outputs the tag name as a prefix automatically.\nFor use inside a component's function.\n\nthis.logger.warn(\"Hello\");",
+              "description": "Local warning wrapper that outputs the tag name as a prefix automatically.\nFor use inside a component's function.",
               "kind": "method"
             },
             {
@@ -2018,17 +1868,9 @@
                 }
               },
               "name": "error",
-              "description": "Local error wrapper that outputs the tag name as a prefix automatically.\nFor use inside a component's function.\n\nthis.logger.error(\"Hello\");",
+              "description": "Local error wrapper that outputs the tag name as a prefix automatically.\nFor use inside a component's function.",
               "kind": "method"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -2039,9 +1881,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/logger.ts#L3"
-          },
           "kind": "class"
         }
       ],
@@ -2103,21 +1942,6 @@
               "readonly": true,
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "Options | undefined"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "parameters": [
                 {
@@ -2187,9 +2011,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/overflow-controller.ts#L16"
-          },
           "kind": "class"
         }
       ],
@@ -2226,14 +2047,6 @@
               },
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -2253,9 +2066,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/perf-controller.ts#L5"
-          },
           "kind": "class"
         }
       ],
@@ -2286,22 +2096,6 @@
               "kind": "field",
               "privacy": "private"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "T"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "PropertyObserverOptions\u003cT\u003e"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -2322,9 +2116,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/property-observer-controller.ts#L19"
-          },
           "kind": "class"
         }
       ],
@@ -2345,7 +2136,7 @@
       "declarations": [
         {
           "name": "RovingTabindexController",
-          "description": "Implements roving tabindex, as described in WAI-ARIA practices, [Managing Focus Within\nComponents Using a Roving tabindex][rti]\n\n[rti]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex",
+          "description": "Implements roving tabindex, as described in WAI-ARIA practices, [Managing Focus Within\nComponents Using a Roving tabindex][rti]\n* [rti]: https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex",
           "superclass": {
             "name": "ATFocusController"
           },
@@ -2386,13 +2177,6 @@
               "name": "items",
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost"
-              },
-              "kind": "field"
-            },
             {
               "parameters": [
                 {
@@ -2412,9 +2196,6 @@
               "privacy": "protected"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/roving-tabindex-controller.ts#L15"
-          },
           "kind": "class"
         }
       ],
@@ -2457,14 +2238,6 @@
               },
               "kind": "field"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveControllerHost \u0026 HTMLElement"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -2503,9 +2276,6 @@
               "privacy": "public"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/scroll-spy-controller.ts#L34"
-          },
           "kind": "class"
         }
       ],
@@ -2561,13 +2331,6 @@
               "kind": "field",
               "static": true
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field"
-            },
             {
               "parameters": [
                 {
@@ -2636,9 +2399,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/slot-controller-server.ts#L7"
-          },
           "kind": "class"
         }
       ],
@@ -2667,10 +2427,7 @@
             }
           ],
           "name": "isObjectSpread",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/slot-controller.ts#L37"
-          }
+          "kind": "function"
         },
         {
           "name": "SlotControllerPublicAPI",
@@ -2691,36 +2448,11 @@
               "kind": "field"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/slot-controller.ts#L52"
-          },
           "kind": "class"
         },
         {
           "name": "SlotRecord",
           "members": [
-            {
-              "name": "slot",
-              "type": {
-                "text": "HTMLSlotElement"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "name",
-              "type": {
-                "text": "string | symbol"
-              },
-              "kind": "field"
-            },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "name": "elements",
               "readonly": true,
@@ -2732,9 +2464,6 @@
               "kind": "field"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/slot-controller.ts#L101"
-          },
           "kind": "class"
         },
         {
@@ -2756,13 +2485,6 @@
               "kind": "field",
               "static": true
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field"
-            },
             {
               "return": {
                 "type": {
@@ -2797,7 +2519,7 @@
                 }
               },
               "name": "getSlotted",
-              "description": "Given a slot name or slot names, returns elements assigned to the requested slots as an array.\nIf no value is provided, it returns all children not assigned to a slot (without a slot attribute).\n\n\u003cfigure\u003e\n\u003cfigcaption\u003eGet header-slotted elements\u003c/figcaption\u003e\n\n```js\nthis.getSlotted('header')\n```\n\u003c/figure\u003e\n\n\u003cfigure\u003e\n\u003cfigcaption\u003eGet header- and footer-slotted elements\u003c/figcaption\u003e\n\n```js\nthis.getSlotted('header', 'footer')\n```\n\u003c/figure\u003e\n\n\u003cfigure\u003e\n\u003cfigcaption\u003eGet default-slotted elements\u003c/figcaption\u003e\n\n```js\nthis.getSlotted();\n```\n\u003c/figure\u003e",
+              "description": "Given a slot name or slot names, returns elements assigned to the requested slots as an array.\nIf no value is provided, it returns all children not assigned to a slot (without a slot attribute).",
               "kind": "method",
               "privacy": "public"
             },
@@ -2817,7 +2539,7 @@
                 }
               },
               "name": "hasSlotted",
-              "description": "Returns a boolean statement of whether or not any of those slots exists in the light DOM.\n\nthis.hasSlotted('header');",
+              "description": "Returns a boolean statement of whether or not any of those slots exists in the light DOM.",
               "kind": "method",
               "privacy": "public"
             },
@@ -2837,14 +2559,11 @@
                 }
               },
               "name": "isEmpty",
-              "description": "Whether or not all the requested slots are empty.\n\nthis.isEmpty('header', 'footer');\n\nthis.isEmpty();",
+              "description": "Whether or not all the requested slots are empty.",
               "kind": "method",
               "privacy": "public"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/slot-controller.ts#L130"
-          },
           "kind": "class"
         }
       ],
@@ -2884,23 +2603,6 @@
               "kind": "field",
               "privacy": "private"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "ReactiveElement"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
-            {
-              "name": "styles",
-              "description": "These styles will be applied to the host element",
-              "type": {
-                "text": "CSSResultGroup"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "return": {
                 "type": {
@@ -2911,9 +2613,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/style-controller.ts#L21"
-          },
           "kind": "class"
         }
       ],
@@ -3010,9 +2709,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/tabs-aria-controller.ts#L14"
-          },
           "kind": "class"
         }
       ],
@@ -3089,9 +2785,6 @@
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/controllers/timestamp-controller.ts#L27"
-          },
           "kind": "class"
         }
       ],
@@ -3120,11 +2813,8 @@
             }
           ],
           "name": "bound",
-          "description": "Binds a class method to the instance\n\n\u003cfigure\u003e\n\u003cfigcaption\u003eBinding an event listener\u003c/figcaption\u003e\n\n```ts\nprivate mo = new MutationObserver(this.onMutation);\n\u003c/figure\u003e",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/bound.ts#L17"
-          }
+          "description": "Binds a class method to the instance",
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3155,10 +2845,7 @@
           "name": "cascades",
           "description": "Cascades the decorated attribute to children",
           "deprecated": "use context, especially via `@patternfly/pfe-core/functions/context.js`;",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/cascades.ts#L10"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3187,14 +2874,12 @@
             }
           ],
           "name": "deprecation",
-          "description": "Aliases the decorated field to an existing property, and logs a warning if it is used\n\n\u003cfigure\u003e\n\u003cfigcaption\u003edeprecating an attribute\u003c/figcaption\u003e\n\n```ts\n\u003c/figure\u003e",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/deprecation.ts#L21"
-          }
+          "description": "Aliases the decorated field to an existing property, and logs a warning if it is used",
+          "kind": "function"
         },
         {
           "name": "Deprecation",
+          "description": "Aliases the decorated field to an existing property, and logs a warning if it is used",
           "members": [
             {
               "name": "logger",
@@ -3213,38 +2898,11 @@
               "kind": "field",
               "privacy": "private"
             },
-            {
-              "name": "host",
-              "type": {
-                "text": "T"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
-            {
-              "name": "options",
-              "type": {
-                "text": "DeprecationDeclaration\u003cK\u003e"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
-            {
-              "name": "deprecatedKey",
-              "type": {
-                "text": "string \u0026 keyof T"
-              },
-              "kind": "field",
-              "privacy": "private"
-            },
             {
               "name": "hostUpdate",
               "kind": "method"
             }
           ],
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/deprecation.ts#L38"
-          },
           "kind": "class"
         }
       ],
@@ -3275,10 +2933,7 @@
           ],
           "name": "initializer",
           "description": "Runs the decorated method in `connectedCallback`,\nprovided the element has light children, and sets\nup a mutation observer to re-run the callback,\nunless opted-out with `{ observe: false }`",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/initializer.ts#L13"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3308,10 +2963,7 @@
           ],
           "name": "listen",
           "description": "Listens for a given event on the custom element.\nequivalent to calling `this.addEventListener` in the constructor",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/listen.ts#L9"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3339,10 +2991,7 @@
             }
           ],
           "name": "observed",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/observed.ts#L34"
-          }
+          "kind": "function"
         },
         {
           "parameters": [
@@ -3354,10 +3003,7 @@
             }
           ],
           "name": "observed",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/observed.ts#L35"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3387,10 +3033,7 @@
           ],
           "name": "observes",
           "description": "Observes changes on the given property and calls the decorated method\nwith the old and new values when it changes. In cases where the decorated method\nneeds to access uninitialized class fields, You may need to wait for the element to connect\nbefore running your effects. In that case, you can optionally specify which\nlifecycle state to wait for. e.g.:\n- `waitFor: 'firstUpdate'` waits until the first update cycle has completed\n- `waitFor: 'updated'` waits until the next update cycle has completed\n- `waitFor: 'connected'` waits until the element connects",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/observes.ts#L21"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3420,10 +3063,7 @@
           ],
           "name": "time",
           "description": "Tracks the time a method takes to complete using the [performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/time.ts#L5"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3453,10 +3093,7 @@
           ],
           "name": "trace",
           "description": "Logs the result of a class method",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/decorators/trace.ts#L5"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3486,10 +3123,7 @@
           ],
           "name": "arraysAreEquivalent",
           "description": "Whether the two arrays are equivalent\nArrays are equivalent when they are both empty, or when their lengths are equal and each of\ntheir members is equal (===) to the corresponding member in the other array.\nIf either argument is not an array, the result will be strict equivalence (===)",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/arraysAreEquivalent.ts#L9"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3519,10 +3153,7 @@
           ],
           "name": "containsDeep",
           "description": "Whether or not the container contains the node,\nand if not, whether the node is contained by any element\nslotted in to the container",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/containsDeep.ts#L8"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3553,10 +3184,7 @@
           ],
           "name": "createContextWithRoot",
           "description": "In order to prevent late-upgrading-context-consumers from 'missing'\ntheir rightful context providers, we must set up a `ContextRoot` on the body.\nAlways use this function when creating contexts that are shared with child elements.",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/context.ts#L25"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3586,10 +3214,7 @@
           ],
           "name": "debounce",
           "description": "Debounce helper function",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/debounce.ts#L9"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3622,10 +3247,7 @@
           },
           "name": "isElementInView",
           "description": "This function returns whether or not an element is within the viewable area of a container. If partial is true,\nthen this function will return true even if only part of the element is in view.",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/isElementInView.ts#L10"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
@@ -3646,10 +3268,7 @@
         {
           "name": "getRandomId",
           "description": "A quick way to fetch a random ID value.\n_Note:_ All values are prefixed automatically to ensure an ID-safe value is returned.",
-          "kind": "function",
-          "source": {
-            "href": "https://github.com/patternfly/patternfly-elements/tree/main/functions/random.ts#L6"
-          }
+          "kind": "function"
         }
       ],
       "exports": [
diff --git a/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js b/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js
index f603fd6..7fd536d 100644
--- a/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js
+++ b/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js
@@ -7,7 +7,7 @@
  * @param b second array
  */
 export function arraysAreEquivalent(a, b) {
-    if (!Array.isArray(a) || !Array.isArray(b)) {
+    if (!Array.isArray(a) || !Array.isArray(b)) { // one or both are not an array
         return a === b;
     }
     else if (a.length !== b.length) { // lengths are different
@@ -17,12 +17,7 @@ export function arraysAreEquivalent(a, b) {
         return true;
     }
     else { // multi and length of both is equal
-        for (const [i, element] of a.entries()) {
-            if (element !== b[i]) {
-                return false;
-            }
-        }
-        return true;
+        return a.every((v, i) => b[i] === v);
     }
 }
 //# sourceMappingURL=arraysAreEquivalent.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js.map b/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js.map
index b143380..abd64b2 100644
--- a/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js.map
+++ b/node_modules/@patternfly/pfe-core/functions/arraysAreEquivalent.js.map
@@ -1 +1 @@
-{"version":3,"file":"arraysAreEquivalent.js","sourceRoot":"","sources":["arraysAreEquivalent.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AACH,MAAM,UAAU,mBAAmB,CAAC,CAAU,EAAE,CAAU;IACxD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QAC3C,OAAO,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC;SAAM,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,wBAAwB;QAC1D,OAAO,KAAK,CAAC;IACf,CAAC;SAAM,IAAI,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,iBAAiB;QACpD,OAAO,IAAI,CAAC;IACd,CAAC;SAAM,CAAC,CAAC,oCAAoC;QAC3C,KAAK,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC;YACvC,IAAI,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACrB,OAAO,KAAK,CAAC;YACf,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC","sourcesContent":["/**\n * Whether the two arrays are equivalent\n * Arrays are equivalent when they are both empty, or when their lengths are equal and each of\n * their members is equal (===) to the corresponding member in the other array.\n * If either argument is not an array, the result will be strict equivalence (===)\n * @param a first array\n * @param b second array\n */\nexport function arraysAreEquivalent(a: unknown, b: unknown): boolean {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return a === b;\n  } else if (a.length !== b.length) { // lengths are different\n    return false;\n  } else if (!a.length && !b.length) { // both are empty\n    return true;\n  } else { // multi and length of both is equal\n    for (const [i, element] of a.entries()) {\n      if (element !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"arraysAreEquivalent.js","sourceRoot":"","sources":["arraysAreEquivalent.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AACH,MAAM,UAAU,mBAAmB,CAAC,CAAU,EAAE,CAAU;IACxD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,+BAA+B;QAC3E,OAAO,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC;SAAM,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,wBAAwB;QAC1D,OAAO,KAAK,CAAC;IACf,CAAC;SAAM,IAAI,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,iBAAiB;QACpD,OAAO,IAAI,CAAC;IACd,CAAC;SAAM,CAAC,CAAC,oCAAoC;QAC3C,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IACvC,CAAC;AACH,CAAC","sourcesContent":["/**\n * Whether the two arrays are equivalent\n * Arrays are equivalent when they are both empty, or when their lengths are equal and each of\n * their members is equal (===) to the corresponding member in the other array.\n * If either argument is not an array, the result will be strict equivalence (===)\n * @param a first array\n * @param b second array\n */\nexport function arraysAreEquivalent(a: unknown, b: unknown): boolean {\n  if (!Array.isArray(a) || !Array.isArray(b)) { // one or both are not an array\n    return a === b;\n  } else if (a.length !== b.length) { // lengths are different\n    return false;\n  } else if (!a.length && !b.length) { // both are empty\n    return true;\n  } else { // multi and length of both is equal\n    return a.every((v, i) => b[i] === v);\n  }\n}\n"]}
\ No newline at end of file
