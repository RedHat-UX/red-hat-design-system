diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts
new file mode 100644
index 0000000..4723455
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts
@@ -0,0 +1,17 @@
+import type { ReactiveElement } from 'lit';
+import { type SlotControllerArgs, type SlotControllerPublicAPI } from './slot-controller.js';
+export declare class SlotController implements SlotControllerPublicAPI {
+    host: ReactiveElement;
+    static default: symbol;
+    /** @deprecated use `default` */
+    static anonymous: symbol;
+    static property: "ssrHintHasSlotted";
+    static attribute: "ssr-hint-has-slotted";
+    static anonymousAttribute: "ssr-hint-has-slotted-anonymous";
+    constructor(host: ReactiveElement, ..._: SlotControllerArgs);
+    hostConnected?(): Promise<void>;
+    private fromAttribute;
+    getSlotted<T extends Element = Element>(..._: string[]): T[];
+    hasSlotted(...names: (string | null)[]): boolean;
+    isEmpty(...names: (string | null)[]): boolean;
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js
new file mode 100644
index 0000000..5da25fa
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js
@@ -0,0 +1,33 @@
+var _a;
+import {} from './slot-controller.js';
+export class SlotController {
+    constructor(host, ..._) {
+        this.host = host;
+        host.addController(this);
+    }
+    fromAttribute(slots) {
+        return (slots ?? '')
+            .split(/[, ]/)
+            .map(x => x.trim());
+    }
+    getSlotted(..._) {
+        return [];
+    }
+    hasSlotted(...names) {
+        const attr = this.host.getAttribute(_a.attribute);
+        const anon = this.host.hasAttribute(_a.anonymousAttribute);
+        const hints = new Set(this.fromAttribute(attr));
+        return names.every(x => x === null ? anon : hints.has(x));
+    }
+    isEmpty(...names) {
+        return !this.hasSlotted(...names);
+    }
+}
+_a = SlotController;
+SlotController.default = Symbol('default slot');
+/** @deprecated use `default` */
+SlotController.anonymous = _a.default;
+SlotController.property = 'ssrHintHasSlotted';
+SlotController.attribute = 'ssr-hint-has-slotted';
+SlotController.anonymousAttribute = 'ssr-hint-has-slotted-anonymous';
+//# sourceMappingURL=slot-controller-server.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
index 3fae8f3..784dd4e 100644
--- a/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
@@ -1,4 +1,4 @@
-import type { ReactiveController, ReactiveElement } from 'lit';
+import { type ReactiveController, type ReactiveElement } from 'lit';
 interface AnonymousSlot {
     hasContent: boolean;
     elements: Element[];
@@ -9,8 +9,9 @@ interface NamedSlot extends AnonymousSlot {
     initialized: true;
 }
 export type Slot = NamedSlot | AnonymousSlot;
+export type SlotName = string | null;
 export interface SlotsConfig {
-    slots: (string | null)[];
+    slots: SlotName[];
     /**
      * Object mapping new slot name keys to deprecated slot name values
      * @example `pf-modal--header` is deprecated in favour of `header`
@@ -25,16 +26,58 @@ export interface SlotsConfig {
      */
     deprecations?: Record<string, string>;
 }
-export declare class SlotController implements ReactiveController {
+export type SlotControllerArgs = [SlotsConfig] | SlotName[];
+export declare function isObjectSpread(config: SlotControllerArgs): config is [SlotsConfig];
+export declare class SlotControllerPublicAPI implements ReactiveController {
+    static default: symbol;
+    host: ReactiveElement;
+    constructor(host: ReactiveElement, ...args: SlotControllerArgs);
+    hostConnected?(): Promise<void>;
+    hostDisconnected?(): void;
+    hostUpdated?(): void;
+    /**
+     * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
+     * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
+     * @param slotNames slots to query
+     * @example Get header-slotted elements
+     *          ```js
+     *          this.getSlotted('header')
+     *          ```
+     * @example Get header- and footer-slotted elements
+     *          ```js
+     *          this.getSlotted('header', 'footer')
+     *          ```
+     * @example Get default-slotted elements
+     *          ```js
+     *          this.getSlotted();
+     *          ```
+     */
+    getSlotted<T extends Element = Element>(...slotNames: string[]): T[];
+    /**
+     * Returns a boolean statement of whether or not any of those slots exists in the light DOM.
+     * @param names The slot names to check.
+     * @example this.hasSlotted('header');
+     */
+    hasSlotted(...names: (string | null | undefined)[]): boolean;
+    /**
+     * Whether or not all the requested slots are empty.
+     * @param  names The slot names to query.  If no value is provided, it returns the default slot.
+     * @example this.isEmpty('header', 'footer');
+     * @example this.isEmpty();
+     * @returns
+     */
+    isEmpty(...names: (string | null | undefined)[]): boolean;
+}
+export declare class SlotController implements SlotControllerPublicAPI {
     #private;
     host: ReactiveElement;
     static default: symbol;
     /** @deprecated use `default` */
     static anonymous: symbol;
-    constructor(host: ReactiveElement, ...config: ([SlotsConfig] | (string | null)[]));
+    constructor(host: ReactiveElement, ...args: SlotControllerArgs);
     hostConnected(): Promise<void>;
-    hostUpdated(): void;
     hostDisconnected(): void;
+    hostUpdated(): void;
     /**
      * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
      * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
index 7162155..43c66c0 100644
--- a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
@@ -1,7 +1,7 @@
-var _SlotController_instances, _a, _SlotController_nodes, _SlotController_logger, _SlotController_firstUpdated, _SlotController_mo, _SlotController_slotNames, _SlotController_deprecations, _SlotController_onSlotChange, _SlotController_onMutation, _SlotController_getChildrenForSlot, _SlotController_initSlot;
+var _SlotController_instances, _a, _SlotController_nodes, _SlotController_slotMapInitialized, _SlotController_slotNames, _SlotController_ssrHintHasSlotted, _SlotController_deprecations, _SlotController_mo, _SlotController_initialize, _SlotController_initSlotMap, _SlotController_getSlotElement, _SlotController_getChildrenForSlot;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
-import { Logger } from './logger.js';
-function isObjectConfigSpread(config) {
+import { isServer } from 'lit';
+export function isObjectSpread(config) {
     return config.length === 1 && typeof config[0] === 'object' && config[0] !== null;
 }
 /**
@@ -12,80 +12,42 @@ function isObjectConfigSpread(config) {
 const isSlot = (n) => (child) => n === SlotController.default ? !child.hasAttribute('slot')
     : child.getAttribute('slot') === n;
 export class SlotController {
-    constructor(host, ...config) {
+    constructor(host, ...args) {
         _SlotController_instances.add(this);
         this.host = host;
         _SlotController_nodes.set(this, new Map());
-        _SlotController_logger.set(this, void 0);
-        _SlotController_firstUpdated.set(this, false);
-        _SlotController_mo.set(this, new MutationObserver(records => __classPrivateFieldGet(this, _SlotController_onMutation, "f").call(this, records)));
-        _SlotController_slotNames.set(this, void 0);
+        _SlotController_slotMapInitialized.set(this, false);
+        _SlotController_slotNames.set(this, []);
+        _SlotController_ssrHintHasSlotted.set(this, []);
         _SlotController_deprecations.set(this, {});
-        _SlotController_onSlotChange.set(this, (event) => {
-            const slotName = event.target.name;
-            __classPrivateFieldGet(this, _SlotController_initSlot, "f").call(this, slotName);
-            this.host.requestUpdate();
-        });
-        _SlotController_onMutation.set(this, async (records) => {
-            const changed = [];
-            for (const { addedNodes, removedNodes } of records) {
-                for (const node of [...addedNodes, ...removedNodes]) {
-                    if (node instanceof HTMLElement && node.slot) {
-                        __classPrivateFieldGet(this, _SlotController_initSlot, "f").call(this, node.slot);
-                        changed.push(node.slot);
-                    }
-                }
-            }
-            this.host.requestUpdate();
-        });
-        _SlotController_initSlot.set(this, (slotName) => {
-            const name = slotName || _a.default;
-            const elements = __classPrivateFieldGet(this, _SlotController_nodes, "f").get(name)?.slot?.assignedElements?.()
-                ?? __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getChildrenForSlot).call(this, name);
-            const selector = slotName ? `slot[name="${slotName}"]` : 'slot:not([name])';
-            const slot = this.host.shadowRoot?.querySelector?.(selector) ?? null;
-            const hasContent = !!elements.length;
-            __classPrivateFieldGet(this, _SlotController_nodes, "f").set(name, { elements, name: slotName ?? '', hasContent, slot });
-            __classPrivateFieldGet(this, _SlotController_logger, "f").debug(slotName, hasContent);
-        });
-        __classPrivateFieldSet(this, _SlotController_logger, new Logger(this.host), "f");
-        if (isObjectConfigSpread(config)) {
-            const [{ slots, deprecations }] = config;
-            __classPrivateFieldSet(this, _SlotController_slotNames, slots, "f");
-            __classPrivateFieldSet(this, _SlotController_deprecations, deprecations ?? {}, "f");
-        }
-        else if (config.length >= 1) {
-            __classPrivateFieldSet(this, _SlotController_slotNames, config, "f");
-            __classPrivateFieldSet(this, _SlotController_deprecations, {}, "f");
-        }
-        else {
+        _SlotController_mo.set(this, new MutationObserver(__classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).bind(this)));
+        __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initialize).call(this, ...args);
+        host.addController(this);
+        if (!__classPrivateFieldGet(this, _SlotController_slotNames, "f").length) {
             __classPrivateFieldSet(this, _SlotController_slotNames, [null], "f");
         }
-        host.addController(this);
     }
     async hostConnected() {
-        this.host.addEventListener('slotchange', __classPrivateFieldGet(this, _SlotController_onSlotChange, "f"));
-        __classPrivateFieldSet(this, _SlotController_firstUpdated, false, "f");
         __classPrivateFieldGet(this, _SlotController_mo, "f").observe(this.host, { childList: true });
+        __classPrivateFieldSet(this, _SlotController_ssrHintHasSlotted, this.host
+            // @ts-expect-error: this is a ponyfill for ::has-slotted, is not intended as a public API
+            .ssrHintHasSlotted
+            ?? [], "f");
         // Map the defined slots into an object that is easier to query
         __classPrivateFieldGet(this, _SlotController_nodes, "f").clear();
-        // Loop over the properties provided by the schema
-        __classPrivateFieldGet(this, _SlotController_slotNames, "f").forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-        Object.values(__classPrivateFieldGet(this, _SlotController_deprecations, "f")).forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-        this.host.requestUpdate();
+        __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).call(this);
         // insurance for framework integrations
         await this.host.updateComplete;
         this.host.requestUpdate();
     }
-    hostUpdated() {
-        if (!__classPrivateFieldGet(this, _SlotController_firstUpdated, "f")) {
-            __classPrivateFieldGet(this, _SlotController_slotNames, "f").forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-            __classPrivateFieldSet(this, _SlotController_firstUpdated, true, "f");
-        }
-    }
     hostDisconnected() {
         __classPrivateFieldGet(this, _SlotController_mo, "f").disconnect();
     }
+    hostUpdated() {
+        if (!__classPrivateFieldGet(this, _SlotController_slotMapInitialized, "f")) {
+            __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).call(this);
+        }
+    }
     /**
      * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
      * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
@@ -134,9 +96,49 @@ export class SlotController {
         return !this.hasSlotted(...names);
     }
 }
-_a = SlotController, _SlotController_nodes = new WeakMap(), _SlotController_logger = new WeakMap(), _SlotController_firstUpdated = new WeakMap(), _SlotController_mo = new WeakMap(), _SlotController_slotNames = new WeakMap(), _SlotController_deprecations = new WeakMap(), _SlotController_onSlotChange = new WeakMap(), _SlotController_onMutation = new WeakMap(), _SlotController_initSlot = new WeakMap(), _SlotController_instances = new WeakSet(), _SlotController_getChildrenForSlot = function _SlotController_getChildrenForSlot(name) {
-    const children = Array.from(this.host.children);
-    return children.filter(isSlot(name));
+_a = SlotController, _SlotController_nodes = new WeakMap(), _SlotController_slotMapInitialized = new WeakMap(), _SlotController_slotNames = new WeakMap(), _SlotController_ssrHintHasSlotted = new WeakMap(), _SlotController_deprecations = new WeakMap(), _SlotController_mo = new WeakMap(), _SlotController_instances = new WeakSet(), _SlotController_initialize = function _SlotController_initialize(...config) {
+    if (isObjectSpread(config)) {
+        const [{ slots, deprecations }] = config;
+        __classPrivateFieldSet(this, _SlotController_slotNames, slots, "f");
+        __classPrivateFieldSet(this, _SlotController_deprecations, deprecations ?? {}, "f");
+    }
+    else if (config.length >= 1) {
+        __classPrivateFieldSet(this, _SlotController_slotNames, config, "f");
+        __classPrivateFieldSet(this, _SlotController_deprecations, {}, "f");
+    }
+}, _SlotController_initSlotMap = function _SlotController_initSlotMap() {
+    // Loop over the properties provided by the schema
+    for (const slotName of __classPrivateFieldGet(this, _SlotController_slotNames, "f")
+        .concat(Object.values(__classPrivateFieldGet(this, _SlotController_deprecations, "f")))) {
+        const slotId = slotName || _a.default;
+        const name = slotName ?? '';
+        const elements = __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getChildrenForSlot).call(this, slotId);
+        const slot = __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getSlotElement).call(this, slotId);
+        const hasContent = isServer ? __classPrivateFieldGet(this, _SlotController_ssrHintHasSlotted, "f").includes(slotName)
+            : !!elements.length || !!slot?.assignedNodes?.()?.filter(x => x.textContent?.trim()).length;
+        __classPrivateFieldGet(this, _SlotController_nodes, "f").set(slotId, { elements, name, hasContent, slot });
+    }
+    this.host.requestUpdate();
+    __classPrivateFieldSet(this, _SlotController_slotMapInitialized, true, "f");
+}, _SlotController_getSlotElement = function _SlotController_getSlotElement(slotId) {
+    if (isServer) {
+        return null;
+    }
+    else {
+        const selector = slotId === _a.default ? 'slot:not([name])' : `slot[name="${slotId}"]`;
+        return this.host.shadowRoot?.querySelector?.(selector) ?? null;
+    }
+}, _SlotController_getChildrenForSlot = function _SlotController_getChildrenForSlot(name) {
+    if (isServer) {
+        return [];
+    }
+    else if (__classPrivateFieldGet(this, _SlotController_nodes, "f").has(name)) {
+        return (__classPrivateFieldGet(this, _SlotController_nodes, "f").get(name).slot?.assignedElements?.() ?? []);
+    }
+    else {
+        const children = Array.from(this.host.children);
+        return children.filter(isSlot(name));
+    }
 };
 SlotController.default = Symbol('default slot');
 /** @deprecated use `default` */
diff --git a/node_modules/@patternfly/pfe-core/decorators/observes.js b/node_modules/@patternfly/pfe-core/decorators/observes.js
index d2a82be..5c38c6f 100644
--- a/node_modules/@patternfly/pfe-core/decorators/observes.js
+++ b/node_modules/@patternfly/pfe-core/decorators/observes.js
@@ -13,18 +13,30 @@ import { PropertyObserverController, } from '@patternfly/pfe-core/controllers/pr
  */
 export function observes(propertyName, options) {
     return function (proto, methodName) {
-        const callback = proto[methodName];
-        if (typeof callback !== 'function') {
-            throw new Error('@observes must decorate a class method');
+        if (typeof methodName === 'object') {
+            methodName.addInitializer(function() {
+                this.constructor.addInitializer(instance => {
+                    instance.addController(new PropertyObserverController(instance, {
+                        ...options,
+                        propertyName,
+                        callback: proto,
+                    }));
+                });
+            });
+        } else {
+            const callback = proto[methodName];
+            if (typeof callback !== 'function') {
+                throw new Error('@observes must decorate a class method');
+            }
+            const klass = proto.constructor;
+            klass.addInitializer(instance => {
+                instance.addController(new PropertyObserverController(instance, {
+                    ...options,
+                    propertyName,
+                    callback,
+                }));
+            });
         }
-        const klass = proto.constructor;
-        klass.addInitializer(instance => {
-            instance.addController(new PropertyObserverController(instance, {
-                ...options,
-                propertyName,
-                callback,
-            }));
-        });
     };
 }
 //# sourceMappingURL=observes.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/package.json b/node_modules/@patternfly/pfe-core/package.json
index 55fdb01..c772d45 100644
--- a/node_modules/@patternfly/pfe-core/package.json
+++ b/node_modules/@patternfly/pfe-core/package.json
@@ -32,7 +32,11 @@
     "./controllers/property-observer-controller.js": "./controllers/property-observer-controller.js",
     "./controllers/roving-tabindex-controller.js": "./controllers/roving-tabindex-controller.js",
     "./controllers/scroll-spy-controller.js": "./controllers/scroll-spy-controller.js",
-    "./controllers/slot-controller.js": "./controllers/slot-controller.js",
+    "./controllers/slot-controller.js": {
+      "node": "./controllers/slot-controller-server.js",
+      "import": "./controllers/slot-controller.js",
+      "default": "./controllers/slot-controller.js"
+    },
     "./controllers/style-controller.js": "./controllers/style-controller.js",
     "./controllers/timestamp-controller.js": "./controllers/timestamp-controller.js",
     "./controllers/tabs-controller.js": "./controllers/tabs-controller.js",
