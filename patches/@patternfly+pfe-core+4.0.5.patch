diff --git a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.d.ts
index d31b514..4bf8ba4 100644
--- a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.d.ts
@@ -1,4 +1,4 @@
-import type { ReactiveController, ReactiveElement } from 'lit';
+import { type ReactiveController, type ReactiveElement } from 'lit';
 export interface Options {
     observe?: boolean | MutationObserverInit;
     emptyWarning?: string;
diff --git a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js
index e256eb6..3c82ece 100644
--- a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js
@@ -1,3 +1,4 @@
+import { isServer } from 'lit';
 import { Logger } from './logger.js';
 export class LightDOMController {
     constructor(host, initializer, options) {
@@ -31,8 +32,13 @@ export class LightDOMController {
      * Returns a boolean statement of whether or not this component contains any light DOM.
      */
     hasLightDOM() {
-        return !!(this.host.children.length > 0
-            || (this.host.textContent ?? '').trim().length > 0);
+        if (isServer) {
+            return false;
+        }
+        else {
+            return !!(this.host.children.length > 0
+                || (this.host.textContent ?? '').trim().length > 0);
+        }
     }
 }
 //# sourceMappingURL=light-dom-controller.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js.map
index 02f424a..b6d1bf9 100644
--- a/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/light-dom-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"light-dom-controller.js","sourceRoot":"","sources":["light-dom-controller.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAOrC,MAAM,OAAO,kBAAkB;IAK7B,YACU,IAAqB,EAC7B,WAAuB,EACf,OAA6B;QAF7B,SAAI,GAAJ,IAAI,CAAiB;QAErB,YAAO,GAAP,OAAO,CAAsB;QAErC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAI,CAAC,EAAE,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACjD,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC;YACvB,IAAI,CAAC,WAAW,EAAE,CAAC;QACrB,CAAC;aAAM,IAAI,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE,CAAC;YACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QAC/C,CAAC;QAED,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED,gBAAgB;QACd,IAAI,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC;IACvB,CAAC;IAEO,YAAY;QAClB,IAAI,IAAI,CAAC,OAAO,EAAE,OAAO,IAAI,IAAI,EAAE,CAAC;YAClC,8CAA8C;YAC9C,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,IAAI,CAAC,IAAI,EACP,OAAO,IAAI,CAAC,OAAO,EAAE,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE;gBACjE,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,OAA+B,CAChD,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,WAAW;QACT,OAAO,CAAC,CAAC,CACP,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;eAC1B,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CACnD,CAAC;IACJ,CAAC;CACF","sourcesContent":["import type { ReactiveController, ReactiveElement } from 'lit';\n\nimport { Logger } from './logger.js';\n\nexport interface Options {\n  observe?: boolean | MutationObserverInit;\n  emptyWarning?: string;\n}\n\nexport class LightDOMController implements ReactiveController {\n  private mo: MutationObserver;\n  private logger: Logger;\n  private initializer: () => void;\n\n  constructor(\n    private host: ReactiveElement,\n    initializer: () => void,\n    private options?: Options | undefined,\n  ) {\n    this.initializer = initializer.bind(host);\n    this.mo = new MutationObserver(this.initializer);\n    this.logger = new Logger(this.host);\n    host.addController(this);\n  }\n\n  hostConnected(): void {\n    if (this.hasLightDOM()) {\n      this.initializer();\n    } else if (this.options?.emptyWarning) {\n      this.logger.warn(this.options?.emptyWarning);\n    }\n\n    this.initObserver();\n  }\n\n  hostDisconnected(): void {\n    this.mo.disconnect();\n  }\n\n  private initObserver() {\n    if (this.options?.observe ?? true) {\n      // Use the provided options, or their defaults\n      this.mo.observe(\n        this.host,\n          typeof this.options?.observe !== 'object' ? { childList: true }\n        : this.options?.observe as MutationObserverInit\n      );\n    }\n  }\n\n  /**\n   * Returns a boolean statement of whether or not this component contains any light DOM.\n   */\n  hasLightDOM(): boolean {\n    return !!(\n      this.host.children.length > 0\n      || (this.host.textContent ?? '').trim().length > 0\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"light-dom-controller.js","sourceRoot":"","sources":["light-dom-controller.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAiD,MAAM,KAAK,CAAC;AAE9E,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAOrC,MAAM,OAAO,kBAAkB;IAK7B,YACU,IAAqB,EAC7B,WAAuB,EACf,OAA6B;QAF7B,SAAI,GAAJ,IAAI,CAAiB;QAErB,YAAO,GAAP,OAAO,CAAsB;QAErC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAI,CAAC,EAAE,GAAG,IAAI,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACjD,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED,aAAa;QACX,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC;YACvB,IAAI,CAAC,WAAW,EAAE,CAAC;QACrB,CAAC;aAAM,IAAI,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE,CAAC;YACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QAC/C,CAAC;QAED,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED,gBAAgB;QACd,IAAI,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC;IACvB,CAAC;IAEO,YAAY;QAClB,IAAI,IAAI,CAAC,OAAO,EAAE,OAAO,IAAI,IAAI,EAAE,CAAC;YAClC,8CAA8C;YAC9C,IAAI,CAAC,EAAE,CAAC,OAAO,CACb,IAAI,CAAC,IAAI,EACP,OAAO,IAAI,CAAC,OAAO,EAAE,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE;gBACjE,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,OAA+B,CAChD,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,WAAW;QACT,IAAI,QAAQ,EAAE,CAAC;YACb,OAAO,KAAK,CAAC;QACf,CAAC;aAAM,CAAC;YACN,OAAO,CAAC,CAAC,CACP,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;mBAC1B,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CACnD,CAAC;QACJ,CAAC;IACH,CAAC;CACF","sourcesContent":["import { isServer, type ReactiveController, type ReactiveElement } from 'lit';\n\nimport { Logger } from './logger.js';\n\nexport interface Options {\n  observe?: boolean | MutationObserverInit;\n  emptyWarning?: string;\n}\n\nexport class LightDOMController implements ReactiveController {\n  private mo: MutationObserver;\n  private logger: Logger;\n  private initializer: () => void;\n\n  constructor(\n    private host: ReactiveElement,\n    initializer: () => void,\n    private options?: Options | undefined,\n  ) {\n    this.initializer = initializer.bind(host);\n    this.mo = new MutationObserver(this.initializer);\n    this.logger = new Logger(this.host);\n    host.addController(this);\n  }\n\n  hostConnected(): void {\n    if (this.hasLightDOM()) {\n      this.initializer();\n    } else if (this.options?.emptyWarning) {\n      this.logger.warn(this.options?.emptyWarning);\n    }\n\n    this.initObserver();\n  }\n\n  hostDisconnected(): void {\n    this.mo.disconnect();\n  }\n\n  private initObserver() {\n    if (this.options?.observe ?? true) {\n      // Use the provided options, or their defaults\n      this.mo.observe(\n        this.host,\n          typeof this.options?.observe !== 'object' ? { childList: true }\n        : this.options?.observe as MutationObserverInit\n      );\n    }\n  }\n\n  /**\n   * Returns a boolean statement of whether or not this component contains any light DOM.\n   */\n  hasLightDOM(): boolean {\n    if (isServer) {\n      return false;\n    } else {\n      return !!(\n        this.host.children.length > 0\n        || (this.host.textContent ?? '').trim().length > 0\n      );\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
index d342387..addc933 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.d.ts
@@ -1,4 +1,4 @@
-import type { ReactiveController, ReactiveControllerHost } from 'lit';
+import { type ReactiveController, type ReactiveControllerHost } from 'lit';
 export interface ScrollSpyControllerOptions extends IntersectionObserverInit {
     /**
      * Tag names of legal link children.
@@ -20,6 +20,10 @@ export interface ScrollSpyControllerOptions extends IntersectionObserverInit {
      * @default el => el.getAttribute('href');
      */
     getHash?: (el: Element) => string | null;
+    /**
+     * Optional callback for when an intersection occurs
+     */
+    onIntersection?(): void;
 }
 export declare class ScrollSpyController implements ReactiveController {
     #private;
@@ -32,6 +36,7 @@ export declare class ScrollSpyController implements ReactiveController {
     set threshold(v: number | number[]);
     constructor(host: ReactiveControllerHost & HTMLElement, options: ScrollSpyControllerOptions);
     hostConnected(): void;
+    hostDisconnected(): void;
     /**
      * Explicitly set the active item
      * @param link usually an `<a>`
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
index fd5a7dc..1e8466d 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js
@@ -1,5 +1,6 @@
-var _ScrollSpyController_instances, _ScrollSpyController_tagNames, _ScrollSpyController_activeAttribute, _ScrollSpyController_io, _ScrollSpyController_passedLinks, _ScrollSpyController_force, _ScrollSpyController_intersected, _ScrollSpyController_root, _ScrollSpyController_rootMargin, _ScrollSpyController_threshold, _ScrollSpyController_getRootNode, _ScrollSpyController_getHash, _ScrollSpyController_linkChildren_get, _ScrollSpyController_initIo, _ScrollSpyController_markPassed, _ScrollSpyController_setActive, _ScrollSpyController_nextIntersection, _ScrollSpyController_onIo;
+var _ScrollSpyController_instances, _a, _ScrollSpyController_instances_1, _ScrollSpyController_tagNames, _ScrollSpyController_activeAttribute, _ScrollSpyController_io, _ScrollSpyController_passedLinks, _ScrollSpyController_force, _ScrollSpyController_intersected, _ScrollSpyController_root, _ScrollSpyController_rootMargin, _ScrollSpyController_threshold, _ScrollSpyController_intersectingTargets, _ScrollSpyController_linkTargetMap, _ScrollSpyController_getRootNode, _ScrollSpyController_getHash, _ScrollSpyController_onIntersection, _ScrollSpyController_linkChildren_get, _ScrollSpyController_initializing, _ScrollSpyController_initIo, _ScrollSpyController_markPassed, _ScrollSpyController_setActive, _ScrollSpyController_activateHash, _ScrollSpyController_nextIntersection, _ScrollSpyController_onIo;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
+import { isServer } from 'lit';
 export class ScrollSpyController {
     get root() {
         return __classPrivateFieldGet(this, _ScrollSpyController_root, "f");
@@ -40,20 +41,30 @@ export class ScrollSpyController {
         _ScrollSpyController_root.set(this, void 0);
         _ScrollSpyController_rootMargin.set(this, void 0);
         _ScrollSpyController_threshold.set(this, void 0);
+        _ScrollSpyController_intersectingTargets.set(this, new Set());
+        _ScrollSpyController_linkTargetMap.set(this, new Map());
         _ScrollSpyController_getRootNode.set(this, void 0);
         _ScrollSpyController_getHash.set(this, void 0);
+        _ScrollSpyController_onIntersection.set(this, void 0);
+        _ScrollSpyController_initializing.set(this, true);
         host.addController(this);
         __classPrivateFieldSet(this, _ScrollSpyController_tagNames, options.tagNames, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_root, options.root, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_rootMargin, options.rootMargin, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_activeAttribute, options.activeAttribute ?? 'active', "f");
         __classPrivateFieldSet(this, _ScrollSpyController_threshold, options.threshold ?? 0.85, "f");
-        __classPrivateFieldSet(this, _ScrollSpyController_getRootNode, () => options.rootNode ?? host.getRootNode(), "f");
+        __classPrivateFieldSet(this, _ScrollSpyController_getRootNode, () => options.rootNode ?? host.getRootNode?.() ?? null, "f");
         __classPrivateFieldSet(this, _ScrollSpyController_getHash, options?.getHash ?? ((el) => el.getAttribute('href')), "f");
+        __classPrivateFieldSet(this, _ScrollSpyController_onIntersection, options?.onIntersection, "f");
     }
     hostConnected() {
+        __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).add(this);
         __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_initIo).call(this);
     }
+    hostDisconnected() {
+        __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).delete(this);
+        __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.disconnect();
+    }
     /**
      * Explicitly set the active item
      * @param link usually an `<a>`
@@ -72,20 +83,29 @@ export class ScrollSpyController {
         __classPrivateFieldSet(this, _ScrollSpyController_force, false, "f");
     }
 }
-_ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttribute = new WeakMap(), _ScrollSpyController_io = new WeakMap(), _ScrollSpyController_passedLinks = new WeakMap(), _ScrollSpyController_force = new WeakMap(), _ScrollSpyController_intersected = new WeakMap(), _ScrollSpyController_root = new WeakMap(), _ScrollSpyController_rootMargin = new WeakMap(), _ScrollSpyController_threshold = new WeakMap(), _ScrollSpyController_getRootNode = new WeakMap(), _ScrollSpyController_getHash = new WeakMap(), _ScrollSpyController_instances = new WeakSet(), _ScrollSpyController_linkChildren_get = function _ScrollSpyController_linkChildren_get() {
-    return Array.from(this.host.querySelectorAll(__classPrivateFieldGet(this, _ScrollSpyController_tagNames, "f").join(',')))
-        .filter(__classPrivateFieldGet(this, _ScrollSpyController_getHash, "f"));
-}, _ScrollSpyController_initIo = function _ScrollSpyController_initIo() {
+_a = ScrollSpyController, _ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttribute = new WeakMap(), _ScrollSpyController_io = new WeakMap(), _ScrollSpyController_passedLinks = new WeakMap(), _ScrollSpyController_force = new WeakMap(), _ScrollSpyController_intersected = new WeakMap(), _ScrollSpyController_root = new WeakMap(), _ScrollSpyController_rootMargin = new WeakMap(), _ScrollSpyController_threshold = new WeakMap(), _ScrollSpyController_intersectingTargets = new WeakMap(), _ScrollSpyController_linkTargetMap = new WeakMap(), _ScrollSpyController_getRootNode = new WeakMap(), _ScrollSpyController_getHash = new WeakMap(), _ScrollSpyController_onIntersection = new WeakMap(), _ScrollSpyController_initializing = new WeakMap(), _ScrollSpyController_instances = new WeakSet(), _ScrollSpyController_linkChildren_get = function _ScrollSpyController_linkChildren_get() {
+    if (isServer) {
+        return [];
+    }
+    else {
+        return Array.from(this.host.querySelectorAll(__classPrivateFieldGet(this, _ScrollSpyController_tagNames, "f").join(',')))
+            .filter(__classPrivateFieldGet(this, _ScrollSpyController_getHash, "f"));
+    }
+}, _ScrollSpyController_initIo = async function _ScrollSpyController_initIo() {
     const rootNode = __classPrivateFieldGet(this, _ScrollSpyController_getRootNode, "f").call(this);
     if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {
         const { rootMargin, threshold, root } = this;
         __classPrivateFieldSet(this, _ScrollSpyController_io, new IntersectionObserver(r => __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_onIo).call(this, r), { root, rootMargin, threshold }), "f");
-        __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)
-            .map(x => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, x))
-            .filter((x) => !!x)
-            .map(x => rootNode.getElementById(x.replace('#', '')))
-            .filter((x) => !!x)
-            .forEach(target => __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.observe(target));
+        for (const link of __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)) {
+            const id = __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, link)?.replace('#', '');
+            if (id) {
+                const target = document.getElementById(id);
+                if (target) {
+                    __classPrivateFieldGet(this, _ScrollSpyController_io, "f")?.observe(target);
+                    __classPrivateFieldGet(this, _ScrollSpyController_linkTargetMap, "f").set(link, target);
+                }
+            }
+        }
     }
 }, _ScrollSpyController_markPassed = function _ScrollSpyController_markPassed(link, force) {
     if (force) {
@@ -98,6 +118,16 @@ _ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttrib
     for (const child of __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get)) {
         child.toggleAttribute(__classPrivateFieldGet(this, _ScrollSpyController_activeAttribute, "f"), child === link);
     }
+}, _ScrollSpyController_activateHash = async function _ScrollSpyController_activateHash() {
+    const links = __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get);
+    const { hash } = location;
+    if (!hash) {
+        this.setActive(links.at(0) ?? null);
+    }
+    else {
+        await __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_nextIntersection).call(this);
+        this.setActive(links.find(x => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, x) === hash) ?? null);
+    }
 }, _ScrollSpyController_nextIntersection = async function _ScrollSpyController_nextIntersection() {
     __classPrivateFieldSet(this, _ScrollSpyController_intersected, false, "f");
     // safeguard the loop
@@ -119,5 +149,43 @@ _ScrollSpyController_tagNames = new WeakMap(), _ScrollSpyController_activeAttrib
         __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, last ?? __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).at(0));
     }
     __classPrivateFieldSet(this, _ScrollSpyController_intersected, true, "f");
+    __classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").clear();
+    for (const entry of entries) {
+        if (entry.isIntersecting) {
+            __classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").add(entry.target);
+        }
+    }
+    if (__classPrivateFieldGet(this, _ScrollSpyController_initializing, "f")) {
+        const ints = entries?.filter(x => x.isIntersecting) ?? [];
+        if (__classPrivateFieldGet(this, _ScrollSpyController_intersectingTargets, "f").size > 0) {
+            const [{ target = null } = {}] = ints;
+            const { id } = target ?? {};
+            if (id) {
+                const link = __classPrivateFieldGet(this, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).find(link => __classPrivateFieldGet(this, _ScrollSpyController_getHash, "f").call(this, link) === `#${id}`);
+                if (link) {
+                    __classPrivateFieldGet(this, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(this, link);
+                }
+            }
+        }
+        __classPrivateFieldSet(this, _ScrollSpyController_initializing, false, "f");
+    }
+    __classPrivateFieldGet(this, _ScrollSpyController_onIntersection, "f")?.call(this);
 };
+_ScrollSpyController_instances_1 = { value: new Set };
+(() => {
+    if (!isServer) {
+        addEventListener('scroll', () => {
+            if (Math.round(window.innerHeight + window.scrollY) >= document.body.scrollHeight) {
+                __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
+                    __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "m", _ScrollSpyController_setActive).call(ssc, __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "a", _ScrollSpyController_linkChildren_get).at(-1));
+                });
+            }
+        }, { passive: true });
+        addEventListener('hashchange', () => {
+            __classPrivateFieldGet(_a, _a, "f", _ScrollSpyController_instances_1).forEach(ssc => {
+                __classPrivateFieldGet(ssc, _ScrollSpyController_instances, "m", _ScrollSpyController_activateHash).call(ssc);
+            });
+        });
+    }
+})();
 //# sourceMappingURL=scroll-spy-controller.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
index b0e31b2..f350c7e 100644
--- a/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/scroll-spy-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"scroll-spy-controller.js","sourceRoot":"","sources":["scroll-spy-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\n\nexport interface ScrollSpyControllerOptions extends IntersectionObserverInit {\n  /**\n   * Tag names of legal link children.\n   * Legal children must have an `href` property/attribute pair, like `<a>`.\n   */\n  tagNames: string[];\n\n  /**\n   * Attribute to set on the active link element.\n   * @default 'active'\n   */\n  activeAttribute?: string;\n\n  /**\n   * The root node to query content for\n   * @default the host's root node\n   */\n  rootNode?: Node;\n  /**\n   * function to call on link children to get their URL hash (i.e. id to scroll to)\n   * @default el => el.getAttribute('href');\n   */\n  getHash?: (el: Element) => string | null;\n}\n\nexport class ScrollSpyController implements ReactiveController {\n  #tagNames: string[];\n  #activeAttribute: string;\n\n  #io?: IntersectionObserver;\n\n  /** Which link's targets have already scrolled past? */\n  #passedLinks = new Set<Element>();\n\n  /** Ignore intersections? */\n  #force = false;\n\n  /** Has the intersection observer found an element? */\n  #intersected = false;\n\n  #root: ScrollSpyControllerOptions['root'];\n  #rootMargin?: string;\n  #threshold: number | number[];\n\n  #getRootNode: () => Node;\n  #getHash: (el: Element) => string | null;\n\n  get #linkChildren(): Element[] {\n    return Array.from(this.host.querySelectorAll(this.#tagNames.join(',')))\n        .filter(this.#getHash);\n  }\n\n  get root(): Element | Document | null | undefined {\n    return this.#root;\n  }\n\n  set root(v) {\n    this.#root = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get rootMargin(): string | undefined {\n    return this.#rootMargin;\n  }\n\n  set rootMargin(v) {\n    this.#rootMargin = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get threshold(): number | number[] {\n    return this.#threshold;\n  }\n\n  set threshold(v) {\n    this.#threshold = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  constructor(\n    private host: ReactiveControllerHost & HTMLElement,\n    options: ScrollSpyControllerOptions,\n  ) {\n    host.addController(this);\n    this.#tagNames = options.tagNames;\n    this.#root = options.root;\n    this.#rootMargin = options.rootMargin;\n    this.#activeAttribute = options.activeAttribute ?? 'active';\n    this.#threshold = options.threshold ?? 0.85;\n    this.#getRootNode = () => options.rootNode ?? host.getRootNode();\n    this.#getHash = options?.getHash ?? ((el: Element) => el.getAttribute('href'));\n  }\n\n  hostConnected(): void {\n    this.#initIo();\n  }\n\n  #initIo() {\n    const rootNode = this.#getRootNode();\n    if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {\n      const { rootMargin, threshold, root } = this;\n      this.#io = new IntersectionObserver(r => this.#onIo(r), { root, rootMargin, threshold });\n      this.#linkChildren\n          .map(x => this.#getHash(x))\n          .filter((x): x is string => !!x)\n          .map(x => rootNode.getElementById(x.replace('#', '')))\n          .filter((x): x is HTMLElement => !!x)\n          .forEach(target => this.#io?.observe(target));\n    }\n  }\n\n  #markPassed(link: Element, force: boolean) {\n    if (force) {\n      this.#passedLinks.add(link);\n    } else {\n      this.#passedLinks.delete(link);\n    }\n  }\n\n  #setActive(link?: EventTarget | null) {\n    for (const child of this.#linkChildren) {\n      child.toggleAttribute(this.#activeAttribute, child === link);\n    }\n  }\n\n  async #nextIntersection() {\n    this.#intersected = false;\n    // safeguard the loop\n    setTimeout(() => this.#intersected = false, 3000);\n    while (!this.#intersected) {\n      await new Promise(requestAnimationFrame);\n    }\n  }\n\n  async #onIo(entries: IntersectionObserverEntry[]) {\n    if (!this.#force) {\n      for (const { target, boundingClientRect, intersectionRect } of entries) {\n        const selector = `:is(${this.#tagNames.join(',')})[href=\"#${target.id}\"]`;\n        const link = this.host.querySelector(selector);\n        if (link) {\n          this.#markPassed(link, boundingClientRect.top < intersectionRect.top);\n        }\n      }\n      const link = [...this.#passedLinks];\n      const last = link.at(-1);\n      this.#setActive(last ?? this.#linkChildren.at(0));\n    }\n    this.#intersected = true;\n  }\n\n  /**\n   * Explicitly set the active item\n   * @param link usually an `<a>`\n   */\n  public async setActive(link: EventTarget | null): Promise<void> {\n    this.#force = true;\n    this.#setActive(link);\n    let sawActive = false;\n    for (const child of this.#linkChildren) {\n      this.#markPassed(child, !sawActive);\n      if (child === link) {\n        sawActive = true;\n      }\n    }\n    await this.#nextIntersection();\n    this.#force = false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"scroll-spy-controller.js","sourceRoot":"","sources":["scroll-spy-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveController, type ReactiveControllerHost } from 'lit';\n\nexport interface ScrollSpyControllerOptions extends IntersectionObserverInit {\n  /**\n   * Tag names of legal link children.\n   * Legal children must have an `href` property/attribute pair, like `<a>`.\n   */\n  tagNames: string[];\n\n  /**\n   * Attribute to set on the active link element.\n   * @default 'active'\n   */\n  activeAttribute?: string;\n\n  /**\n   * The root node to query content for\n   * @default the host's root node\n   */\n  rootNode?: Node;\n\n  /**\n   * function to call on link children to get their URL hash (i.e. id to scroll to)\n   * @default el => el.getAttribute('href');\n   */\n  getHash?: (el: Element) => string | null;\n\n  /**\n   * Optional callback for when an intersection occurs\n   */\n  onIntersection?(): void;\n}\n\nexport class ScrollSpyController implements ReactiveController {\n  static #instances = new Set<ScrollSpyController>;\n\n  static {\n    if (!isServer) {\n      addEventListener('scroll', () => {\n        if (Math.round(window.innerHeight + window.scrollY) >= document.body.scrollHeight) {\n          this.#instances.forEach(ssc => {\n            ssc.#setActive(ssc.#linkChildren.at(-1));\n          });\n        }\n      }, { passive: true });\n      addEventListener('hashchange', () => {\n        this.#instances.forEach(ssc => {\n          ssc.#activateHash();\n        });\n      });\n    }\n  }\n\n  #tagNames: string[];\n\n  #activeAttribute: string;\n\n  #io?: IntersectionObserver;\n\n  /** Which link's targets have already scrolled past? */\n  #passedLinks = new Set<Element>();\n\n  /** Ignore intersections? */\n  #force = false;\n\n  /** Has the intersection observer found an element? */\n  #intersected = false;\n\n  #root: ScrollSpyControllerOptions['root'];\n\n  #rootMargin?: string;\n\n  #threshold: number | number[];\n\n  #intersectingTargets = new Set<Element>();\n\n  #linkTargetMap = new Map<Element, Element | null>();\n\n  #getRootNode: () => Node | null;\n\n  #getHash: (el: Element) => string | null;\n\n  #onIntersection?: () => void;\n\n  get #linkChildren(): Element[] {\n    if (isServer) {\n      return [];\n    } else {\n      return Array.from(this.host.querySelectorAll(this.#tagNames.join(',')))\n          .filter(this.#getHash);\n    }\n  }\n\n  get root(): Element | Document | null | undefined {\n    return this.#root;\n  }\n\n  set root(v) {\n    this.#root = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get rootMargin(): string | undefined {\n    return this.#rootMargin;\n  }\n\n  set rootMargin(v) {\n    this.#rootMargin = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  get threshold(): number | number[] {\n    return this.#threshold;\n  }\n\n  set threshold(v) {\n    this.#threshold = v;\n    this.#io?.disconnect();\n    this.#initIo();\n  }\n\n  constructor(\n    private host: ReactiveControllerHost & HTMLElement,\n    options: ScrollSpyControllerOptions,\n  ) {\n    host.addController(this);\n    this.#tagNames = options.tagNames;\n    this.#root = options.root;\n    this.#rootMargin = options.rootMargin;\n    this.#activeAttribute = options.activeAttribute ?? 'active';\n    this.#threshold = options.threshold ?? 0.85;\n    this.#getRootNode = () => options.rootNode ?? host.getRootNode?.() ?? null;\n    this.#getHash = options?.getHash ?? ((el: Element) => el.getAttribute('href'));\n    this.#onIntersection = options?.onIntersection;\n  }\n\n  hostConnected(): void {\n    ScrollSpyController.#instances.add(this);\n    this.#initIo();\n  }\n\n  hostDisconnected(): void {\n    ScrollSpyController.#instances.delete(this);\n    this.#io?.disconnect();\n  }\n\n  #initializing = true;\n\n  async #initIo() {\n    const rootNode = this.#getRootNode();\n    if (rootNode instanceof Document || rootNode instanceof ShadowRoot) {\n      const { rootMargin, threshold, root } = this;\n      this.#io = new IntersectionObserver(r => this.#onIo(r), { root, rootMargin, threshold });\n      for (const link of this.#linkChildren) {\n        const id = this.#getHash(link)?.replace('#', '');\n        if (id) {\n          const target = document.getElementById(id);\n          if (target) {\n            this.#io?.observe(target);\n            this.#linkTargetMap.set(link, target);\n          }\n        }\n      }\n    }\n  }\n\n  #markPassed(link: Element, force: boolean) {\n    if (force) {\n      this.#passedLinks.add(link);\n    } else {\n      this.#passedLinks.delete(link);\n    }\n  }\n\n  #setActive(link?: EventTarget | null) {\n    for (const child of this.#linkChildren) {\n      child.toggleAttribute(this.#activeAttribute, child === link);\n    }\n  }\n\n  async #activateHash() {\n    const links = this.#linkChildren;\n    const { hash } = location;\n    if (!hash) {\n      this.setActive(links.at(0) ?? null);\n    } else {\n      await this.#nextIntersection();\n      this.setActive(links.find(x => this.#getHash(x) === hash) ?? null);\n    }\n  }\n\n  async #nextIntersection() {\n    this.#intersected = false;\n    // safeguard the loop\n    setTimeout(() => this.#intersected = false, 3000);\n    while (!this.#intersected) {\n      await new Promise(requestAnimationFrame);\n    }\n  }\n\n  async #onIo(entries: IntersectionObserverEntry[]) {\n    if (!this.#force) {\n      for (const { target, boundingClientRect, intersectionRect } of entries) {\n        const selector = `:is(${this.#tagNames.join(',')})[href=\"#${target.id}\"]`;\n        const link = this.host.querySelector(selector);\n        if (link) {\n          this.#markPassed(link, boundingClientRect.top < intersectionRect.top);\n        }\n      }\n      const link = [...this.#passedLinks];\n      const last = link.at(-1);\n      this.#setActive(last ?? this.#linkChildren.at(0));\n    }\n    this.#intersected = true;\n    this.#intersectingTargets.clear();\n    for (const entry of entries) {\n      if (entry.isIntersecting) {\n        this.#intersectingTargets.add(entry.target);\n      }\n    }\n    if (this.#initializing) {\n      const ints = entries?.filter(x => x.isIntersecting) ?? [];\n      if (this.#intersectingTargets.size > 0) {\n        const [{ target = null } = {}] = ints;\n        const { id } = target ?? {};\n        if (id) {\n          const link = this.#linkChildren.find(link => this.#getHash(link) === `#${id}`);\n          if (link) {\n            this.#setActive(link);\n          }\n        }\n      }\n      this.#initializing = false;\n    }\n    this.#onIntersection?.();\n  }\n\n  /**\n   * Explicitly set the active item\n   * @param link usually an `<a>`\n   */\n  public async setActive(link: EventTarget | null): Promise<void> {\n    this.#force = true;\n    this.#setActive(link);\n    let sawActive = false;\n    for (const child of this.#linkChildren) {\n      this.#markPassed(child, !sawActive);\n      if (child === link) {\n        sawActive = true;\n      }\n    }\n    await this.#nextIntersection();\n    this.#force = false;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts
new file mode 100644
index 0000000..a6cf023
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.d.ts
@@ -0,0 +1,16 @@
+import type { ReactiveElement } from 'lit';
+import { type SlotControllerArgs, type SlotControllerPublicAPI } from './slot-controller.js';
+export declare class SlotController implements SlotControllerPublicAPI {
+    host: ReactiveElement;
+    static default: symbol;
+    /** @deprecated use `default` */
+    static anonymous: symbol;
+    static attribute: "ssr-hint-has-slotted";
+    static anonymousAttribute: "ssr-hint-has-slotted-default";
+    constructor(host: ReactiveElement, ..._: SlotControllerArgs);
+    hostConnected?(): Promise<void>;
+    private fromAttribute;
+    getSlotted<T extends Element = Element>(..._: string[]): T[];
+    hasSlotted(...names: (string | null)[]): boolean;
+    isEmpty(...names: (string | null)[]): boolean;
+}
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js
new file mode 100644
index 0000000..27cf45e
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js
@@ -0,0 +1,32 @@
+var _a;
+import {} from './slot-controller.js';
+export class SlotController {
+    constructor(host, ..._) {
+        this.host = host;
+        host.addController(this);
+    }
+    fromAttribute(slots) {
+        return (slots ?? '')
+            .split(/[, ]/)
+            .map(x => x.trim());
+    }
+    getSlotted(..._) {
+        return [];
+    }
+    hasSlotted(...names) {
+        const attr = this.host.getAttribute(_a.attribute);
+        const anon = this.host.hasAttribute(_a.anonymousAttribute);
+        const hints = new Set(this.fromAttribute(attr));
+        return names.every(x => x === null ? anon : hints.has(x));
+    }
+    isEmpty(...names) {
+        return !this.hasSlotted(...names);
+    }
+}
+_a = SlotController;
+SlotController.default = Symbol('default slot');
+/** @deprecated use `default` */
+SlotController.anonymous = _a.default;
+SlotController.attribute = 'ssr-hint-has-slotted';
+SlotController.anonymousAttribute = 'ssr-hint-has-slotted-default';
+//# sourceMappingURL=slot-controller-server.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js.map b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js.map
new file mode 100644
index 0000000..2621058
--- /dev/null
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller-server.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"slot-controller-server.js","sourceRoot":"","sources":["slot-controller-server.ts"],"names":[],"mappings":";AACA,OAAO,EAGN,MAAM,sBAAsB,CAAC;AAE9B,MAAM,OAAO,cAAc;IAUzB,YAAmB,IAAqB,EAAE,GAAG,CAAqB;QAA/C,SAAI,GAAJ,IAAI,CAAiB;QACtC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAIO,aAAa,CAAC,KAAoB;QACxC,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC;aACf,KAAK,CAAC,MAAM,CAAC;aACb,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1B,CAAC;IAED,UAAU,CAA8B,GAAG,CAAW;QACpD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,UAAU,CAAC,GAAG,KAAwB;QACpC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAc,CAAC,SAAS,CAAC,CAAC;QAC9D,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAAc,CAAC,kBAAkB,CAAC,CAAC;QACvE,MAAM,KAAK,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;QAChD,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,OAAO,CAAC,GAAG,KAAwB;QACjC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC,CAAC;IACpC,CAAC;;;AAlCa,sBAAO,GAAG,MAAM,CAAC,cAAc,CAA4B,AAApD,CAAqD;AAE1E,gCAAgC;AAClB,wBAAS,GAAW,EAAI,CAAC,OAAO,AAAvB,CAAwB;AAExC,wBAAS,GAAG,sBAA+B,AAAlC,CAAmC;AAE5C,iCAAkB,GAAG,8BAAuC,AAA1C,CAA2C","sourcesContent":["import type { ReactiveElement } from 'lit';\nimport {\n  type SlotControllerArgs,\n  type SlotControllerPublicAPI,\n} from './slot-controller.js';\n\nexport class SlotController implements SlotControllerPublicAPI {\n  public static default = Symbol('default slot') satisfies symbol as symbol;\n\n  /** @deprecated use `default` */\n  public static anonymous: symbol = this.default;\n\n  static attribute = 'ssr-hint-has-slotted' as const;\n\n  static anonymousAttribute = 'ssr-hint-has-slotted-default' as const;\n\n  constructor(public host: ReactiveElement, ..._: SlotControllerArgs) {\n    host.addController(this);\n  }\n\n  hostConnected?(): Promise<void>;\n\n  private fromAttribute(slots: string | null) {\n    return (slots ?? '')\n        .split(/[, ]/)\n        .map(x => x.trim());\n  }\n\n  getSlotted<T extends Element = Element>(..._: string[]): T[] {\n    return [];\n  }\n\n  hasSlotted(...names: (string | null)[]): boolean {\n    const attr = this.host.getAttribute(SlotController.attribute);\n    const anon = this.host.hasAttribute(SlotController.anonymousAttribute);\n    const hints = new Set(this.fromAttribute(attr));\n    return names.every(x => x === null ? anon : hints.has(x));\n  }\n\n  isEmpty(...names: (string | null)[]): boolean {\n    return !this.hasSlotted(...names);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts b/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
index 2a45c34..cbb4f78 100644
--- a/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.d.ts
@@ -1,4 +1,4 @@
-import { type ReactiveController, type ReactiveElement } from 'lit';
+import type { ReactiveController, ReactiveElement } from 'lit';
 interface AnonymousSlot {
     hasContent: boolean;
     elements: Element[];
@@ -9,8 +9,9 @@ interface NamedSlot extends AnonymousSlot {
     initialized: true;
 }
 export type Slot = NamedSlot | AnonymousSlot;
+export type SlotName = string | null;
 export interface SlotsConfig {
-    slots: (string | null)[];
+    slots: SlotName[];
     /**
      * Object mapping new slot name keys to deprecated slot name values
      * @example `pf-modal--header` is deprecated in favour of `header`
@@ -25,13 +26,55 @@ export interface SlotsConfig {
      */
     deprecations?: Record<string, string>;
 }
-export declare class SlotController implements ReactiveController {
+export type SlotControllerArgs = [SlotsConfig] | SlotName[];
+export declare function isObjectSpread(config: SlotControllerArgs): config is [SlotsConfig];
+export declare class SlotControllerPublicAPI implements ReactiveController {
+    static default: symbol;
+    host: ReactiveElement;
+    constructor(host: ReactiveElement, ...args: SlotControllerArgs);
+    hostConnected?(): Promise<void>;
+    hostDisconnected?(): void;
+    hostUpdated?(): void;
+    /**
+     * Given a slot name or slot names, returns elements assigned to the requested slots as an array.
+     * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).
+     * @param slotNames slots to query
+     * @example Get header-slotted elements
+     *          ```js
+     *          this.getSlotted('header')
+     *          ```
+     * @example Get header- and footer-slotted elements
+     *          ```js
+     *          this.getSlotted('header', 'footer')
+     *          ```
+     * @example Get default-slotted elements
+     *          ```js
+     *          this.getSlotted();
+     *          ```
+     */
+    getSlotted<T extends Element = Element>(...slotNames: string[]): T[];
+    /**
+     * Returns a boolean statement of whether or not any of those slots exists in the light DOM.
+     * @param names The slot names to check.
+     * @example this.hasSlotted('header');
+     */
+    hasSlotted(...names: (string | null | undefined)[]): boolean;
+    /**
+     * Whether or not all the requested slots are empty.
+     * @param  names The slot names to query.  If no value is provided, it returns the default slot.
+     * @example this.isEmpty('header', 'footer');
+     * @example this.isEmpty();
+     * @returns
+     */
+    isEmpty(...names: (string | null | undefined)[]): boolean;
+}
+export declare class SlotController implements SlotControllerPublicAPI {
     #private;
     host: ReactiveElement;
     static default: symbol;
     /** @deprecated use `default` */
     static anonymous: symbol;
-    constructor(host: ReactiveElement, ...config: ([SlotsConfig] | (string | null)[]));
+    constructor(host: ReactiveElement, ...args: SlotControllerArgs);
     hostConnected(): Promise<void>;
     hostUpdated(): void;
     hostDisconnected(): void;
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
index 42b0657..2cc4f4a 100644
--- a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js
@@ -1,8 +1,6 @@
-var _SlotController_instances, _a, _SlotController_nodes, _SlotController_logger, _SlotController_firstUpdated, _SlotController_mo, _SlotController_slotNames, _SlotController_deprecations, _SlotController_onSlotChange, _SlotController_onMutation, _SlotController_getChildrenForSlot, _SlotController_initSlot;
+var _SlotController_instances, _a, _SlotController_nodes, _SlotController_slotMapInitialized, _SlotController_slotNames, _SlotController_deprecations, _SlotController_mo, _SlotController_initialize, _SlotController_initSlotMap, _SlotController_getSlotElement, _SlotController_getChildrenForSlot;
 import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
-import { isServer } from 'lit';
-import { Logger } from './logger.js';
-function isObjectConfigSpread(config) {
+export function isObjectSpread(config) {
     return config.length === 1 && typeof config[0] === 'object' && config[0] !== null;
 }
 /**
@@ -13,76 +11,32 @@ function isObjectConfigSpread(config) {
 const isSlot = (n) => (child) => n === SlotController.default ? !child.hasAttribute('slot')
     : child.getAttribute('slot') === n;
 export class SlotController {
-    constructor(host, ...config) {
+    constructor(host, ...args) {
         _SlotController_instances.add(this);
         this.host = host;
         _SlotController_nodes.set(this, new Map());
-        _SlotController_logger.set(this, void 0);
-        _SlotController_firstUpdated.set(this, false);
-        _SlotController_mo.set(this, new MutationObserver(records => __classPrivateFieldGet(this, _SlotController_onMutation, "f").call(this, records)));
-        _SlotController_slotNames.set(this, void 0);
+        _SlotController_slotMapInitialized.set(this, false);
+        _SlotController_slotNames.set(this, []);
         _SlotController_deprecations.set(this, {});
-        _SlotController_onSlotChange.set(this, (event) => {
-            const slotName = event.target.name;
-            __classPrivateFieldGet(this, _SlotController_initSlot, "f").call(this, slotName);
-            this.host.requestUpdate();
-        });
-        _SlotController_onMutation.set(this, async (records) => {
-            const changed = [];
-            for (const { addedNodes, removedNodes } of records) {
-                for (const node of [...addedNodes, ...removedNodes]) {
-                    if (node instanceof HTMLElement && node.slot) {
-                        __classPrivateFieldGet(this, _SlotController_initSlot, "f").call(this, node.slot);
-                        changed.push(node.slot);
-                    }
-                }
-            }
-            this.host.requestUpdate();
-        });
-        _SlotController_initSlot.set(this, (slotName) => {
-            const name = slotName || _a.default;
-            const elements = __classPrivateFieldGet(this, _SlotController_nodes, "f").get(name)?.slot?.assignedElements?.()
-                ?? __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getChildrenForSlot).call(this, name);
-            const selector = slotName ? `slot[name="${slotName}"]` : 'slot:not([name])';
-            const slot = this.host.shadowRoot?.querySelector?.(selector) ?? null;
-            const nodes = slot?.assignedNodes?.();
-            const hasContent = !!elements.length || !!nodes?.filter(x => x.textContent?.trim()).length;
-            __classPrivateFieldGet(this, _SlotController_nodes, "f").set(name, { elements, name: slotName ?? '', hasContent, slot });
-            __classPrivateFieldGet(this, _SlotController_logger, "f").debug(slotName, hasContent);
-        });
-        __classPrivateFieldSet(this, _SlotController_logger, new Logger(this.host), "f");
-        if (isObjectConfigSpread(config)) {
-            const [{ slots, deprecations }] = config;
-            __classPrivateFieldSet(this, _SlotController_slotNames, slots, "f");
-            __classPrivateFieldSet(this, _SlotController_deprecations, deprecations ?? {}, "f");
-        }
-        else if (config.length >= 1) {
-            __classPrivateFieldSet(this, _SlotController_slotNames, config, "f");
-            __classPrivateFieldSet(this, _SlotController_deprecations, {}, "f");
-        }
-        else {
+        _SlotController_mo.set(this, new MutationObserver(__classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).bind(this)));
+        __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initialize).call(this, ...args);
+        host.addController(this);
+        if (!__classPrivateFieldGet(this, _SlotController_slotNames, "f").length) {
             __classPrivateFieldSet(this, _SlotController_slotNames, [null], "f");
         }
-        host.addController(this);
     }
     async hostConnected() {
-        this.host.addEventListener('slotchange', __classPrivateFieldGet(this, _SlotController_onSlotChange, "f"));
-        __classPrivateFieldSet(this, _SlotController_firstUpdated, false, "f");
         __classPrivateFieldGet(this, _SlotController_mo, "f").observe(this.host, { childList: true });
         // Map the defined slots into an object that is easier to query
         __classPrivateFieldGet(this, _SlotController_nodes, "f").clear();
-        // Loop over the properties provided by the schema
-        __classPrivateFieldGet(this, _SlotController_slotNames, "f").forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-        Object.values(__classPrivateFieldGet(this, _SlotController_deprecations, "f")).forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-        this.host.requestUpdate();
+        __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).call(this);
         // insurance for framework integrations
         await this.host.updateComplete;
         this.host.requestUpdate();
     }
     hostUpdated() {
-        if (!__classPrivateFieldGet(this, _SlotController_firstUpdated, "f")) {
-            __classPrivateFieldGet(this, _SlotController_slotNames, "f").forEach(__classPrivateFieldGet(this, _SlotController_initSlot, "f"));
-            __classPrivateFieldSet(this, _SlotController_firstUpdated, true, "f");
+        if (!__classPrivateFieldGet(this, _SlotController_slotMapInitialized, "f")) {
+            __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_initSlotMap).call(this);
         }
     }
     hostDisconnected() {
@@ -119,20 +73,11 @@ export class SlotController {
      * @example this.hasSlotted('header');
      */
     hasSlotted(...names) {
-        if (isServer) {
-            return this.host
-                .getAttribute('ssr-hint-has-slotted')
-                ?.split(',')
-                .map(name => name.trim())
-                .some(name => names.includes(name === 'default' ? null : name)) ?? false;
-        }
-        else {
-            const slotNames = Array.from(names, x => x == null ? _a.default : x);
-            if (!slotNames.length) {
-                slotNames.push(_a.default);
-            }
-            return slotNames.some(x => __classPrivateFieldGet(this, _SlotController_nodes, "f").get(x)?.hasContent ?? false);
+        const slotNames = Array.from(names, x => x == null ? _a.default : x);
+        if (!slotNames.length) {
+            slotNames.push(_a.default);
         }
+        return slotNames.some(x => __classPrivateFieldGet(this, _SlotController_nodes, "f").get(x)?.hasContent ?? false);
     }
     /**
      * Whether or not all the requested slots are empty.
@@ -145,9 +90,40 @@ export class SlotController {
         return !this.hasSlotted(...names);
     }
 }
-_a = SlotController, _SlotController_nodes = new WeakMap(), _SlotController_logger = new WeakMap(), _SlotController_firstUpdated = new WeakMap(), _SlotController_mo = new WeakMap(), _SlotController_slotNames = new WeakMap(), _SlotController_deprecations = new WeakMap(), _SlotController_onSlotChange = new WeakMap(), _SlotController_onMutation = new WeakMap(), _SlotController_initSlot = new WeakMap(), _SlotController_instances = new WeakSet(), _SlotController_getChildrenForSlot = function _SlotController_getChildrenForSlot(name) {
-    const children = Array.from(this.host.children);
-    return children.filter(isSlot(name));
+_a = SlotController, _SlotController_nodes = new WeakMap(), _SlotController_slotMapInitialized = new WeakMap(), _SlotController_slotNames = new WeakMap(), _SlotController_deprecations = new WeakMap(), _SlotController_mo = new WeakMap(), _SlotController_instances = new WeakSet(), _SlotController_initialize = function _SlotController_initialize(...config) {
+    if (isObjectSpread(config)) {
+        const [{ slots, deprecations }] = config;
+        __classPrivateFieldSet(this, _SlotController_slotNames, slots, "f");
+        __classPrivateFieldSet(this, _SlotController_deprecations, deprecations ?? {}, "f");
+    }
+    else if (config.length >= 1) {
+        __classPrivateFieldSet(this, _SlotController_slotNames, config, "f");
+        __classPrivateFieldSet(this, _SlotController_deprecations, {}, "f");
+    }
+}, _SlotController_initSlotMap = function _SlotController_initSlotMap() {
+    // Loop over the properties provided by the schema
+    for (const slotName of __classPrivateFieldGet(this, _SlotController_slotNames, "f")
+        .concat(Object.values(__classPrivateFieldGet(this, _SlotController_deprecations, "f")))) {
+        const slotId = slotName || _a.default;
+        const name = slotName ?? '';
+        const elements = __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getChildrenForSlot).call(this, slotId);
+        const slot = __classPrivateFieldGet(this, _SlotController_instances, "m", _SlotController_getSlotElement).call(this, slotId);
+        const hasContent = !!elements.length || !!slot?.assignedNodes?.()?.filter(x => x.textContent?.trim()).length;
+        __classPrivateFieldGet(this, _SlotController_nodes, "f").set(slotId, { elements, name, hasContent, slot });
+    }
+    this.host.requestUpdate();
+    __classPrivateFieldSet(this, _SlotController_slotMapInitialized, true, "f");
+}, _SlotController_getSlotElement = function _SlotController_getSlotElement(slotId) {
+    const selector = slotId === _a.default ? 'slot:not([name])' : `slot[name="${slotId}"]`;
+    return this.host.shadowRoot?.querySelector?.(selector) ?? null;
+}, _SlotController_getChildrenForSlot = function _SlotController_getChildrenForSlot(name) {
+    if (__classPrivateFieldGet(this, _SlotController_nodes, "f").has(name)) {
+        return (__classPrivateFieldGet(this, _SlotController_nodes, "f").get(name).slot?.assignedElements?.() ?? []);
+    }
+    else {
+        const children = Array.from(this.host.children);
+        return children.filter(isSlot(name));
+    }
 };
 SlotController.default = Symbol('default slot');
 /** @deprecated use `default` */
diff --git a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js.map b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js.map
index 5d3a50a..d4535ed 100644
--- a/node_modules/@patternfly/pfe-core/controllers/slot-controller.js.map
+++ b/node_modules/@patternfly/pfe-core/controllers/slot-controller.js.map
@@ -1 +1 @@
-{"version":3,"file":"slot-controller.js","sourceRoot":"","sources":["slot-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { isServer, type ReactiveController, type ReactiveElement } from 'lit';\n\nimport { Logger } from './logger.js';\n\ninterface AnonymousSlot {\n  hasContent: boolean;\n  elements: Element[];\n  slot: HTMLSlotElement | null;\n}\n\ninterface NamedSlot extends AnonymousSlot {\n  name: string;\n  initialized: true;\n}\n\nexport type Slot = NamedSlot | AnonymousSlot;\n\nexport interface SlotsConfig {\n  slots: (string | null)[];\n  /**\n   * Object mapping new slot name keys to deprecated slot name values\n   * @example `pf-modal--header` is deprecated in favour of `header`\n   * ```js\n   * new SlotController(this, {\n   *   slots: ['header'],\n   *   deprecations: {\n   *     'header': 'pf-modal--header'\n   *   }\n   * })\n   * ```\n   */\n  deprecations?: Record<string, string>;\n}\n\nfunction isObjectConfigSpread(\n  config: ([SlotsConfig] | (string | null)[]),\n): config is [SlotsConfig] {\n  return config.length === 1 && typeof config[0] === 'object' && config[0] !== null;\n}\n\n/**\n * If it's a named slot, return its children,\n * for the default slot, look for direct children not assigned to a slot\n * @param n slot name\n */\nconst isSlot =\n  <T extends Element = Element>(n: string | typeof SlotController.default) =>\n    (child: Element): child is T =>\n        n === SlotController.default ? !child.hasAttribute('slot')\n      : child.getAttribute('slot') === n;\n\nexport class SlotController implements ReactiveController {\n  public static default = Symbol('default slot') satisfies symbol as symbol;\n\n  /** @deprecated use `default` */\n  public static anonymous: symbol = this.default;\n\n  #nodes = new Map<string | typeof SlotController.default, Slot>();\n\n  #logger: Logger;\n\n  #firstUpdated = false;\n\n  #mo = new MutationObserver(records => this.#onMutation(records));\n\n  #slotNames: (string | null)[];\n\n  #deprecations: Record<string, string> = {};\n\n  constructor(public host: ReactiveElement, ...config: ([SlotsConfig] | (string | null)[])) {\n    this.#logger = new Logger(this.host);\n\n    if (isObjectConfigSpread(config)) {\n      const [{ slots, deprecations }] = config;\n      this.#slotNames = slots;\n      this.#deprecations = deprecations ?? {};\n    } else if (config.length >= 1) {\n      this.#slotNames = config;\n      this.#deprecations = {};\n    } else {\n      this.#slotNames = [null];\n    }\n\n\n    host.addController(this);\n  }\n\n  async hostConnected(): Promise<void> {\n    this.host.addEventListener('slotchange', this.#onSlotChange as EventListener);\n    this.#firstUpdated = false;\n    this.#mo.observe(this.host, { childList: true });\n    // Map the defined slots into an object that is easier to query\n    this.#nodes.clear();\n    // Loop over the properties provided by the schema\n    this.#slotNames.forEach(this.#initSlot);\n    Object.values(this.#deprecations).forEach(this.#initSlot);\n    this.host.requestUpdate();\n    // insurance for framework integrations\n    await this.host.updateComplete;\n    this.host.requestUpdate();\n  }\n\n  hostUpdated(): void {\n    if (!this.#firstUpdated) {\n      this.#slotNames.forEach(this.#initSlot);\n      this.#firstUpdated = true;\n    }\n  }\n\n  hostDisconnected(): void {\n    this.#mo.disconnect();\n  }\n\n  /**\n   * Given a slot name or slot names, returns elements assigned to the requested slots as an array.\n   * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).\n   * @param slotNames slots to query\n   * @example Get header-slotted elements\n   *          ```js\n   *          this.getSlotted('header')\n   *          ```\n   * @example Get header- and footer-slotted elements\n   *          ```js\n   *          this.getSlotted('header', 'footer')\n   *          ```\n   * @example Get default-slotted elements\n   *          ```js\n   *          this.getSlotted();\n   *          ```\n   */\n  getSlotted<T extends Element = Element>(...slotNames: string[]): T[] {\n    if (!slotNames.length) {\n      return (this.#nodes.get(SlotController.default)?.elements ?? []) as T[];\n    } else {\n      return slotNames.flatMap(slotName =>\n        this.#nodes.get(slotName)?.elements ?? []) as T[];\n    }\n  }\n\n  /**\n   * Returns a boolean statement of whether or not any of those slots exists in the light DOM.\n   * @param names The slot names to check.\n   * @example this.hasSlotted('header');\n   */\n  hasSlotted(...names: (string | null | undefined)[]): boolean {\n    if (isServer) {\n      return this.host\n          .getAttribute('ssr-hint-has-slotted')\n          ?.split(',')\n          .map(name => name.trim())\n          .some(name => names.includes(name === 'default' ? null : name)) ?? false;\n    } else {\n      const slotNames = Array.from(names, x => x == null ? SlotController.default : x);\n      if (!slotNames.length) {\n        slotNames.push(SlotController.default);\n      }\n      return slotNames.some(x => this.#nodes.get(x)?.hasContent ?? false);\n    }\n  }\n\n  /**\n   * Whether or not all the requested slots are empty.\n   * @param  names The slot names to query.  If no value is provided, it returns the default slot.\n   * @example this.isEmpty('header', 'footer');\n   * @example this.isEmpty();\n   * @returns\n   */\n  isEmpty(...names: (string | null | undefined)[]): boolean {\n    return !this.hasSlotted(...names);\n  }\n\n  #onSlotChange = (event: Event & { target: HTMLSlotElement }) => {\n    const slotName = event.target.name;\n    this.#initSlot(slotName);\n    this.host.requestUpdate();\n  };\n\n  #onMutation = async (records: MutationRecord[]) => {\n    const changed = [];\n    for (const { addedNodes, removedNodes } of records) {\n      for (const node of [...addedNodes, ...removedNodes]) {\n        if (node instanceof HTMLElement && node.slot) {\n          this.#initSlot(node.slot);\n          changed.push(node.slot);\n        }\n      }\n    }\n    this.host.requestUpdate();\n  };\n\n  #getChildrenForSlot<T extends Element = Element>(\n    name: string | typeof SlotController.default,\n  ): T[] {\n    const children = Array.from(this.host.children) as T[];\n    return children.filter(isSlot(name));\n  }\n\n  #initSlot = (slotName: string | null) => {\n    const name = slotName || SlotController.default;\n    const elements = this.#nodes.get(name)?.slot?.assignedElements?.()\n      ?? this.#getChildrenForSlot(name);\n    const selector = slotName ? `slot[name=\"${slotName}\"]` : 'slot:not([name])';\n    const slot = this.host.shadowRoot?.querySelector?.<HTMLSlotElement>(selector) ?? null;\n    const nodes = slot?.assignedNodes?.();\n    const hasContent = !!elements.length || !!nodes?.filter(x => x.textContent?.trim()).length;\n    this.#nodes.set(name, { elements, name: slotName ?? '', hasContent, slot });\n    this.#logger.debug(slotName, hasContent);\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"slot-controller.js","sourceRoot":"","sources":["slot-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveController, ReactiveElement } from 'lit';\n\ninterface AnonymousSlot {\n  hasContent: boolean;\n  elements: Element[];\n  slot: HTMLSlotElement | null;\n}\n\ninterface NamedSlot extends AnonymousSlot {\n  name: string;\n  initialized: true;\n}\n\nexport type Slot = NamedSlot | AnonymousSlot;\n\nexport type SlotName = string | null;\n\nexport interface SlotsConfig {\n  slots: SlotName[];\n  /**\n   * Object mapping new slot name keys to deprecated slot name values\n   * @example `pf-modal--header` is deprecated in favour of `header`\n   * ```js\n   * new SlotController(this, {\n   *   slots: ['header'],\n   *   deprecations: {\n   *     'header': 'pf-modal--header'\n   *   }\n   * })\n   * ```\n   */\n  deprecations?: Record<string, string>;\n}\n\nexport type SlotControllerArgs = [SlotsConfig] | SlotName[];\n\nexport function isObjectSpread(config: SlotControllerArgs): config is [SlotsConfig] {\n  return config.length === 1 && typeof config[0] === 'object' && config[0] !== null;\n}\n\n/**\n * If it's a named slot, return its children,\n * for the default slot, look for direct children not assigned to a slot\n * @param n slot name\n */\nconst isSlot =\n  <T extends Element = Element>(n: string | typeof SlotController.default) =>\n    (child: Element): child is T =>\n        n === SlotController.default ? !child.hasAttribute('slot')\n      : child.getAttribute('slot') === n;\n\nexport declare class SlotControllerPublicAPI implements ReactiveController {\n  static default: symbol;\n\n  public host: ReactiveElement;\n\n  constructor(host: ReactiveElement, ...args: SlotControllerArgs);\n\n  hostConnected?(): Promise<void>;\n\n  hostDisconnected?(): void;\n\n  hostUpdated?(): void;\n\n  /**\n   * Given a slot name or slot names, returns elements assigned to the requested slots as an array.\n   * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).\n   * @param slotNames slots to query\n   * @example Get header-slotted elements\n   *          ```js\n   *          this.getSlotted('header')\n   *          ```\n   * @example Get header- and footer-slotted elements\n   *          ```js\n   *          this.getSlotted('header', 'footer')\n   *          ```\n   * @example Get default-slotted elements\n   *          ```js\n   *          this.getSlotted();\n   *          ```\n   */\n  getSlotted<T extends Element = Element>(...slotNames: string[]): T[];\n\n  /**\n   * Returns a boolean statement of whether or not any of those slots exists in the light DOM.\n   * @param names The slot names to check.\n   * @example this.hasSlotted('header');\n   */\n  hasSlotted(...names: (string | null | undefined)[]): boolean;\n\n  /**\n   * Whether or not all the requested slots are empty.\n   * @param  names The slot names to query.  If no value is provided, it returns the default slot.\n   * @example this.isEmpty('header', 'footer');\n   * @example this.isEmpty();\n   * @returns\n   */\n  isEmpty(...names: (string | null | undefined)[]): boolean;\n}\n\nexport class SlotController implements SlotControllerPublicAPI {\n  public static default = Symbol('default slot') satisfies symbol as symbol;\n\n  /** @deprecated use `default` */\n  public static anonymous: symbol = this.default;\n\n  #nodes = new Map<string | typeof SlotController.default, Slot>();\n\n  #slotMapInitialized = false;\n\n  #slotNames: (string | null)[] = [];\n\n  #deprecations: Record<string, string> = {};\n\n  #mo = new MutationObserver(this.#initSlotMap.bind(this));\n\n  constructor(public host: ReactiveElement, ...args: SlotControllerArgs) {\n    this.#initialize(...args);\n    host.addController(this);\n    if (!this.#slotNames.length) {\n      this.#slotNames = [null];\n    }\n  }\n\n  #initialize(...config: SlotControllerArgs) {\n    if (isObjectSpread(config)) {\n      const [{ slots, deprecations }] = config;\n      this.#slotNames = slots;\n      this.#deprecations = deprecations ?? {};\n    } else if (config.length >= 1) {\n      this.#slotNames = config;\n      this.#deprecations = {};\n    }\n  }\n\n  async hostConnected(): Promise<void> {\n    this.#mo.observe(this.host, { childList: true });\n    // Map the defined slots into an object that is easier to query\n    this.#nodes.clear();\n    this.#initSlotMap();\n    // insurance for framework integrations\n    await this.host.updateComplete;\n    this.host.requestUpdate();\n  }\n\n  hostUpdated(): void {\n    if (!this.#slotMapInitialized) {\n      this.#initSlotMap();\n    }\n  }\n\n  hostDisconnected(): void {\n    this.#mo.disconnect();\n  }\n\n  #initSlotMap() {\n    // Loop over the properties provided by the schema\n    for (const slotName of this.#slotNames\n        .concat(Object.values(this.#deprecations))) {\n      const slotId = slotName || SlotController.default;\n      const name = slotName ?? '';\n      const elements = this.#getChildrenForSlot(slotId);\n      const slot = this.#getSlotElement(slotId);\n      const hasContent =\n        !!elements.length || !!slot?.assignedNodes?.()?.filter(x => x.textContent?.trim()).length;\n      this.#nodes.set(slotId, { elements, name, hasContent, slot });\n    }\n    this.host.requestUpdate();\n    this.#slotMapInitialized = true;\n  }\n\n  #getSlotElement(slotId: string | symbol) {\n    const selector =\n      slotId === SlotController.default ? 'slot:not([name])' : `slot[name=\"${slotId as string}\"]`;\n    return this.host.shadowRoot?.querySelector?.<HTMLSlotElement>(selector) ?? null;\n  }\n\n  #getChildrenForSlot<T extends Element = Element>(\n    name: string | typeof SlotController.default,\n  ): T[] {\n    if (this.#nodes.has(name)) {\n      return (this.#nodes.get(name)!.slot?.assignedElements?.() ?? []) as T[];\n    } else {\n      const children = Array.from(this.host.children) as T[];\n      return children.filter(isSlot(name));\n    }\n  }\n\n  /**\n   * Given a slot name or slot names, returns elements assigned to the requested slots as an array.\n   * If no value is provided, it returns all children not assigned to a slot (without a slot attribute).\n   * @param slotNames slots to query\n   * @example Get header-slotted elements\n   *          ```js\n   *          this.getSlotted('header')\n   *          ```\n   * @example Get header- and footer-slotted elements\n   *          ```js\n   *          this.getSlotted('header', 'footer')\n   *          ```\n   * @example Get default-slotted elements\n   *          ```js\n   *          this.getSlotted();\n   *          ```\n   */\n  getSlotted<T extends Element = Element>(...slotNames: string[]): T[] {\n    if (!slotNames.length) {\n      return (this.#nodes.get(SlotController.default)?.elements ?? []) as T[];\n    } else {\n      return slotNames.flatMap(slotName =>\n        this.#nodes.get(slotName)?.elements ?? []) as T[];\n    }\n  }\n\n  /**\n   * Returns a boolean statement of whether or not any of those slots exists in the light DOM.\n   * @param names The slot names to check.\n   * @example this.hasSlotted('header');\n   */\n  hasSlotted(...names: (string | null | undefined)[]): boolean {\n    const slotNames = Array.from(names, x => x == null ? SlotController.default : x);\n    if (!slotNames.length) {\n      slotNames.push(SlotController.default);\n    }\n    return slotNames.some(x => this.#nodes.get(x)?.hasContent ?? false);\n  }\n\n  /**\n   * Whether or not all the requested slots are empty.\n   * @param  names The slot names to query.  If no value is provided, it returns the default slot.\n   * @example this.isEmpty('header', 'footer');\n   * @example this.isEmpty();\n   * @returns\n   */\n  isEmpty(...names: (string | null | undefined)[]): boolean {\n    return !this.hasSlotted(...names);\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/custom-elements.json b/node_modules/@patternfly/pfe-core/custom-elements.json
index 287526c..aabde1c 100644
--- a/node_modules/@patternfly/pfe-core/custom-elements.json
+++ b/node_modules/@patternfly/pfe-core/custom-elements.json
@@ -8488,6 +8488,15 @@
                 }
               }
             },
+            {
+              "kind": "method",
+              "name": "hostDisconnected",
+              "return": {
+                "type": {
+                  "text": "void"
+                }
+              }
+            },
             {
               "kind": "method",
               "name": "setActive",
@@ -8546,6 +8555,10 @@
               "kind": "method",
               "name": "hostConnected"
             },
+            {
+              "kind": "method",
+              "name": "hostDisconnected"
+            },
             {
               "kind": "method",
               "name": "setActive",
@@ -8587,122 +8600,294 @@
           "members": [
             {
               "kind": "field",
-              "name": "#tagNames",
+              "name": "#instances",
               "privacy": "private",
-              "type": {
-                "text": "string[]"
-              }
+              "static": true,
+              "default": "new Set<ScrollSpyController>"
             },
             {
               "kind": "field",
-              "name": "#activeAttribute",
-              "privacy": "private",
-              "type": {
-                "text": "string"
-              }
-            },
+              "name": "",
+              "static": true
+            }
+          ]
+        }
+      ],
+      "exports": [
+        {
+          "kind": "js",
+          "name": "ScrollSpyController",
+          "declaration": {
+            "name": "ScrollSpyController",
+            "module": "controllers/scroll-spy-controller.ts"
+          }
+        }
+      ]
+    },
+    {
+      "kind": "javascript-module",
+      "path": "controllers/slot-controller-server.d.ts",
+      "declarations": [
+        {
+          "kind": "class",
+          "description": "",
+          "name": "SlotController",
+          "members": [
             {
               "kind": "field",
-              "name": "#io",
-              "privacy": "private",
+              "name": "host",
               "type": {
-                "text": "IntersectionObserver | undefined"
+                "text": "ReactiveElement"
               }
             },
             {
               "kind": "field",
-              "name": "#passedLinks",
-              "privacy": "private",
-              "default": "new Set<Element>()",
-              "description": "Which link's targets have already scrolled past?"
+              "name": "default",
+              "type": {
+                "text": "symbol"
+              },
+              "static": true
             },
             {
               "kind": "field",
-              "name": "#force",
-              "privacy": "private",
+              "name": "anonymous",
               "type": {
-                "text": "boolean"
+                "text": "symbol"
               },
-              "default": "false",
-              "description": "Ignore intersections?"
+              "static": true,
+              "deprecated": "use `default`"
             },
             {
               "kind": "field",
-              "name": "#intersected",
-              "privacy": "private",
+              "name": "attribute",
               "type": {
-                "text": "boolean"
+                "text": "\"ssr-hint-has-slotted\""
               },
-              "default": "false",
-              "description": "Has the intersection observer found an element?"
+              "static": true
             },
             {
               "kind": "field",
-              "name": "#root",
-              "privacy": "private",
+              "name": "anonymousAttribute",
               "type": {
-                "text": "ScrollSpyControllerOptions['root']"
-              }
+                "text": "\"ssr-hint-has-slotted-default\""
+              },
+              "static": true
             },
             {
-              "kind": "field",
-              "name": "#rootMargin",
-              "privacy": "private",
-              "type": {
-                "text": "string | undefined"
+              "kind": "method",
+              "name": "hostConnected",
+              "return": {
+                "type": {
+                  "text": "Promise<void>"
+                }
               }
             },
             {
               "kind": "field",
-              "name": "#threshold",
-              "privacy": "private",
-              "type": {
-                "text": "number | number[]"
-              }
+              "name": "fromAttribute",
+              "privacy": "private"
             },
             {
-              "kind": "field",
-              "name": "#getRootNode",
-              "privacy": "private",
-              "type": {
-                "text": "() => Node"
-              }
+              "kind": "method",
+              "name": "getSlotted",
+              "return": {
+                "type": {
+                  "text": "T[]"
+                }
+              },
+              "parameters": [
+                {
+                  "name": "_",
+                  "type": {
+                    "text": "string[]"
+                  }
+                }
+              ]
             },
             {
-              "kind": "field",
-              "name": "#getHash",
-              "privacy": "private",
-              "type": {
-                "text": "(el: Element) => string | null"
-              }
+              "kind": "method",
+              "name": "hasSlotted",
+              "return": {
+                "type": {
+                  "text": "boolean"
+                }
+              },
+              "parameters": [
+                {
+                  "name": "names",
+                  "type": {
+                    "text": "(string | null)[]"
+                  }
+                }
+              ]
+            },
+            {
+              "kind": "method",
+              "name": "isEmpty",
+              "return": {
+                "type": {
+                  "text": "boolean"
+                }
+              },
+              "parameters": [
+                {
+                  "name": "names",
+                  "type": {
+                    "text": "(string | null)[]"
+                  }
+                }
+              ]
+            }
+          ]
+        }
+      ],
+      "exports": [
+        {
+          "kind": "js",
+          "name": "SlotController",
+          "declaration": {
+            "name": "SlotController",
+            "module": "controllers/slot-controller-server.d.ts"
+          }
+        }
+      ]
+    },
+    {
+      "kind": "javascript-module",
+      "path": "controllers/slot-controller-server.js",
+      "declarations": [
+        {
+          "kind": "class",
+          "description": "",
+          "name": "SlotController",
+          "members": [
+            {
+              "kind": "method",
+              "name": "fromAttribute",
+              "parameters": [
+                {
+                  "name": "slots"
+                }
+              ]
+            },
+            {
+              "kind": "method",
+              "name": "getSlotted",
+              "parameters": [
+                {
+                  "name": "_"
+                }
+              ]
+            },
+            {
+              "kind": "method",
+              "name": "hasSlotted",
+              "parameters": [
+                {
+                  "name": "names"
+                }
+              ]
+            },
+            {
+              "kind": "method",
+              "name": "isEmpty",
+              "parameters": [
+                {
+                  "name": "names"
+                }
+              ]
             },
             {
               "kind": "field",
-              "name": "#linkChildren",
-              "privacy": "private",
-              "type": {
-                "text": "Element[]"
-              }
+              "name": "host",
+              "default": "host"
+            }
+          ]
+        }
+      ],
+      "exports": [
+        {
+          "kind": "js",
+          "name": "SlotController",
+          "declaration": {
+            "name": "SlotController",
+            "module": "controllers/slot-controller-server.js"
+          }
+        }
+      ]
+    },
+    {
+      "kind": "javascript-module",
+      "path": "controllers/slot-controller-server.ts",
+      "declarations": [
+        {
+          "kind": "class",
+          "description": "",
+          "name": "SlotController",
+          "members": [
+            {
+              "kind": "field",
+              "name": "default",
+              "privacy": "public",
+              "static": true
             },
             {
               "kind": "field",
-              "name": "root",
+              "name": "satisfies"
+            }
+          ]
+        }
+      ],
+      "exports": [
+        {
+          "kind": "js",
+          "name": "SlotController",
+          "declaration": {
+            "name": "SlotController",
+            "module": "controllers/slot-controller-server.ts"
+          }
+        }
+      ]
+    },
+    {
+      "kind": "javascript-module",
+      "path": "controllers/slot-controller.d.ts",
+      "declarations": [
+        {
+          "kind": "function",
+          "name": "isObjectSpread",
+          "return": {
+            "type": {
+              "text": "config is [SlotsConfig]"
+            }
+          },
+          "parameters": [
+            {
+              "name": "config",
               "type": {
-                "text": "Element | Document | null | undefined"
+                "text": "SlotControllerArgs"
               }
-            },
+            }
+          ]
+        },
+        {
+          "kind": "class",
+          "description": "",
+          "name": "SlotControllerPublicAPI",
+          "members": [
             {
               "kind": "field",
-              "name": "rootMargin",
+              "name": "default",
               "type": {
-                "text": "string | undefined"
-              }
+                "text": "symbol"
+              },
+              "static": true
             },
             {
               "kind": "field",
-              "name": "threshold",
+              "name": "host",
               "type": {
-                "text": "number | number[]"
+                "text": "ReactiveElement"
               }
             },
             {
@@ -8710,108 +8895,87 @@
               "name": "hostConnected",
               "return": {
                 "type": {
-                  "text": "void"
+                  "text": "Promise<void>"
                 }
               }
             },
             {
               "kind": "method",
-              "name": "#initIo"
+              "name": "hostDisconnected",
+              "return": {
+                "type": {
+                  "text": "void"
+                }
+              }
             },
             {
               "kind": "method",
-              "name": "#markPassed",
-              "parameters": [
-                {
-                  "name": "link",
-                  "type": {
-                    "text": "Element"
-                  }
-                },
-                {
-                  "name": "force",
-                  "type": {
-                    "text": "boolean"
-                  }
+              "name": "hostUpdated",
+              "return": {
+                "type": {
+                  "text": "void"
                 }
-              ]
+              }
             },
             {
               "kind": "method",
-              "name": "#setActive",
+              "name": "getSlotted",
+              "return": {
+                "type": {
+                  "text": "T[]"
+                }
+              },
               "parameters": [
                 {
-                  "name": "link",
-                  "optional": true,
+                  "name": "slotNames",
                   "type": {
-                    "text": "EventTarget | null"
-                  }
+                    "text": "string[]"
+                  },
+                  "description": "slots to query"
                 }
-              ]
-            },
-            {
-              "kind": "method",
-              "name": "#nextIntersection"
+              ],
+              "description": "Given a slot name or slot names, returns elements assigned to the requested slots as an array.\nIf no value is provided, it returns all children not assigned to a slot (without a slot attribute)."
             },
             {
               "kind": "method",
-              "name": "#onIo",
+              "name": "hasSlotted",
+              "return": {
+                "type": {
+                  "text": "boolean"
+                }
+              },
               "parameters": [
                 {
-                  "name": "entries",
+                  "name": "names",
                   "type": {
-                    "text": "IntersectionObserverEntry[]"
-                  }
+                    "text": "(string | null | undefined)[]"
+                  },
+                  "description": "The slot names to check."
                 }
-              ]
+              ],
+              "description": "Returns a boolean statement of whether or not any of those slots exists in the light DOM."
             },
             {
               "kind": "method",
-              "name": "setActive",
-              "privacy": "public",
+              "name": "isEmpty",
               "return": {
                 "type": {
-                  "text": "Promise<void>"
+                  "text": ""
                 }
               },
               "parameters": [
                 {
-                  "name": "link",
+                  "name": "names",
                   "type": {
-                    "text": "EventTarget | null"
+                    "text": "(string | null | undefined)[]"
                   },
-                  "description": "usually an `<a>`"
+                  "description": "The slot names to query.  If no value is provided, it returns the default slot."
                 }
               ],
-              "description": "Explicitly set the active item"
-            },
-            {
-              "kind": "field",
-              "type": {
-                "text": "ReactiveControllerHost & HTMLElement",
-                "name": "ReactiveControllerHost & HTMLElement"
-              },
-              "name": "host",
-              "privacy": "private"
+              "description": "Whether or not all the requested slots are empty."
             }
           ]
-        }
-      ],
-      "exports": [
-        {
-          "kind": "js",
-          "name": "ScrollSpyController",
-          "declaration": {
-            "name": "ScrollSpyController",
-            "module": "controllers/scroll-spy-controller.ts"
-          }
-        }
-      ]
-    },
-    {
-      "kind": "javascript-module",
-      "path": "controllers/slot-controller.d.ts",
-      "declarations": [
+        },
         {
           "kind": "class",
           "description": "",
@@ -8934,6 +9098,22 @@
         }
       ],
       "exports": [
+        {
+          "kind": "js",
+          "name": "isObjectSpread",
+          "declaration": {
+            "name": "isObjectSpread",
+            "module": "controllers/slot-controller.d.ts"
+          }
+        },
+        {
+          "kind": "js",
+          "name": "SlotControllerPublicAPI",
+          "declaration": {
+            "name": "SlotControllerPublicAPI",
+            "module": "controllers/slot-controller.d.ts"
+          }
+        },
         {
           "kind": "js",
           "name": "SlotController",
@@ -8948,6 +9128,15 @@
       "kind": "javascript-module",
       "path": "controllers/slot-controller.js",
       "declarations": [
+        {
+          "kind": "function",
+          "name": "isObjectSpread",
+          "parameters": [
+            {
+              "name": "config"
+            }
+          ]
+        },
         {
           "kind": "class",
           "description": "",
@@ -9012,6 +9201,14 @@
         }
       ],
       "exports": [
+        {
+          "kind": "js",
+          "name": "isObjectSpread",
+          "declaration": {
+            "name": "isObjectSpread",
+            "module": "controllers/slot-controller.js"
+          }
+        },
         {
           "kind": "js",
           "name": "SlotController",
@@ -9026,6 +9223,130 @@
       "kind": "javascript-module",
       "path": "controllers/slot-controller.ts",
       "declarations": [
+        {
+          "kind": "function",
+          "name": "isObjectSpread",
+          "return": {
+            "type": {
+              "text": "config is [SlotsConfig]"
+            }
+          },
+          "parameters": [
+            {
+              "name": "config",
+              "type": {
+                "text": "SlotControllerArgs"
+              }
+            }
+          ]
+        },
+        {
+          "kind": "class",
+          "description": "",
+          "name": "SlotControllerPublicAPI",
+          "members": [
+            {
+              "kind": "field",
+              "name": "default",
+              "type": {
+                "text": "symbol"
+              },
+              "static": true
+            },
+            {
+              "kind": "field",
+              "name": "host",
+              "type": {
+                "text": "ReactiveElement"
+              },
+              "privacy": "public"
+            },
+            {
+              "kind": "method",
+              "name": "hostConnected",
+              "return": {
+                "type": {
+                  "text": "Promise<void>"
+                }
+              }
+            },
+            {
+              "kind": "method",
+              "name": "hostDisconnected",
+              "return": {
+                "type": {
+                  "text": "void"
+                }
+              }
+            },
+            {
+              "kind": "method",
+              "name": "hostUpdated",
+              "return": {
+                "type": {
+                  "text": "void"
+                }
+              }
+            },
+            {
+              "kind": "method",
+              "name": "getSlotted",
+              "return": {
+                "type": {
+                  "text": "T[]"
+                }
+              },
+              "parameters": [
+                {
+                  "name": "slotNames",
+                  "type": {
+                    "text": "string[]"
+                  },
+                  "description": "slots to query"
+                }
+              ],
+              "description": "Given a slot name or slot names, returns elements assigned to the requested slots as an array.\nIf no value is provided, it returns all children not assigned to a slot (without a slot attribute)."
+            },
+            {
+              "kind": "method",
+              "name": "hasSlotted",
+              "return": {
+                "type": {
+                  "text": "boolean"
+                }
+              },
+              "parameters": [
+                {
+                  "name": "names",
+                  "type": {
+                    "text": "(string | null | undefined)[]"
+                  },
+                  "description": "The slot names to check."
+                }
+              ],
+              "description": "Returns a boolean statement of whether or not any of those slots exists in the light DOM."
+            },
+            {
+              "kind": "method",
+              "name": "isEmpty",
+              "return": {
+                "type": {
+                  "text": ""
+                }
+              },
+              "parameters": [
+                {
+                  "name": "names",
+                  "type": {
+                    "text": "(string | null | undefined)[]"
+                  },
+                  "description": "The slot names to query.  If no value is provided, it returns the default slot."
+                }
+              ],
+              "description": "Whether or not all the requested slots are empty."
+            }
+          ]
+        },
         {
           "kind": "class",
           "description": "",
@@ -9045,6 +9366,22 @@
         }
       ],
       "exports": [
+        {
+          "kind": "js",
+          "name": "isObjectSpread",
+          "declaration": {
+            "name": "isObjectSpread",
+            "module": "controllers/slot-controller.ts"
+          }
+        },
+        {
+          "kind": "js",
+          "name": "SlotControllerPublicAPI",
+          "declaration": {
+            "name": "SlotControllerPublicAPI",
+            "module": "controllers/slot-controller.ts"
+          }
+        },
         {
           "kind": "js",
           "name": "SlotController",
diff --git a/node_modules/@patternfly/pfe-core/functions/context.js b/node_modules/@patternfly/pfe-core/functions/context.js
index e46eac0..feff5a4 100644
--- a/node_modules/@patternfly/pfe-core/functions/context.js
+++ b/node_modules/@patternfly/pfe-core/functions/context.js
@@ -6,6 +6,11 @@ function makeContextRoot() {
     if (!isServer) {
         root.attach(document.body);
     }
+    else {
+        root.attach(
+        // @ts-expect-error: enable context root in ssr
+        globalThis.litServerRoot);
+    }
     return root;
 }
 /**
diff --git a/node_modules/@patternfly/pfe-core/functions/context.js.map b/node_modules/@patternfly/pfe-core/functions/context.js.map
index 3774125..11f9bc1 100644
--- a/node_modules/@patternfly/pfe-core/functions/context.js.map
+++ b/node_modules/@patternfly/pfe-core/functions/context.js.map
@@ -1 +1 @@
-{"version":3,"file":"context.js","sourceRoot":"","sources":["context.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,aAAa,EAAgB,MAAM,cAAc,CAAC;AACxE,OAAO,EAAE,QAAQ,EAAE,MAAM,KAAK,CAAC;AAE/B,IAAI,IAAiB,CAAC;AAEtB,SAAS,eAAe;IACtB,MAAM,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC;IAC/B,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,qBAAqB,CACnC,GAAG,IAAsC;IAEzC,IAAI,KAAJ,IAAI,GAAK,eAAe,EAAE,EAAC;IAC3B,OAAO,aAAa,CAAI,GAAG,IAAI,CAAC,CAAC;AACnC,CAAC","sourcesContent":["import { ContextRoot, createContext, type Context } from '@lit/context';\nimport { isServer } from 'lit';\n\nlet root: ContextRoot;\n\nfunction makeContextRoot() {\n  const root = new ContextRoot();\n  if (!isServer) {\n    root.attach(document.body);\n  }\n  return root;\n}\n\n/**\n * In order to prevent late-upgrading-context-consumers from 'missing'\n * their rightful context providers, we must set up a `ContextRoot` on the body.\n * Always use this function when creating contexts that are shared with child elements.\n * @param args createContext args\n */\nexport function createContextWithRoot<T>(\n  ...args: Parameters<typeof createContext>\n): Context<unknown, T> {\n  root ??= makeContextRoot();\n  return createContext<T>(...args);\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"context.js","sourceRoot":"","sources":["context.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,aAAa,EAAgB,MAAM,cAAc,CAAC;AACxE,OAAO,EAAE,QAAQ,EAAE,MAAM,KAAK,CAAC;AAE/B,IAAI,IAAiB,CAAC;AAEtB,SAAS,eAAe;IACtB,MAAM,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC;IAC/B,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,MAAM;QACT,+CAA+C;QAC/C,UAAU,CAAC,aAAa,CACzB,CAAC;IACJ,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,qBAAqB,CACnC,GAAG,IAAsC;IAEzC,IAAI,KAAJ,IAAI,GAAK,eAAe,EAAE,EAAC;IAC3B,OAAO,aAAa,CAAI,GAAG,IAAI,CAAC,CAAC;AACnC,CAAC","sourcesContent":["import { ContextRoot, createContext, type Context } from '@lit/context';\nimport { isServer } from 'lit';\n\nlet root: ContextRoot;\n\nfunction makeContextRoot() {\n  const root = new ContextRoot();\n  if (!isServer) {\n    root.attach(document.body);\n  } else {\n    root.attach(\n      // @ts-expect-error: enable context root in ssr\n      globalThis.litServerRoot,\n    );\n  }\n  return root;\n}\n\n/**\n * In order to prevent late-upgrading-context-consumers from 'missing'\n * their rightful context providers, we must set up a `ContextRoot` on the body.\n * Always use this function when creating contexts that are shared with child elements.\n * @param args createContext args\n */\nexport function createContextWithRoot<T>(\n  ...args: Parameters<typeof createContext>\n): Context<unknown, T> {\n  root ??= makeContextRoot();\n  return createContext<T>(...args);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/package.json b/node_modules/@patternfly/pfe-core/package.json
index ebd98c5..6974a01 100644
--- a/node_modules/@patternfly/pfe-core/package.json
+++ b/node_modules/@patternfly/pfe-core/package.json
@@ -32,7 +32,11 @@
     "./controllers/property-observer-controller.js": "./controllers/property-observer-controller.js",
     "./controllers/roving-tabindex-controller.js": "./controllers/roving-tabindex-controller.js",
     "./controllers/scroll-spy-controller.js": "./controllers/scroll-spy-controller.js",
-    "./controllers/slot-controller.js": "./controllers/slot-controller.js",
+    "./controllers/slot-controller.js": {
+      "node": "./controllers/slot-controller-server.js",
+      "import": "./controllers/slot-controller.js",
+      "default": "./controllers/slot-controller.js"
+    },
     "./controllers/style-controller.js": "./controllers/style-controller.js",
     "./controllers/timestamp-controller.js": "./controllers/timestamp-controller.js",
     "./controllers/tabs-controller.js": "./controllers/tabs-controller.js",
@@ -62,8 +66,8 @@
   },
   "dependencies": {
     "@floating-ui/dom": "^1.6.10",
-    "@lit/context": "^1.1.2",
-    "lit": "^3.2.0"
+    "@lit/context": "^1.1.3",
+    "lit": "^3.2.1"
   },
   "repository": {
     "type": "git",
diff --git a/node_modules/@patternfly/pfe-core/ssr-shims.d.ts b/node_modules/@patternfly/pfe-core/ssr-shims.d.ts
index f463291..cb0ff5c 100644
--- a/node_modules/@patternfly/pfe-core/ssr-shims.d.ts
+++ b/node_modules/@patternfly/pfe-core/ssr-shims.d.ts
@@ -1,17 +1 @@
-declare class ObserverShim {
-    observe(): void;
-    disconnect(): void;
-}
-declare class MiniHTMLElement {
-    tagName: string;
-    innerHTML: string;
-    constructor(tagName: string);
-}
-declare class MiniHTMLTemplateElement extends MiniHTMLElement {
-    content: {
-        cloneNode: () => string;
-    };
-}
-declare class MiniDocument {
-    createElement(tagName: string): MiniHTMLElement;
-}
+export {};
diff --git a/node_modules/@patternfly/pfe-core/ssr-shims.js b/node_modules/@patternfly/pfe-core/ssr-shims.js
index c8fe51d..1584acc 100644
--- a/node_modules/@patternfly/pfe-core/ssr-shims.js
+++ b/node_modules/@patternfly/pfe-core/ssr-shims.js
@@ -1,4 +1,5 @@
-"use strict";
+var _a;
+import { installWindowOnGlobal } from '@lit-labs/ssr/lib/dom-shim.js';
 class ObserverShim {
     observe() {
         void 0;
@@ -19,32 +20,7 @@ class MiniHTMLTemplateElement extends MiniHTMLElement {
         this.content = { cloneNode: () => this.innerHTML };
     }
 }
-class MiniDocument {
-    createElement(tagName) {
-        switch (tagName) {
-            case 'template':
-                return new MiniHTMLTemplateElement(tagName);
-            default:
-                return new MiniHTMLElement(tagName);
-        }
-    }
-}
-// @ts-expect-error: this runs in node
-globalThis.window ?? (globalThis.window = globalThis);
-// @ts-expect-error: this runs in node
-globalThis.document ?? (globalThis.document = new MiniDocument());
-// @ts-expect-error: this runs in node
-globalThis.navigator ?? (globalThis.navigator = { userAgent: '' });
-// @ts-expect-error: this runs in node
-globalThis.ErrorEvent ?? (globalThis.ErrorEvent = Event);
-// @ts-expect-error: this runs in node
-globalThis.IntersectionObserver ?? (globalThis.IntersectionObserver = ObserverShim);
-// @ts-expect-error: this runs in node
-globalThis.MutationObserver ?? (globalThis.MutationObserver = ObserverShim);
-// @ts-expect-error: this runs in node
-globalThis.ResizeObserver ?? (globalThis.ResizeObserver = ObserverShim);
-// @ts-expect-error: this runs in node
-globalThis.getComputedStyle ?? (globalThis.getComputedStyle = function () {
+function getComputedStyle() {
     return {
         getPropertyPriority() {
             return '';
@@ -53,5 +29,25 @@ globalThis.getComputedStyle ?? (globalThis.getComputedStyle = function () {
             return '';
         },
     };
+}
+;
+// @ts-expect-error: opt in to event support in ssr
+globalThis.litSsrCallConnectedCallback = true;
+installWindowOnGlobal({
+    ErrorEvent: Event,
+    IntersectionObserver: ObserverShim,
+    MutationObserver: ObserverShim,
+    ResizeObserver: ObserverShim,
+    getComputedStyle,
 });
+// @ts-expect-error: this runs in node
+(_a = globalThis.navigator).userAgent ?? (_a.userAgent = '@lit-labs/ssr');
+globalThis.document.createElement = function createElement(tagName) {
+    switch (tagName) {
+        case 'template':
+            return new MiniHTMLTemplateElement(tagName);
+        default:
+            return new MiniHTMLElement(tagName);
+    }
+};
 //# sourceMappingURL=ssr-shims.js.map
\ No newline at end of file
diff --git a/node_modules/@patternfly/pfe-core/ssr-shims.js.map b/node_modules/@patternfly/pfe-core/ssr-shims.js.map
index 8ef66dc..5a05b91 100644
--- a/node_modules/@patternfly/pfe-core/ssr-shims.js.map
+++ b/node_modules/@patternfly/pfe-core/ssr-shims.js.map
@@ -1 +1 @@
-{"version":3,"file":"ssr-shims.js","sourceRoot":"","sources":["ssr-shims.ts"],"names":[],"mappings":";AAAA,MAAM,YAAY;IAChB,OAAO;QACL,KAAK,CAAC,CAAC;IACT,CAAC;IAED,UAAU;QACR,KAAK,CAAC,CAAC;IACT,CAAC;CACF;AAED,MAAM,eAAe;IAEnB,YAAmB,OAAe;QAAf,YAAO,GAAP,OAAO,CAAQ;QADlC,cAAS,GAAG,EAAE,CAAC;IACuB,CAAC;CACxC;AAED,MAAM,uBAAwB,SAAQ,eAAe;IAArD;;QACE,YAAO,GAAG,EAAE,SAAS,EAAE,GAAW,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;IACxD,CAAC;CAAA;AAED,MAAM,YAAY;IAChB,aAAa,CAAC,OAAe;QAC3B,QAAQ,OAAO,EAAE,CAAC;YAChB,KAAK,UAAU;gBACb,OAAO,IAAI,uBAAuB,CAAC,OAAO,CAAC,CAAC;YAC9C;gBACE,OAAO,IAAI,eAAe,CAAC,OAAO,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;CACF;AAED,sCAAsC;AACtC,UAAU,CAAC,MAAM,KAAjB,UAAU,CAAC,MAAM,GAAK,UAAU,EAAC;AACjC,sCAAsC;AACtC,UAAU,CAAC,QAAQ,KAAnB,UAAU,CAAC,QAAQ,GAAK,IAAI,YAAY,EAAE,EAAC;AAC3C,sCAAsC;AACtC,UAAU,CAAC,SAAS,KAApB,UAAU,CAAC,SAAS,GAAK,EAAE,SAAS,EAAE,EAAE,EAAE,EAAC;AAC3C,sCAAsC;AACtC,UAAU,CAAC,UAAU,KAArB,UAAU,CAAC,UAAU,GAAK,KAAK,EAAC;AAChC,sCAAsC;AACtC,UAAU,CAAC,oBAAoB,KAA/B,UAAU,CAAC,oBAAoB,GAAK,YAAY,EAAC;AACjD,sCAAsC;AACtC,UAAU,CAAC,gBAAgB,KAA3B,UAAU,CAAC,gBAAgB,GAAK,YAAY,EAAC;AAC7C,sCAAsC;AACtC,UAAU,CAAC,cAAc,KAAzB,UAAU,CAAC,cAAc,GAAK,YAAY,EAAC;AAC3C,sCAAsC;AACtC,UAAU,CAAC,gBAAgB,KAA3B,UAAU,CAAC,gBAAgB,GAAK;IAC9B,OAAO;QACL,mBAAmB;YACjB,OAAO,EAAE,CAAC;QACZ,CAAC;QACD,gBAAgB;YACd,OAAO,EAAE,CAAC;QACZ,CAAC;KACF,CAAC;AACJ,CAAC,EAEA","sourcesContent":["class ObserverShim {\n  observe(): void {\n    void 0;\n  }\n\n  disconnect(): void {\n    void 0;\n  }\n}\n\nclass MiniHTMLElement {\n  innerHTML = '';\n  constructor(public tagName: string) { }\n}\n\nclass MiniHTMLTemplateElement extends MiniHTMLElement {\n  content = { cloneNode: (): string => this.innerHTML };\n}\n\nclass MiniDocument {\n  createElement(tagName: string): MiniHTMLElement {\n    switch (tagName) {\n      case 'template':\n        return new MiniHTMLTemplateElement(tagName);\n      default:\n        return new MiniHTMLElement(tagName);\n    }\n  }\n}\n\n// @ts-expect-error: this runs in node\nglobalThis.window ??= globalThis;\n// @ts-expect-error: this runs in node\nglobalThis.document ??= new MiniDocument();\n// @ts-expect-error: this runs in node\nglobalThis.navigator ??= { userAgent: '' };\n// @ts-expect-error: this runs in node\nglobalThis.ErrorEvent ??= Event;\n// @ts-expect-error: this runs in node\nglobalThis.IntersectionObserver ??= ObserverShim;\n// @ts-expect-error: this runs in node\nglobalThis.MutationObserver ??= ObserverShim;\n// @ts-expect-error: this runs in node\nglobalThis.ResizeObserver ??= ObserverShim;\n// @ts-expect-error: this runs in node\nglobalThis.getComputedStyle ??= function() {\n  return {\n    getPropertyPriority() {\n      return '';\n    },\n    getPropertyValue() {\n      return '';\n    },\n  };\n}\n\n;\n\n"]}
\ No newline at end of file
+{"version":3,"file":"ssr-shims.js","sourceRoot":"","sources":["ssr-shims.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,qBAAqB,EAAE,MAAM,+BAA+B,CAAC;AAEtE,MAAM,YAAY;IAChB,OAAO;QACL,KAAK,CAAC,CAAC;IACT,CAAC;IAED,UAAU;QACR,KAAK,CAAC,CAAC;IACT,CAAC;CACF;AAED,MAAM,eAAe;IAEnB,YAAmB,OAAe;QAAf,YAAO,GAAP,OAAO,CAAQ;QADlC,cAAS,GAAG,EAAE,CAAC;IACuB,CAAC;CACxC;AAED,MAAM,uBAAwB,SAAQ,eAAe;IAArD;;QACE,YAAO,GAAG,EAAE,SAAS,EAAE,GAAW,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;IACxD,CAAC;CAAA;AAED,SAAS,gBAAgB;IACvB,OAAO;QACL,mBAAmB;YACjB,OAAO,EAAE,CAAC;QACZ,CAAC;QACD,gBAAgB;YACd,OAAO,EAAE,CAAC;QACZ,CAAC;KACF,CAAC;AACJ,CAAC;AAAA,CAAC;AAEF,mDAAmD;AACnD,UAAU,CAAC,2BAA2B,GAAG,IAAI,CAAC;AAE9C,qBAAqB,CAAC;IACpB,UAAU,EAAE,KAAK;IACjB,oBAAoB,EAAE,YAAY;IAClC,gBAAgB,EAAE,YAAY;IAC9B,cAAc,EAAE,YAAY;IAC5B,gBAAgB;CACjB,CAAC,CAAC;AAEH,sCAAsC;AACtC,MAAA,UAAU,CAAC,SAAS,EAAC,SAAS,QAAT,SAAS,GAAK,eAAe,EAAC;AAEnD,UAAU,CAAC,QAAQ,CAAC,aAAa,GAAG,SAAS,aAAa,CAAC,OAAe;IACxE,QAAQ,OAAO,EAAE,CAAC;QAChB,KAAK,UAAU;YACb,OAAO,IAAI,uBAAuB,CAAC,OAAO,CAA2B,CAAC;QACxE;YACE,OAAO,IAAI,eAAe,CAAC,OAAO,CAAgB,CAAC;IACvD,CAAC;AACH,CAAC,CAAC","sourcesContent":["import { installWindowOnGlobal } from '@lit-labs/ssr/lib/dom-shim.js';\n\nclass ObserverShim {\n  observe(): void {\n    void 0;\n  }\n\n  disconnect(): void {\n    void 0;\n  }\n}\n\nclass MiniHTMLElement {\n  innerHTML = '';\n  constructor(public tagName: string) { }\n}\n\nclass MiniHTMLTemplateElement extends MiniHTMLElement {\n  content = { cloneNode: (): string => this.innerHTML };\n}\n\nfunction getComputedStyle() {\n  return {\n    getPropertyPriority() {\n      return '';\n    },\n    getPropertyValue() {\n      return '';\n    },\n  };\n};\n\n// @ts-expect-error: opt in to event support in ssr\nglobalThis.litSsrCallConnectedCallback = true;\n\ninstallWindowOnGlobal({\n  ErrorEvent: Event,\n  IntersectionObserver: ObserverShim,\n  MutationObserver: ObserverShim,\n  ResizeObserver: ObserverShim,\n  getComputedStyle,\n});\n\n// @ts-expect-error: this runs in node\nglobalThis.navigator.userAgent ??= '@lit-labs/ssr';\n\nglobalThis.document.createElement = function createElement(tagName: string): HTMLElement {\n  switch (tagName) {\n    case 'template':\n      return new MiniHTMLTemplateElement(tagName) as unknown as HTMLElement;\n    default:\n      return new MiniHTMLElement(tagName) as HTMLElement;\n  }\n};\n"]}
\ No newline at end of file
